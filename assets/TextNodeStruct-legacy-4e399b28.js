System.register(["./CoreExtension-legacy-ac715ad4.js"],(function(t,e){"use strict";var r,o,s,n,i,a,l,c,h,d,u,p,f,m,g,x,y,v,_,w;return{setters:[t=>{r=t.E,o=t.g,s=t.m,n=t.a,i=t.b,a=t.c,l=t.T,c=t.d,h=t.e,d=t.i,u=t.S,p=t.f,f=t.B,m=t.h,g=t.j,x=t.k,y=t.W,v=t.l,_=t.n,w=t.C}],execute:function(){t("l",(async function(t,r){let o;try{console.log("Loading core extension",t),o=await nt((()=>e.import(t)),void 0)}catch(n){return console.error(`The core extension module at '${t}' could not be loaded.`),void console.error(n)}if(!o.default)return void console.error(`The core extension module at '${t}' does not have a default export.`);const s=o.default;if(s.prototype instanceof w){const e=new s;try{await e.run(r)}catch(n){console.error(`The core extension at '${t}' threw an error.`),console.error(n)}}else console.error(`The core extension at '${t}' does not extend CoreExtension.`)})),t("a",class extends r{node;props;settings;propStartValues={};restoreValues={};progress=0;timingFunction;constructor(t,e,r){super(),this.node=t,this.props=e,this.settings=r,this.propStartValues={},Object.keys(e).forEach((e=>{this.propStartValues[e]=t[e]})),this.timingFunction=t=>t,r.easing&&"string"==typeof r.easing&&(this.timingFunction=o(r.easing))}reset(){this.progress=0,this.update(0)}restore(){this.reset(),Object.keys(this.props).forEach((t=>{this.node[t]=this.propStartValues[t]}))}reverse(){this.progress=0,Object.keys(this.props).forEach((t=>{const e=this.props[t],r=this.propStartValues[t];this.props[t]=r,this.propStartValues[t]=e})),this.settings.loop||(this.settings.stopMethod=!1)}applyEasing(t,e,r){return(this.timingFunction(t)||t)*(r-e)+e}update(t){const{duration:e,loop:r,easing:o}=this.settings;e?(this.progress+=t/e,this.progress>1&&(this.progress=r?0:1,this.emit("finished",{})),Object.keys(this.props).forEach((t=>{const e=this.props[t],r=this.propStartValues[t],n=e;if(-1!==t.indexOf("color")){const e=o&&this.timingFunction(this.progress)||this.progress,i=s(r,n,e);this.node[t]=o?i:s(r,n,this.progress)}else this.node[t]=o?this.applyEasing(this.progress,r,n):r+(n-r)*this.progress}))):this.emit("finished",{})}}),t("b",class{manager;animation;stoppedPromise=null;stoppedResolve=null;constructor(t,e){this.manager=t,this.animation=e,this.state="stopped"}state;start(){return this.makeStoppedPromise(),this.animation.once("finished",this.finished.bind(this)),this.manager.activeAnimations.has(this.animation)||this.manager.registerAnimation(this.animation),this.state="running",this}stop(){return this.manager.unregisterAnimation(this.animation),null!==this.stoppedResolve&&(this.stoppedResolve(),this.stoppedResolve=null),this.animation.reset(),this.state="stopped",this}pause(){return this.manager.unregisterAnimation(this.animation),this.state="paused",this}restore(){return this.stoppedResolve=null,this.animation.restore(),this}waitUntilStopped(){this.makeStoppedPromise();const t=this.stoppedPromise;return n(t),t}makeStoppedPromise(){null===this.stoppedResolve&&(this.stoppedPromise=new Promise((t=>{this.stoppedResolve=t})))}finished(){n(this.stoppedResolve);const{loop:t,stopMethod:e}=this.animation.settings;if("reverse"===e)return this.animation.reverse(),void this.start();this.stoppedResolve(),this.stoppedResolve=null,t||this.manager.unregisterAnimation(this.animation)}});class b{alpha=1;px=0;py=0;ta=1;tb=0;tc=0;td=1;isIdentity(){return 1===this.alpha&&0===this.px&&0===this.py&&this.isIdentityMatrix()}isIdentityMatrix(){return 1===this.ta&&0===this.tb&&0===this.tc&&1===this.td}isSquare(){return 0===this.tb&&0===this.tc}}class S extends r{stage;children=[];props;recalculationType=6;hasUpdates=!0;worldContext=new b;localPx=0;localPy=0;isComplex=!1;constructor(t,e){super(),this.stage=t,this.props={...e,parent:null,ta:e.ta??1,tb:e.tb??0,tc:e.tc??0,td:e.td??1,worldX:e.worldX??0,worldY:e.worldY??0},this.parent=e.parent,this.updateLocalTransform()}loadTexture(t,e,r=null){this.props.texture&&this.unloadTexture();const{txManager:o}=this.stage,s=o.loadTexture(t,e,r);this.props.texture=s,this.props.textureOptions=r,queueMicrotask((()=>{"loaded"===s.state?this.onTextureLoaded(s,s.dimensions):"failed"===s.state&&this.onTextureFailed(s,s.error),s.on("loaded",this.onTextureLoaded),s.on("failed",this.onTextureFailed)}))}unloadTexture(){this.props.texture&&(this.props.texture.off("loaded",this.onTextureLoaded),this.props.texture.off("failed",this.onTextureFailed)),this.props.texture=null,this.props.textureOptions=null}onTextureLoaded=(t,e)=>{this.emit("txLoaded",e)};onTextureFailed=(t,e)=>{this.emit("txFailed",e)};loadShader(t,e){const r=this.stage.renderer.getShaderManager();n(r);const{shader:o,props:s}=r.loadShader(t,e);this.props.shader=o,this.props.shaderProps=s}setHasUpdates(){if(!this.props.alpha)return;this.hasUpdates=!0;let t=this?.props.parent;for(;t;)t.hasUpdates=!0,t=t?.props.parent}setRecalculationType(t){this.recalculationType|=t,this.setHasUpdates()}updateLocalTransform(){if(0!==this.props.rotation&&this.props.rotation%(2*Math.PI)){const t=Math.sin(this.props.rotation),e=Math.cos(this.props.rotation);this.setLocalTransform(e*this.props.scale,-t*this.props.scale,t*this.props.scale,e*this.props.scale)}else this.setLocalTransform(this.props.scale,0,0,this.props.scale);this.updateLocalTranslate()}setLocalTransform(t,e,r,o){this.setRecalculationType(4),this.props.ta=t,this.props.tb=e,this.props.tc=r,this.props.td=o,this.isComplex=0!==e||0!==r||t<0||o<0}updateLocalTranslate(){this.setRecalculationType(2);const t=this.props.pivotX*this.props.width,e=this.props.pivotY*this.props.height;let r=this.props.x-(t*this.props.ta+e*this.props.tb)+t,o=this.props.y-(t*this.props.tc+e*this.props.td)+e;r-=this.props.mountX*this.props.width,o-=this.props.mountY*this.props.height,this.localPx=r,this.localPy=o}update(t){const e=this.props.parent?.worldContext,r=this.worldContext;r.px=(e?.px||0)+this.localPx*(e?.ta||1),r.py=(e?.py||0)+this.localPy*(e?.td||1),0!==e?.tb&&(r.px+=this.localPy*(e?.tb||0)),0!==e?.tc&&(r.py+=this.localPx*(e?.tc||0)),r.ta=this.props.ta*(e?.ta||1),r.tb=this.props.td*(e?.tb||0),r.tc=this.props.ta*(e?.tc||0),r.td=this.props.td*(e?.td||1),this.isComplex&&(r.ta+=this.props.tc*(e?.tb||0),r.tb+=this.props.tb*(e?.ta||1),r.tc+=this.props.tc*(e?.td||1),r.td+=this.props.tb*(e?.tc||0)),this.worldX=r.px,this.worldY=r.py,this.children.length&&this.children.forEach((e=>{e.update(t)})),this.hasUpdates=!1,this.recalculationType=0}renderQuads(t,e){const{width:r,height:o,colorTl:s,colorTr:n,colorBl:i,colorBr:a,texture:l,textureOptions:c,shader:h,shaderProps:d,scale:u}=this.props,{zIndex:p,alpha:f,worldScale:m}=this;t.addRenderable({width:r,height:o,colorTl:s,colorTr:n,colorBl:i,colorBr:a,texture:l,textureOptions:c,zIndex:p,shader:h,shaderProps:d,alpha:f,scale:u,clippingRect:e,wpx:this.worldContext.px,wpy:this.worldContext.py,worldScale:m,ta:this.worldContext.ta,tb:this.worldContext.tb,tc:this.worldContext.tc,td:this.worldContext.td})}get id(){return this.props.id}get x(){return this.props.x}set x(t){this.props.x!==t&&(this.props.x=t,this.updateLocalTranslate())}get worldX(){return this.props.worldX||0}set worldX(t){this.props.worldX=t}get worldY(){return this.props.worldY||0}set worldY(t){this.props.worldY=t}get absX(){return this.props.x+(this.props.parent?.absX||this.props.parent?.worldContext.px||0)}get absY(){return this.props.y+(this.props.parent?.absY??0)}get y(){return this.props.y}set y(t){this.props.y!==t&&(this.props.y=t,this.updateLocalTranslate())}get width(){return this.props.width}set width(t){this.props.width!==t&&(this.props.width=t,this.updateLocalTransform())}get height(){return this.props.height}set height(t){this.props.height!==t&&(this.props.height=t,this.updateLocalTransform())}get scale(){return this.props.scale}set scale(t){this.props.scale!==t&&(this.props.scale=t,this.updateLocalTransform())}get worldScale(){return this.props.scale*(this.props.parent?.worldScale??1)||this.props.scale}get mount(){return this.props.mount}set mount(t){this.props.mountX=t,this.props.mountY=t,this.props.mount=t,this.updateLocalTranslate()}get mountX(){return this.props.mountX}set mountX(t){this.props.mountX=t,this.updateLocalTranslate()}get mountY(){return this.props.mountY}set mountY(t){this.props.mountY=t,this.updateLocalTranslate()}get pivot(){return this.props.pivot}set pivot(t){this.props.pivotX===t&&this.props.pivotY===t||(this.props.pivotX=t,this.props.pivotY=t,this.updateLocalTranslate())}get pivotX(){return this.props.pivotX}set pivotX(t){this.props.pivotX=t,this.updateLocalTranslate()}get pivotY(){return this.props.pivotY}set pivotY(t){this.props.pivotY=t,this.updateLocalTranslate()}get rotation(){return this.props.rotation}set rotation(t){this.props.rotation!==t&&(this.props.rotation=t,this.updateLocalTransform())}get alpha(){const t=this.props,e=t.parent;return e?t.alpha*e.alpha:1}set alpha(t){this.props.alpha=t}get clipping(){return this.props.clipping}set clipping(t){this.props.clipping=t}get color(){return this.props.color}set color(t){this.props.colorTl===t&&this.props.colorTr===t&&this.props.colorBl===t&&this.props.colorBr===t||(this.colorTl=t,this.colorTr=t,this.colorBl=t,this.colorBr=t),this.props.color=t}get colorTop(){return this.props.colorTop}set colorTop(t){this.props.colorTl===t&&this.props.colorTr===t||(this.colorTl=t,this.colorTr=t),this.props.colorTop=t}get colorBottom(){return this.props.colorBottom}set colorBottom(t){this.props.colorBl===t&&this.props.colorBr===t||(this.colorBl=t,this.colorBr=t),this.props.colorBottom=t}get colorLeft(){return this.props.colorLeft}set colorLeft(t){this.props.colorTl===t&&this.props.colorBl===t||(this.colorTl=t,this.colorBl=t),this.props.colorLeft=t}get colorRight(){return this.props.colorRight}set colorRight(t){this.props.colorTr===t&&this.props.colorBr===t||(this.colorTr=t,this.colorBr=t),this.props.colorRight=t}get colorTl(){return this.props.colorTl}set colorTl(t){this.props.colorTl=t}get colorTr(){return this.props.colorTr}set colorTr(t){this.props.colorTr=t}get colorBl(){return this.props.colorBl}set colorBl(t){this.props.colorBl=t}get colorBr(){return this.props.colorBr}set colorBr(t){this.props.colorBr=t}get zIndexLocked(){return this.props.zIndexLocked||0}set zIndexLocked(t){this.props.zIndexLocked=t}get zIndex(){const t=this.props,e=t.zIndex||0,r=t.parent?.zIndex||0;return t.parent?.zIndexLocked?e<r?e:r:e}set zIndex(t){this.props.zIndex=t}get parent(){return this.props.parent}set parent(t){const e=this.props.parent;if(e!==t){if(this.props.parent=t,e){const t=e.children.indexOf(this);n(-1!==t,"CoreNode.parent: Node not found in old parent's children!"),e.children.splice(t,1)}t&&t.children.push(this),this.updateLocalTransform()}}}t("C",S);class T{root;constructor(t){this.root=t}getNodeByType(t){return[]}getNodeById(t){return null}update(t){this.root.update(t)}}class C extends i{constructor(t){super({renderer:t,attributes:["a_position","a_textureCoordinate","a_color"],uniforms:[{name:"u_resolution",uniform:"uniform2fv"},{name:"u_pixelRatio",uniform:"uniform1f"},{name:"u_texture",uniform:"uniform2fv"}]})}bindTextures(t){const{gl:e}=this;e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,t[0].ctxTexture)}static shaderSources={vertex:"\n      # ifdef GL_FRAGMENT_PRESICISON_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      attribute vec2 a_position;\n      attribute vec2 a_textureCoordinate;\n      attribute vec4 a_color;\n\n      uniform vec2 u_resolution;\n      uniform float u_pixelRatio;\n\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoordinate;\n\n      void main() {\n        vec2 normalized = a_position * u_pixelRatio / u_resolution;\n        vec2 zero_two = normalized * 2.0;\n        vec2 clip_space = zero_two - 1.0;\n\n        // pass to fragment\n        v_color = a_color;\n        v_textureCoordinate = a_textureCoordinate;\n\n        // flip y\n        gl_Position = vec4(clip_space * vec2(1.0, -1.0), 0, 1);\n      }\n    ",fragment:"\n      # ifdef GL_FRAGMENT_PRESICISON_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      uniform vec2 u_resolution;\n      uniform sampler2D u_texture;\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoordinate;\n\n      void main() {\n          vec4 color = texture2D(u_texture, v_textureCoordinate);\n          gl_FragColor = vec4(v_color) * texture2D(u_texture, v_textureCoordinate);\n      }\n    "}}class I extends i{supportsIndexedTextures=!0;constructor(t){super({renderer:t,attributes:["a_position","a_textureCoordinate","a_color","a_textureIndex"],uniforms:[{name:"u_resolution",uniform:"uniform2fv"},{name:"u_pixelRatio",uniform:"uniform1f"},{name:"u_textures[0]",uniform:"uniform1iv"}]})}bindTextures(t){const{renderer:e,gl:r}=this;if(t.length>e.system.parameters.MAX_VERTEX_TEXTURE_IMAGE_UNITS)throw new Error(`DefaultShaderBatched: Cannot bind more than ${e.system.parameters.MAX_VERTEX_TEXTURE_IMAGE_UNITS} textures`);t.forEach(((t,e)=>{r.activeTexture(r.TEXTURE0+e),r.bindTexture(r.TEXTURE_2D,t.ctxTexture)}));const o=Array.from(Array(t.length).keys());this.setUniform("u_textures[0]",o)}static shaderSources={vertex:"\n      # ifdef GL_FRAGMENT_PRESICISON_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      attribute vec2 a_textureCoordinate;\n      attribute vec2 a_position;\n      attribute vec4 a_color;\n      attribute float a_textureIndex;\n      attribute float a_depth;\n\n      uniform vec2 u_resolution;\n      uniform float u_pixelRatio;\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoordinate;\n      varying float v_textureIndex;\n\n      void main(){\n        vec2 normalized = a_position * u_pixelRatio / u_resolution;\n        vec2 zero_two = normalized * 2.0;\n        vec2 clip_space = zero_two - 1.0;\n\n        // pass to fragment\n        v_color = a_color;\n        v_textureCoordinate = a_textureCoordinate;\n        v_textureIndex = a_textureIndex;\n\n        // flip y\n        gl_Position = vec4(clip_space * vec2(1.0, -1.0), 0, 1);\n      }\n    ",fragment:t=>`\n      #define txUnits ${t}\n      # ifdef GL_FRAGMENT_PRESICISON_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      uniform vec2 u_resolution;\n      uniform sampler2D u_image;\n      uniform sampler2D u_textures[txUnits];\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoordinate;\n      varying float v_textureIndex;\n\n      vec4 sampleFromTexture(sampler2D textures[${t}], int idx, vec2 uv) {\n        ${Array.from(Array(t).keys()).map((t=>`\n          ${0!==t?"else ":""}if (idx == ${t}) {\n            return texture2D(textures[${t}], uv);\n          }\n        `)).join("")}\n        return texture2D(textures[0], uv);\n      }\n\n      void main(){\n        gl_FragColor = vec4(v_color) * sampleFromTexture(u_textures, int(v_textureIndex), v_textureCoordinate);\n      }\n    `}}class R{priority=1;name="";ref;target;passParameters="";declaredUniforms="";uniformInfo={};static uniforms={};static methods;static onShaderMask;static onColorize;static onEffectMask;static getEffectKey(t){return""}static getMethodParameters(t,e){const r=[];for(const o in t){const s=t[o];let n="";s.size&&(n=`[${s.size(e)}]`),r.push(`${s.type} ${o}${n}`)}return r.join(",")}constructor(t){const{ref:e,target:r,props:o={}}=t;this.ref=e,this.target=r;const s={},n=[];let i="";const a=this.constructor.uniforms||{};for(const l in a){const t=a[l],r=t.type,c=`${e}_${l}`;let h="";t.size&&(h=`[${t.size(o)}]`),n.push(c),i+=`uniform ${r} ${c}${h};`,s[l]={name:c,uniform:a[l].method}}this.passParameters=n.join(","),this.declaredUniforms=i,this.uniformInfo=s}static resolveDefaults(t){return{}}static makeEffectKey(t){return!1}}class k extends R{static z$__type__Props;name="radius";static getEffectKey(){return"radius"}static uniforms={radius:{value:0,method:"uniform4fv",type:"vec4",validator:t=>{let e=t;return Array.isArray(e)?2===e.length?e=[e[0],e[1],e[0],e[1]]:3===e.length?e=[e[0],e[1],e[2],e[0]]:4!==e.length&&(e=[e[0],e[0],e[0],e[0]]):"number"==typeof e&&(e=[e,e,e,e]),e}}};static methods={fillMask:"\n      float function(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n    ",boxDist:"\n      float function(vec2 p, vec2 size, float radius) {\n        size -= vec2(radius);\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n      }\n    "};static resolveDefaults(t){return{radius:t.radius??10}}static onShaderMask="\n  vec2 halfDimensions = u_dimensions * 0.5;\n  float r = radius[0] * step(v_textureCoordinate.x, 0.5) * step(v_textureCoordinate.y, 0.5);\n  r = r + radius[1] * step(0.5, v_textureCoordinate.x) * step(v_textureCoordinate.y, 0.5);\n  r = r + radius[2] * step(0.5, v_textureCoordinate.x) * step(0.5, v_textureCoordinate.y);\n  r = r + radius[3] * step(v_textureCoordinate.x, 0.5) * step(0.5, v_textureCoordinate.y);\n  return $boxDist(v_textureCoordinate.xy * u_dimensions - halfDimensions, halfDimensions, r);\n  ";static onEffectMask="\n  return mix(vec4(0.0), maskColor, $fillMask(shaderMask));\n  "}class E extends R{static z$__type__Props;name="border";static getEffectKey(){return"border"}static resolveDefaults(t){return{width:t.width??10,color:t.color??4294967295}}static uniforms={width:{value:0,method:"uniform1f",type:"float"},color:{value:4294967295,validator:t=>a(t),method:"uniform4fv",type:"vec4"}};static onEffectMask="\n  float mask = clamp(shaderMask + width, 0.0, 1.0) - clamp(shaderMask, 0.0, 1.0);\n  return mix(shaderColor, maskColor, mask);\n  ";static onColorize="\n    return color;\n  "}class M extends R{static z$__type__Props;name="linearGradient";static getEffectKey(t){return`linearGradient${t.colors.length}`}static resolveDefaults(t){const e=t.colors??[4278190080,4294967295];let r=t.stops;if(!r){r=[];const t=e.length-1;for(let o=0;o<e.length;o++)r.push(o*(1/t))}return{colors:e,stops:r,angle:t.angle??0}}static uniforms={angle:{value:0,method:"uniform1f",type:"float"},colors:{value:4294967295,validator:t=>t.map((t=>a(t))).reduce(((t,e)=>t.concat(e)),[]),size:t=>t.colors.length,method:"uniform4fv",type:"vec4"},stops:{value:[],validator:(t,e)=>{const r=e.colors??[];let o=t;const s=t;if(0===o.length||o&&o.length!==r.length){for(let t=0;t<r.length;t++)o[t]?(s[t]=o[t],void 0===o[t-1]&&void 0!==s[t-2]&&(s[t-1]=s[t-2]+(o[t]-s[t-2])/2)):s[t]=t*(1/(r.length-1));o=s}return s},size:t=>t.colors.length,method:"uniform1fv",type:"float"}};static methods={fromLinear:"\n      vec4 function(vec4 linearRGB) {\n        vec4 higher = vec4(1.055)*pow(linearRGB, vec4(1.0/2.4)) - vec4(0.055);\n        vec4 lower = linearRGB * vec4(12.92);\n        return mix(higher, lower, 1.0);\n      }\n    ",toLinear:"\n      vec4 function(vec4 sRGB) {\n        vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));\n        vec4 lower = sRGB/vec4(12.92);\n        return mix(higher, lower, 1.0);\n      }\n    ",calcPoint:"\n      vec2 function(float d, float angle) {\n        return d * vec2(cos(angle), sin(angle)) + (u_dimensions * 0.5);\n      }\n    "};static ColorLoop=t=>{let e="";for(let r=2;r<t;r++)e+=`colorOut = mix(colorOut, colors[${r}], clamp((dist - stops[${r-1}]) / (stops[${r}] - stops[${r-1}]), 0.0, 1.0));`;return e};static onColorize=t=>`\n      float a = angle - (PI / 180.0 * 90.0);\n      float lineDist = abs(u_dimensions.x * cos(a)) + abs(u_dimensions.y * sin(a));\n      vec2 f = $calcPoint(lineDist * 0.5, a);\n      vec2 t = $calcPoint(lineDist * 0.5, a + PI);\n      vec2 gradVec = t - f;\n      float dist = dot(v_textureCoordinate.xy * u_dimensions - f, gradVec) / dot(gradVec, gradVec);\n\n      float stopCalc = (dist - stops[0]) / (stops[1] - stops[0]);\n      vec4 colorOut = $fromLinear(mix($toLinear(colors[0]), $toLinear(colors[1]), stopCalc));\n      for(int i = 1; i < ${t.colors.length||1}-1; i++) {\n        stopCalc = (dist - stops[i]) / (stops[i + 1] - stops[i]);\n        colorOut = mix(colorOut, colors[i + 1], clamp(stopCalc, 0.0, 1.0));\n      }\n      return mix(maskColor, colorOut, clamp(colorOut.a, 0.0, 1.0));\n    `}class F extends R{name="grayscale";static getEffectKey(){return"grayscale"}static onColorize="\n    vec3 color = pow(maskColor.rgb, vec3(2.0));\n    float gray = dot(color, vec3(0.2126, 0.7152, 0.0722));\n    float gammaGray = sqrt(gray);\n    return vec4(gammaGray, gammaGray, gammaGray, 1.0);\n  "}class O extends R{static z$__type__Props;name="borderRight";static getEffectKey(){return"borderRight"}static resolveDefaults(t){return{width:t.width??10,color:t.color??4294967295}}static uniforms={width:{value:0,method:"uniform1f",type:"float"},color:{value:4294967295,validator:t=>a(t),method:"uniform4fv",type:"vec4"}};static methods={fillMask:"\n      float function(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n    ",rectDist:"\n      float function(vec2 p, vec2 size) {\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n      }\n    "};static onEffectMask="\n  vec2 pos = vec2(u_dimensions.x - width * 0.5, 0.0);\n  float mask = $rectDist(v_textureCoordinate.xy * u_dimensions - pos, vec2(width*0.5, u_dimensions.y));\n  return mix(shaderColor, maskColor, $fillMask(mask));\n  ";static onColorize="\n    return color;\n  "}class z extends R{static z$__type__Props;name="borderTop";static getEffectKey(){return"borderTop"}static resolveDefaults(t){return{width:t.width??10,color:t.color??4294967295}}static uniforms={width:{value:0,method:"uniform1f",type:"float"},color:{value:4294967295,validator:t=>a(t),method:"uniform4fv",type:"vec4"}};static methods={fillMask:"\n      float function(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n    ",rectDist:"\n      float function(vec2 p, vec2 size) {\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n      }\n    "};static onEffectMask="\n  vec2 pos = vec2(0.0, width * 0.5);\n  float mask = $rectDist(v_textureCoordinate.xy * u_dimensions - pos, vec2(u_dimensions.x, width*0.5));\n  return mix(shaderColor, maskColor, $fillMask(mask));\n  ";static onColorize="\n    return color;\n  "}class D extends R{static z$__type__Props;name="borderBottom";static getEffectKey(){return"borderBottom"}static resolveDefaults(t){return{width:t.width??10,color:t.color??4294967295}}static uniforms={width:{value:0,method:"uniform1f",type:"float"},color:{value:4294967295,validator:t=>a(t),method:"uniform4fv",type:"vec4"}};static methods={fillMask:"\n      float function(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n    ",rectDist:"\n      float function(vec2 p, vec2 size) {\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n      }\n    "};static onEffectMask="\n  vec2 pos = vec2(0.0, u_dimensions.y - width * 0.5);\n  float mask = $rectDist(v_textureCoordinate.xy * u_dimensions - pos, vec2(u_dimensions.x, width*0.5));\n  return mix(shaderColor, maskColor, $fillMask(mask));\n  ";static onColorize="\n    return color;\n  "}class A extends R{static z$__type__Props;name="borderLeft";static getEffectKey(){return"borderLeft"}static resolveDefaults(t){return{width:t.width??10,color:t.color??4294967295}}static uniforms={width:{value:0,method:"uniform1f",type:"float"},color:{value:4294967295,validator:t=>a(t),method:"uniform4fv",type:"vec4"}};static methods={fillMask:"\n      float function(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n    ",rectDist:"\n      float function(vec2 p, vec2 size) {\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n      }\n    "};static onEffectMask="\n  vec2 pos = vec2(width * 0.5, 0.0);\n  float mask = $rectDist(v_textureCoordinate.xy * u_dimensions - pos, vec2(width*0.5, u_dimensions.y));\n  return mix(shaderColor, maskColor, $fillMask(mask));\n  ";static onColorize="\n    return color;\n  "}class $ extends R{static z$__type__Props;name="glitch";static getEffectKey(t){return"glitch"}static resolveDefaults(t){return{amplitude:t.amplitude??.2,narrowness:t.narrowness??4,blockiness:t.blockiness??2,minimizer:t.minimizer??8,time:t.time??Date.now()}}static uniforms={amplitude:{value:0,method:"uniform1f",type:"float"},narrowness:{value:0,method:"uniform1f",type:"float"},blockiness:{value:0,method:"uniform1f",type:"float"},minimizer:{value:0,method:"uniform1f",type:"float"},time:{value:0,method:"uniform1f",validator:t=>(Date.now()-t)%1e3,type:"float"}};static methods={rand:"\n      float function(vec2 p, float time) {\n        float t = floor(time * 20.) / 10.;\n        return fract(sin(dot(p, vec2(t * 12.9898, t * 78.233))) * 43758.5453);\n      }\n    ",noise:"\n      float function(vec2 uv, float blockiness, float time) {\n        vec2 lv = fract(uv);\n        vec2 id = floor(uv);\n\n        float n1 = rand(id, time);\n        float n2 = rand(id+vec2(1,0), time);\n        float n3 = rand(id+vec2(0,1), time);\n        float n4 = rand(id+vec2(1,1), time);\n        vec2 u = smoothstep(0.0, 1.0 + blockiness, lv);\n        return mix(mix(n1, n2, u.x), mix(n3, n4, u.x), u.y);\n      }\n    ",fbm:"\n      float function(vec2 uv, int count, float blockiness, float complexity, float time) {\n        float val = 0.0;\n        float amp = 0.5;\n        const int MAX_ITERATIONS = 10;\n\n        for(int i = 0; i < MAX_ITERATIONS; i++) {\n          if(i >= count) {break;}\n          val += amp * noise(uv, blockiness, time);\n          amp *= 0.5;\n          uv *= complexity;\n        }\n        return val;\n      }\n    "};static onColorize="\n    vec2 uv = v_textureCoordinate.xy;\n    float aspect = u_dimensions.x / u_dimensions.y;\n    vec2 a = vec2(uv.x * aspect , uv.y);\n    vec2 uv2 = vec2(a.x / u_dimensions.x, exp(a.y));\n\n    float shift = amplitude * pow($fbm(uv2, 4, blockiness, narrowness, time), minimizer);\n    float colR = texture2D(u_texture, vec2(uv.x + shift, uv.y)).r * (1. - shift);\n    float colG = texture2D(u_texture, vec2(uv.x - shift, uv.y)).g * (1. - shift);\n    float colB = texture2D(u_texture, vec2(uv.x - shift, uv.y)).b * (1. - shift);\n\n    vec3 f = vec3(colR, colG, colB);\n    return vec4(f, texture2D(u_texture, vec2(uv.x - shift, uv.y)).a);\n  "}class P extends R{static z$__type__Props;name="fadeOut";static getEffectKey(){return"fadeOut"}static uniforms={fade:{value:0,method:"uniform4fv",type:"vec4",validator:t=>{let e=t;return Array.isArray(e)?2===e.length?e=[e[0],e[1],e[0],e[1]]:3===e.length?e=[e[0],e[1],e[2],e[0]]:4!==e.length&&(e=[e[0],e[0],e[0],e[0]]):"number"==typeof e&&(e=[e,e,e,e]),e}}};static resolveDefaults(t){return{fade:t.fade??10}}static onColorize="\n  vec2 point = v_textureCoordinate.xy * u_dimensions.xy;\n  vec2 pos1;\n  vec2 pos2;\n  vec2 d;\n  float c;\n  vec4 result = maskColor;\n\n\n  if(fade[0] > 0.0) {\n    pos1 = vec2(point.x, point.y);\n    pos2 = vec2(point.x, point.y + fade[0]);\n    d = pos2 - pos1;\n    c = dot(pos1, d) / dot(d, d);\n    result = mix(vec4(0.0), result, smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0)));\n  }\n\n  if(fade[1] > 0.0) {\n    pos1 = vec2(point.x - u_dimensions.x - fade[1], v_textureCoordinate.y);\n    pos2 = vec2(point.x - u_dimensions.x, v_textureCoordinate.y);\n    d = pos1 - pos2;\n    c = dot(pos2, d) / dot(d, d);\n    result = mix(vec4(0.0), result, smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0)));\n  }\n\n  if(fade[2] > 0.0) {\n    pos1 = vec2(v_textureCoordinate.x, point.y - u_dimensions.y - fade[2]);\n    pos2 = vec2(v_textureCoordinate.x, point.y - u_dimensions.y);\n    d = pos1 - pos2;\n    c = dot(pos2, d) / dot(d, d);\n    result = mix(vec4(0.0), result, smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0)));\n  }\n\n  if(fade[3] > 0.0) {\n    pos1 = vec2(point.x, point.y);\n    pos2 = vec2(point.x + fade[3], point.y);\n    d = pos2 - pos1;\n    c = dot(pos1, d) / dot(d, d);\n    result = mix(vec4(0.0), result, smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0)));\n  }\n\n  return result;\n  "}class L extends R{static z$__type__Props;name="radialGradient";static getEffectKey(t){return`radialGradient${t.colors.length}`}static resolveDefaults(t){const e=t.colors??[4278190080,4294967295];let r=t.stops;if(!r){r=[];const t=e.length-1;for(let o=0;o<e.length;o++)r.push(o*(1/t))}return{colors:e,stops:r,width:t.width??0,height:t.height??t.width??0,pivot:t.pivot??[.5,.5]}}static uniforms={width:{value:0,method:"uniform1f",type:"float"},height:{value:0,method:"uniform1f",type:"float"},pivot:{value:[.5,.5],method:"uniform2fv",type:"vec2"},colors:{value:4294967295,validator:t=>t.map((t=>a(t))).reduce(((t,e)=>t.concat(e)),[]),size:t=>t.colors.length,method:"uniform4fv",type:"vec4"},stops:{value:[],validator:(t,e)=>{const r=e.colors??[];let o=t;const s=t;if(0===o.length||o&&o.length!==r.length){for(let t=0;t<r.length;t++)o[t]?(s[t]=o[t],void 0===o[t-1]&&void 0!==s[t-2]&&(s[t-1]=s[t-2]+(o[t]-s[t-2])/2)):s[t]=t*(1/(r.length-1));o=s}return s},size:t=>t.colors.length,method:"uniform1fv",type:"float"}};static onColorize=t=>`\n      vec2 point = v_textureCoordinate.xy * u_dimensions;\n      vec2 projection = vec2(pivot.x * u_dimensions.x, pivot.y * u_dimensions.y);\n\n      float dist = length((point - projection) / vec2(width, height));\n\n      float stopCalc = (dist - stops[0]) / (stops[1] - stops[0]);\n      vec4 colorOut = mix(colors[0], colors[1], stopCalc);\n      for(int i = 1; i < ${t.colors.length||1}-1; i++) {\n        stopCalc = (dist - stops[i]) / (stops[i + 1] - stops[i]);\n        colorOut = mix(colorOut, colors[i + 1], clamp(stopCalc, 0.0, 1.0));\n      }\n      return mix(maskColor, colorOut, clamp(colorOut.a, 0.0, 1.0));\n    `}const j={radius:k,border:E,borderBottom:D,borderLeft:A,borderRight:O,borderTop:z,fadeOut:P,linearGradient:M,radialGradient:L,grayscale:F,glitch:$};class B extends i{effects=[];constructor(t,e,r){const o=B.createShader(e,r);super({renderer:t,attributes:["a_position","a_textureCoordinate","a_color"],uniforms:[{name:"u_resolution",uniform:"uniform2fv"},{name:"u_pixelRatio",uniform:"uniform1f"},{name:"u_texture",uniform:"uniform2fv"},{name:"u_dimensions",uniform:"uniform2fv"},{name:"u_alpha",uniform:"uniform1f"},...o.uniforms],shaderSources:{vertex:o.vertex,fragment:o.fragment}}),this.effects=o.effects}bindTextures(t){const{gl:e}=this;e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,t[0].ctxTexture)}bindProps(t){t.effects?.forEach(((t,e)=>{const r=this.effects[e],o=j[r.name],s=t.props??{},n=r.uniformInfo;Object.keys(s).forEach((t=>{const e=o.uniforms[t],r=n[t];let i=e.validator?e.validator(s[t],s):s[t];Array.isArray(i)&&(i=new Float32Array(i)),this.setUniform(r.name,i)}))}))}static createShader(t,e){const r={},o={};let s="";const n=[],i=[],a=t.effects.map((t=>{const o=e[t.type],a=o.getEffectKey(t.props||{});r[a]=r[a]?++r[a]:1;const l=r[a];1===l&&i.push({key:a,type:t.type,props:t.props});const c=new o({ref:`${a}${1===l?"":l}`,target:a,props:t.props});return s+=c.declaredUniforms,n.push(...Object.values(c.uniformInfo)),c}));let l="";i?.forEach((t=>{const r=e[t.type],s=r.resolveDefaults(t.props??{}),n=[];for(const e in r.methods){let t=e;const s=r.methods[e];o[e]&&o[e]!==s&&(t=B.resolveMethodDuplicate(e,s,o)),o[t]=s.replace("function",t),n.push({m:e,cm:t})}let i=r.onShaderMask instanceof Function?r.onShaderMask(s):r.onShaderMask,a=r.onColorize instanceof Function?r.onColorize(s):r.onColorize,c=r.onEffectMask instanceof Function?r.onEffectMask(s):r.onEffectMask;n.forEach((t=>{const{m:e,cm:r}=t,o=new RegExp(`\\$${e}`,"g");i&&(i=i.replace(o,r)),a&&(a=a.replace(o,r)),c&&(c=c.replace(o,r))}));const h=r.getMethodParameters(r.uniforms,s),d=h.length>0?`, ${h}`:"";i&&(l+=`\n        float fx_${t.key}_onShaderMask(float shaderMask ${d}) {\n          ${i}\n        }\n        `),a&&(l+=`\n          vec4 fx_${t.key}_onColorize(float shaderMask, vec4 maskColor, vec4 shaderColor${d}) {\n            ${a}\n          }\n        `),c&&(l+=`\n          vec4 fx_${t.key}_onEffectMask(float shaderMask, vec4 maskColor, vec4 shaderColor${d}) {\n            ${c}\n          }\n        `)}));let c="";for(const u in o)c+=o[u];let h="mix(shaderColor, maskColor, clamp(-(lng_DefaultMask), 0.0, 1.0))",d="\n\n    ";for(let u=0;u<a.length;u++){const t=a[u],e=t.passParameters.length>0?`, ${t.passParameters}`:"",r=j[t.name];r.onShaderMask&&(d+=`\n        shaderMask = fx_${t.target}_onShaderMask(shaderMask ${e});\n        `),r.onColorize&&(d+=`\n        maskColor = fx_${t.target}_onColorize(shaderMask, maskColor, shaderColor${e});\n        `),r.onEffectMask&&(h=`fx_${t.target}_onEffectMask(shaderMask, maskColor, shaderColor${e})`);const o=a[u+1];(void 0===o||j[o.name].onEffectMask)&&(d+=`\n          shaderColor = ${h};\n        `)}return{effects:a,uniforms:n,fragment:B.fragment(s,c,l,d),vertex:B.vertex()}}static resolveMethodDuplicate(t,e,r,o=0){const s=t+(o>0?o:"");return r[s]&&r[s]!==e?this.resolveMethodDuplicate(t,e,r,++o):s}static resolveDefaults(t,e){return{effects:(t.effects??[]).map((t=>({type:t.type,props:e[t.type].resolveDefaults(t.props||{})}))),$dimensions:{width:0,height:0},$alpha:0}}static makeCacheKey(t,e){let r="";return t.effects?.forEach((t=>{const o=e[t.type].getEffectKey(t.props||{});r+=`,${o}`})),`DynamicShader${r}`}static z$__type__Props;static vertex=()=>"\n    # ifdef GL_FRAGMENT_PRESICISON_HIGH\n    precision highp float;\n    # else\n    precision mediump float;\n    # endif\n\n    attribute vec2 a_textureCoordinate;\n    attribute vec2 a_position;\n    attribute vec4 a_color;\n    attribute float a_textureIndex;\n\n    uniform vec2 u_resolution;\n    uniform float u_pixelRatio;\n\n    varying vec4 v_color;\n    varying vec2 v_textureCoordinate;\n    varying float v_textureIndex;\n\n    void main(){\n      vec2 normalized = a_position * u_pixelRatio / u_resolution;\n      vec2 zero_two = normalized * 2.0;\n      vec2 clip_space = zero_two - 1.0;\n\n      // pass to fragment\n      v_color = a_color;\n      v_textureCoordinate = a_textureCoordinate;\n      v_textureIndex = a_textureIndex;\n\n      // flip y\n      gl_Position = vec4(clip_space * vec2(1.0, -1.0), 0, 1);\n    }\n  ";static fragment=(t,e,r,o)=>`\n    # ifdef GL_FRAGMENT_PRESICISON_HIGH\n    precision highp float;\n    # else\n    precision mediump float;\n    # endif\n\n    #define PI 3.14159265359\n\n    uniform vec2 u_resolution;\n    uniform vec2 u_dimensions;\n    uniform float u_alpha;\n    uniform float u_radius;\n    uniform sampler2D u_texture;\n    uniform float u_pixelRatio;\n\n    ${t}\n\n    varying vec4 v_color;\n    varying vec2 v_textureCoordinate;\n\n    ${e}\n\n    ${r}\n\n    void main() {\n      vec2 p = v_textureCoordinate.xy * u_dimensions - u_dimensions * 0.5;\n      vec2 d = abs(p) - (u_dimensions) * 0.5;\n      float lng_DefaultMask = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n\n      vec4 shaderColor = vec4(0.0);\n      float shaderMask = lng_DefaultMask;\n\n      vec4 maskColor = texture2D(u_texture, v_textureCoordinate) * v_color;\n\n      shaderColor = mix(shaderColor, maskColor, clamp(-(lng_DefaultMask + 0.5), 0.0, 1.0));\n\n      ${o}\n\n      gl_FragColor = shaderColor * u_alpha;\n    }\n  `}class X extends i{constructor(t){super({renderer:t,attributes:["a_position","a_textureCoordinate","a_color"],uniforms:[{name:"u_resolution",uniform:"uniform2fv"},{name:"u_pixelRatio",uniform:"uniform1f"},{name:"u_texture",uniform:"uniform2f"},{name:"u_dimensions",uniform:"uniform2fv"},{name:"u_radius",uniform:"uniform1f"}]})}static z$__type__Props;static resolveDefaults(t){return{radius:t.radius||10,$dimensions:{width:0,height:0}}}bindTextures(t){const{gl:e}=this;e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,t[0].ctxTexture)}bindProps(t){this.setUniform("u_radius",t.radius)}canBatchShaderProps(t,e){return t.radius===e.radius&&t.$dimensions.width===e.$dimensions.width&&t.$dimensions.height===e.$dimensions.height}static shaderSources={vertex:"\n      # ifdef GL_FRAGMENT_PRESICISON_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      attribute vec2 a_position;\n      attribute vec2 a_textureCoordinate;\n      attribute vec4 a_color;\n      attribute float a_textureIndex;\n      attribute float a_depth;\n\n      uniform vec2 u_resolution;\n      uniform float u_pixelRatio;\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoordinate;\n\n      void main() {\n        vec2 normalized = a_position * u_pixelRatio / u_resolution;\n        vec2 zero_two = normalized * 2.0;\n        vec2 clip_space = zero_two - 1.0;\n\n        // pass to fragment\n        v_color = a_color;\n        v_textureCoordinate = a_textureCoordinate;\n\n        // flip y\n        gl_Position = vec4(clip_space * vec2(1.0, -1.0), 0, 1);\n      }\n    ",fragment:"\n      # ifdef GL_FRAGMENT_PRESICISON_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      uniform vec2 u_resolution;\n      uniform vec2 u_dimensions;\n      uniform float u_radius;\n      uniform sampler2D u_texture;\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoordinate;\n\n      float boxDist(vec2 p, vec2 size, float radius){\n        size -= vec2(radius);\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n      }\n\n      float fillMask(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n\n      void main() {\n        vec4 color = texture2D(u_texture, v_textureCoordinate) * v_color;\n        vec2 halfDimensions = u_dimensions * 0.5;\n\n        float d = boxDist(v_textureCoordinate.xy * u_dimensions - halfDimensions, halfDimensions + 0.5, u_radius);\n        gl_FragColor = mix(vec4(0.0), color, fillMask(d));\n      }\n    "}}class Y extends i{constructor(t){super({renderer:t,attributes:["a_position","a_textureCoordinate"],uniforms:[{name:"u_resolution",uniform:"uniform2fv"},{name:"u_pixelRatio",uniform:"uniform1f"},{name:"u_texture",uniform:"uniform2f"},{name:"u_offset",uniform:"uniform2fv"},{name:"u_color",uniform:"uniform4fv"},{name:"u_size",uniform:"uniform1f"},{name:"u_distanceRange",uniform:"uniform1f"},{name:"u_debug",uniform:"uniform1i"}]})}bindTextures(t){const{gl:e}=this;e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,t[0].ctxTexture)}bindProps(t){const e=Y.resolveDefaults(t);for(const r in e)if("offset"===r)this.setUniform("u_offset",e[r]);else if("color"===r){const t=a(e.color);this.setUniform("u_color",t)}else"size"===r?this.setUniform("u_size",e[r]):"distanceRange"===r?this.setUniform("u_distanceRange",e[r]):"debug"===r&&this.setUniform("u_debug",e[r]?1:0)}static resolveDefaults(t={}){return{offset:t.offset??[0,0],color:t.color??4294967295,size:t.size??16,distanceRange:t.distanceRange??1,debug:t.debug??!1}}static shaderSources={vertex:"\n      // an attribute is an input (in) to a vertex shader.\n      // It will receive data from a buffer\n      attribute vec2 a_position;\n      attribute vec2 a_textureCoordinate;\n\n      uniform vec2 u_offset;\n      uniform vec2 u_resolution;\n      uniform float u_pixelRatio;\n      uniform float u_size;\n\n      varying vec2 v_texcoord;\n\n      void main() {\n        gl_Position = vec4(((a_position * u_size + u_offset) * u_pixelRatio / u_resolution * 2.0 - 1.0) * vec2(1, -1), 0, 1);\n        v_texcoord = a_textureCoordinate;\n      }\n    ",fragment:"\n      precision highp float;\n\n      uniform vec4 u_color;\n      uniform sampler2D u_texture;\n      uniform float u_distanceRange;\n      uniform float u_pixelRatio;\n      uniform int u_debug;\n\n      varying vec2 v_texcoord;\n\n      float median(float r, float g, float b) {\n          return max(min(r, g), min(max(r, g), b));\n      }\n\n      void main() {\n          vec3 sample = texture2D(u_texture, v_texcoord).rgb;\n          if (u_debug == 1) {\n            gl_FragColor = vec4(sample.r, sample.g, sample.b, 1.0);\n            return;\n          }\n          float scaledDistRange = u_distanceRange * u_pixelRatio;\n          float sigDist = scaledDistRange * (median(sample.r, sample.g, sample.b) - 0.5);\n          float opacity = clamp(sigDist + 0.5, 0.0, 1.0) * u_color.a;\n\n          // Build the final color.\n          // IMPORTANT: We must premultiply the color by the alpha value before returning it.\n          gl_FragColor = vec4(u_color.r * opacity, u_color.g * opacity, u_color.b * opacity, opacity);\n      }\n    "}}class W{shCache=new Map;shConstructors={};attachedShader=null;effectConstructors={};renderer;constructor(){this.registerShaderType("DefaultShader",C),this.registerShaderType("DefaultShaderBatched",I),this.registerShaderType("RoundedRectangle",X),this.registerShaderType("DynamicShader",B),this.registerShaderType("SdfShader",Y),this.registerEffectType("border",E),this.registerEffectType("borderBottom",D),this.registerEffectType("borderLeft",A),this.registerEffectType("borderRight",O),this.registerEffectType("borderTop",z),this.registerEffectType("fadeOut",P),this.registerEffectType("linearGradient",M),this.registerEffectType("radialGradient",L),this.registerEffectType("grayscale",F),this.registerEffectType("glitch",$),this.registerEffectType("radius",k)}registerShaderType(t,e){this.shConstructors[t]=e}registerEffectType(t,e){this.effectConstructors[t]=e}loadShader(t,e){if(!this.renderer)throw new Error("Renderer is not been defined");const r=this.shConstructors[t];if(!r)throw new Error(`Shader type "${t}" is not registered`);if("DynamicShader"===t)return this.loadDynamicShader(e);const o=r.resolveDefaults(e),s=r.makeCacheKey(o)||r.name;if(s&&this.shCache.has(s))return{shader:this.shCache.get(s),props:o};const n=new r(this.renderer,e);return s&&this.shCache.set(s,n),{shader:n,props:o}}loadDynamicShader(t){if(!this.renderer)throw new Error("Renderer is not been defined");const e=B.resolveDefaults(t,this.effectConstructors),r=B.makeCacheKey(e,this.effectConstructors);if(r&&this.shCache.has(r))return{shader:this.shCache.get(r),props:e};const o=new B(this.renderer,t,this.effectConstructors);return r&&this.shCache.set(r,o),{shader:o,props:e}}useShader(t){this.attachedShader!==t&&(this.attachedShader&&this.attachedShader.detach(),t.attach(),this.attachedShader=t)}}class N{activeAnimations=new Set;registerAnimation(t){this.activeAnimations.add(t)}unregisterAnimation(t){this.activeAnimations.delete(t)}update(t){this.activeAnimations.forEach((e=>{e.update(t)}))}}class H extends l{props;constructor(t,e){super(t),this.props=H.resolveDefaults(e)}async getTextureData(){const{src:t,premultiplyAlpha:e}=this.props;if(!t)return{data:null};if(t instanceof ImageData)return{data:t,premultiplyAlpha:e};const r=await fetch(t),o=await r.blob();return{data:await createImageBitmap(o,{premultiplyAlpha:e?"premultiply":"none",colorSpaceConversion:"none",imageOrientation:"none"})}}static makeCacheKey(t){const e=H.resolveDefaults(t);return!(e.src instanceof ImageData)&&`ImageTexture,${e.src},${e.premultiplyAlpha}`}static resolveDefaults(t){return{src:t.src??"",premultiplyAlpha:t.premultiplyAlpha??!0}}static z$__type__Props}class U extends l{props;constructor(t,e){super(t),this.props=U.resolveDefaults(e)}async getTextureData(){const{width:t,height:e}=this.props,r=t*e*4,o=new Uint8ClampedArray(r);for(let s=0;s<r;s+=4){const t=Math.floor(256*Math.random());o[s]=t,o[s+1]=t,o[s+2]=t,o[s+3]=255}return{data:new ImageData(o,t,e)}}static makeCacheKey(t){const e=U.resolveDefaults(t);return`NoiseTexture,${e.width},${e.height},${e.cacheId}`}static resolveDefaults(t){return{width:t.width??128,height:t.height??128,cacheId:t.cacheId??0}}static z$__type__Props}class G{usedMemory=0;txConstructors={};textureKeyCache=new Map;textureIdCache=new Map;ctxTextureCache=new WeakMap;textureRefCountMap=new WeakMap;renderer;constructor(){this.registerTextureType("ImageTexture",H),this.registerTextureType("ColorTexture",c),this.registerTextureType("NoiseTexture",U),this.registerTextureType("SubTexture",h)}registerTextureType(t,e){this.txConstructors[t]=e}loadTexture(t,e,r=null){const o=this.txConstructors[t];if(!o)throw new Error(`Texture type "${t}" is not registered`);let s;if(void 0!==r?.id&&this.textureIdCache.has(r.id)&&(s=this.textureIdCache.get(r.id)),!s){const t=r?.id,n=r?.cacheKey??o.makeCacheKey(e);s=n&&this.textureKeyCache.has(n)?this.textureKeyCache.get(n):new o(this,e),t&&this.addTextureIdToCache(t,n,s)}return r?.preload&&this.getCtxTexture(s).load(),s}addTextureIdToCache(t,e,r){const{textureIdCache:o,textureRefCountMap:s}=this;o.set(t,r),s.has(r)?s.get(r).count++:(s.set(r,{cacheKey:e,count:1}),e&&this.textureKeyCache.set(e,r))}removeTextureIdFromCache(t){const{textureIdCache:e,textureRefCountMap:r}=this,o=e.get(t);if(o&&(e.delete(t),r.has(o))){const t=r.get(o);n(t),t.count--,0===t.count&&(r.delete(o),t.cacheKey&&this.textureKeyCache.delete(t.cacheKey))}}getDebugInfo(){return{keyCacheSize:this.textureKeyCache.size,idCacheSize:this.textureIdCache.size}}getCtxTexture(t){if(this.ctxTextureCache.has(t))return this.ctxTextureCache.get(t);const e=this.renderer.createCtxTexture(t);return this.ctxTextureCache.set(t,e),e}}class K{textRenderers;constructor(t){this.textRenderers=t}addFontFace(t){for(const e in this.textRenderers){const r=this.textRenderers[e];r&&r.isFontFaceSupported(t)&&r.addFontFace(t)}}static resolveFontFace(t,e){return t.reduce(((t,r)=>{if(t)return t;const o=r[e.fontFamily];if(!o)return;const s=new Set(o);for(const n of s)n.descriptors.stretch===e.fontStretch&&n.descriptors.style===e.fontStyle&&n.descriptors.weight===e.fontWeight||s.delete(n);return s.values().next().value}),void 0)||[][0]}}const Q={x:(t,e)=>{t.props.x=e},y:(t,e)=>{t.props.y=e},width:(t,e)=>{t.props.width=e},height:(t,e)=>{t.props.height=e},color:(t,e)=>{t.props.color=e},alpha:(t,e)=>{t.props.alpha=e},zIndex:(t,e)=>{t.props.zIndex=e},fontFamily:(t,e)=>{t.props.fontFamily=e},fontWeight:(t,e)=>{t.props.fontWeight=e},fontStyle:(t,e)=>{t.props.fontStyle=e},fontStretch:(t,e)=>{t.props.fontStretch=e},fontSize:(t,e)=>{t.props.fontSize=e},text:(t,e)=>{t.props.text=e},textAlign:(t,e)=>{t.props.textAlign=e},contain:(t,e)=>{t.props.contain=e},offsetY:(t,e)=>{t.props.offsetY=e},scrollable:(t,e)=>{t.props.scrollable=e},scrollY:(t,e)=>{t.props.scrollY=e},letterSpacing:(t,e)=>{t.props.letterSpacing=e},debug:(t,e)=>{t.props.debug=e}};class V{stage;set;constructor(t){this.stage=t,this.set=Object.freeze({...Q,...this.getPropertySetters()})}setStatus(t,e,r){t.status!==e&&(t.status=e,t.emitter.emit(e,r))}}class q{iterator;peekBuffer=[];_lastIndex;constructor(t,e=0){this.iterator=t,this.iterator=t,this._lastIndex=e-1,this.peekBuffer=[]}next(){const t=this.peekBuffer.length>0?this.peekBuffer.pop():this.iterator.next();return t.done?this._lastIndex=-1:this._lastIndex++,t}peek(){if(this.peekBuffer.length>0)return this.peekBuffer[0];const t=this.iterator.next();return this.peekBuffer.push(t),t}get lastIndex(){return this._lastIndex}}function*Z(t,e=0){let r=e;for(;r<t.length;){const e=t.codePointAt(r);if(void 0===e)throw new Error("Invalid Unicode code point");yield e,r+=e<=65535?1:2}}function J(t,e,r,o,s,i,a,l,c,h,d,u,p,f,m,g){n(f,"Font face must be loaded"),n(f.loaded,"Font face must be loaded"),n(f.data,"Font face must be loaded"),n(f.shaper,"Font face must be loaded");const x=f.data.info.size,y=l/x,v=i/y,_=c/y,w=u[t],b=w?.codepointIndex||0;let S=w?.maxX||0,T=w?.maxY||0,C=e,I=r,R=0;const k={codepointIndex:-1,bufferOffset:-1,xStart:-1},E=f.shaper,M={letterSpacing:_};let F,O=E.shapeText(M,new q(Z(o,b),b)),z=-1;const D=[],A=a/y,$=function(t,e,r){const o=r.shapeText(e,new q(Z(t,0),0));let s=0;for(const n of o)n.mapped&&(s+=n.xAdvance);return s}("...",M,E);let P=!0;for(;P;){const e="both"!==d||g||I+x+x<=A,r=e?v:v-$;let s=0;for(;(F=O.next())&&!F.done;){const n=F.value;if(t===u.length)u.push({codepointIndex:n.cluster,maxY:T,maxX:S});else if(t>u.length)throw new Error("Unexpected lineCache length");if(32===n.codepoint||10===n.codepoint?-1!==k.codepointIndex&&(k.codepointIndex=-1,s=C):-1===k.codepointIndex&&(k.codepointIndex=n.cluster,k.bufferOffset=R,k.xStart=s),n.mapped){const t=C+n.xOffset+n.width;if("none"!==d&&t>=r&&-1!==k.codepointIndex&&k.codepointIndex<n.cluster&&k.xStart>0){if(e){O=E.shapeText(M,new q(Z(o,k.codepointIndex),k.codepointIndex)),R=k.bufferOffset;break}O=E.shapeText(M,new q(Z("...",0),0)),C=k.xStart,R=k.bufferOffset}else{const t=C+n.xOffset,e=I+n.yOffset,r=!p||I+x>=p.y1/y,o=!p||I<=p.y2/y;if(r&&o){-1===z&&(z=R);const r=f.getAtlasEntry(n.glyphId),o=r.x/f.data.common.scaleW,s=r.y/f.data.common.scaleH,i=r.width/f.data.common.scaleW,a=r.height/f.data.common.scaleH;h[R++]=t,h[R++]=e,h[R++]=o,h[R++]=s,h[R++]=t+n.width,h[R++]=e,h[R++]=o+i,h[R++]=s,h[R++]=t,h[R++]=e+n.height,h[R++]=o,h[R++]=s+a,h[R++]=t+n.width,h[R++]=e+n.height,h[R++]=o+i,h[R++]=s+a}T=Math.max(T,e+n.height),C+=n.xAdvance,S=Math.max(S,C)}}else if(10===n.codepoint)break}-1!==z&&(D.push({bufferStart:z,bufferEnd:R}),z=-1),C=0,I+=x,t++,k.codepointIndex=-1,s=0,!m&&"both"===d&&p&&I>p.y2/y||F&&F.done?P=!1:"both"!==d||g||e||(P=!1)}if("center"===s){const t="none"===d?S:v;for(let e=0;e<D.length;e++){const r=D[e],o=(t-(h[r.bufferEnd-4]-h[r.bufferStart]))/2;for(let t=r.bufferStart;t<r.bufferEnd;t+=4)h[t]+=o}}else if("right"===s){const t="none"===d?S:v;for(let e=0;e<D.length;e++){const r=D[e],o=t-(r.bufferEnd===r.bufferStart?0:h[r.bufferEnd-4]-h[r.bufferStart]);for(let t=r.bufferStart;t<r.bufferEnd;t+=4)h[t]+=o}}return n(F),{bufferNumFloats:R,bufferNumQuads:R/16,layoutNumCharacters:F.done?o.length-b:F.value.cluster-b+1,fullyProcessed:!!F.done,maxX:S,maxY:T}}class tt extends V{ssdfFontFamilies={};msdfFontFamilies={};sdfShader;constructor(t){super(t),this.sdfShader=this.stage.shManager.loadShader("SdfShader").shader}getPropertySetters(){return{fontFamily:(t,e)=>{t.props.fontFamily=e,t.trFontFace=void 0,this.invalidateCache(t)},fontWeight:(t,e)=>{t.props.fontWeight=e,t.trFontFace=void 0,this.invalidateCache(t)},fontStyle:(t,e)=>{t.props.fontStyle=e,t.trFontFace=void 0,this.invalidateCache(t)},fontStretch:(t,e)=>{t.props.fontStretch=e,t.trFontFace=void 0,this.invalidateCache(t)},fontSize:(t,e)=>{t.props.fontSize=e,this.invalidateCache(t)},text:(t,e)=>{t.props.text=e,this.invalidateCache(t)},textAlign:(t,e)=>{t.props.textAlign=e,this.invalidateCache(t)},color:(t,e)=>{t.props.color=e},alpha:(t,e)=>{t.props.alpha=e},x:(t,e)=>{t.props.x=e},y:(t,e)=>{t.props.y=e},contain:(t,e)=>{t.props.contain=e,this.invalidateCache(t)},width:(t,e)=>{t.props.width=e,this.invalidateCache(t)},height:(t,e)=>{t.props.height=e,this.invalidateCache(t)},offsetY:(t,e)=>{t.props.offsetY=e,this.invalidateCache(t)},scrollable:(t,e)=>{t.props.scrollable=e,this.invalidateCache(t)},scrollY:(t,e)=>{t.props.scrollY=e},letterSpacing:(t,e)=>{t.props.letterSpacing=e,this.invalidateCache(t)},debug:(t,e)=>{t.props.debug=e}}}canRenderFont(t){const{fontFamily:e}=t;return e in this.ssdfFontFamilies||e in this.msdfFontFamilies||"$$SDF_FAILURE_TEST$$"===e}isFontFaceSupported(t){return t instanceof u}addFontFace(t){n(t instanceof u);const e=t.fontFamily,r="ssdf"===t.type?this.ssdfFontFamilies:"msdf"===t.type?this.msdfFontFamilies:void 0;if(!r)return void console.warn(`Invalid font face type: ${t.type}`);let o=r[e];o||(o=new Set,r[e]=o),o.add(t)}createState(t){return{props:t,status:"initialState",emitter:new r,lineCache:[],forceFullLayoutCalc:!1,renderWindow:void 0,bufferNumFloats:0,bufferNumQuads:0,vertexBuffer:void 0,webGlBuffers:null,bufferUploaded:!1,textH:void 0,textW:void 0,distanceRange:0,trFontFace:void 0,debugData:{updateCount:0,layoutCount:0,lastLayoutNumCharacters:0,layoutSum:0,drawSum:0,drawCount:0,bufferSize:0}}}updateState(t){performance.now();let{trFontFace:e}=t;const{textH:r,lineCache:o,debugData:s,forceFullLayoutCalc:i}=t;if(s.updateCount++,"initialState"===t.status&&this.setStatus(t,"loading"),!e&&(e=this.resolveFontFace(t.props),t.trFontFace=e,!e)){const e=`SdfTextRenderer: Could not resolve font face for family: '${t.props.fontFamily}'`;return console.error(e),void this.setStatus(t,"failed",new Error(e))}if(!e.loaded)return void e.on("loaded",(function r(){t.emitter.emit("fontLoaded",{}),e?.off("fontLoaded",r)}));n(e.data,"Font face data should be loaded");const{text:a,fontSize:l,x:c,y:h,contain:u,width:f,height:m,scrollable:g}=t.props,x="both"===u&&g?t.props.scrollY:0;let{renderWindow:y}=t;const v=e.data.info.size,_=l/v;t.distanceRange=_*e.data.distanceField.distanceRange;const w=24*a.length;let b=t.vertexBuffer;(!b||b.length<w)&&(b=new Float32Array(2*w));const S={x1:0,y1:0,x2:this.stage.options.appWidth,y2:this.stage.options.appHeight},T=p(S,{x1:c,y1:h,x2:"none"!==u?c+f:1/0,y2:"both"===u?h+m:1/0});if(!i&&y){if(c+y.x1<=T.x1&&c+y.x2>=T.x2&&h-x+y.y1<=T.y1&&h-x+y.y2>=T.y2)return;t.renderWindow=y=void 0}const{offsetY:C,textAlign:I}=t.props;if(!y){const t=T.y2-T.y1;y=function(t,e,r,o,s,n){const i=o*s,a=n.x1-t,l=n.y1-e;return d(n)?{x1:a,y1:l+r-i,x2:a+(n.x2-n.x1),y2:l+r+(n.y2-n.y1)+i}:{x1:0,y1:0,x2:0,y2:0}}(c,h,x,v,Math.ceil(t/v),T)}const R=function(t,e,r,o,s,n,i){let a=0;s&&(a=Math.min(Math.max(Math.floor(s.y1/t),0),n.length));const l=e/r+a*o;if(!(i&&l>=i/r))return{x:0,y:l,lineIndex:a}}(l,C,_,v,y,o,r);if(!R)return void this.setStatus(t,"loaded");const{letterSpacing:k}=t.props,E=J(R.lineIndex,R.x,R.y,a,I,f,m,l,k,b,u,o,y,e,i,g);t.bufferUploaded=!1,t.bufferNumFloats=E.bufferNumFloats,t.bufferNumQuads=E.bufferNumQuads,t.vertexBuffer=b,t.renderWindow=y,s.lastLayoutNumCharacters=E.layoutNumCharacters,s.bufferSize=b.byteLength,E.fullyProcessed&&(t.textW=E.maxX*_,t.textH=E.maxY*_),this.setStatus(t,"loaded")}renderQuads(t,e){if(!t.vertexBuffer)return;performance.now();const{renderer:r}=this.stage;this.stage.options;const{fontSize:o,color:s,alpha:i,x:a,y:l,contain:c,width:h,height:d,scrollable:u,zIndex:p,debug:x}=t.props,y="both"===c&&u?t.props.scrollY:0,{textW:v=0,textH:_=0,distanceRange:w,vertexBuffer:b,bufferNumFloats:S,bufferUploaded:T,renderWindow:C,debugData:I,trFontFace:R}=t;let{webGlBuffers:k}=t;if(!k){const e=r.gl,o=4*Float32Array.BYTES_PER_ELEMENT,s=e.createBuffer();n(s),t.webGlBuffers=new f([{buffer:s,attributes:{a_position:{name:"a_position",size:2,type:e.FLOAT,normalized:!1,stride:o,offset:0},a_textureCoordinate:{name:"a_textureCoordinate",size:2,type:e.FLOAT,normalized:!1,stride:o,offset:2*Float32Array.BYTES_PER_ELEMENT}}}]),t.bufferUploaded=!1,n(t.webGlBuffers),k=t.webGlBuffers}if(!T){const e=r.gl,o=k?.getBuffer("a_textureCoordinate")??null;e.bindBuffer(e.ARRAY_BUFFER,o),e.bufferData(e.ARRAY_BUFFER,b,e.STATIC_DRAW),t.bufferUploaded=!0}n(R);const E=new m(r.gl,r.options,k,this.sdfShader,{color:g(s,i),size:o/(R.data?.info.size||0),offset:[a,l-y],distanceRange:w,debug:x.sdfShaderDebug},i,e,{height:_,width:v},0,p),M=t.trFontFace?.texture;n(M);const F=this.stage.txManager.getCtxTexture(M);E.addTexture(F),E.length=t.bufferNumFloats,E.numQuads=t.bufferNumQuads,r.addRenderable(E)}resolveFontFace(t){return K.resolveFontFace([this.msdfFontFamilies,this.ssdfFontFamilies],t)}invalidateCache(t){t.renderWindow=void 0,t.textH=void 0,t.textW=void 0,t.lineCache=[],this.setStatus(t,"loading")}}class et{_canvas;_context;_settings;renderInfo;constructor(t,e){this._canvas=t,this._context=e,this._settings=this.mergeDefaults({})}set settings(t){this._settings=this.mergeDefaults(t)}get settings(){return this._settings}getPrecision(){return this._settings.precision}setFontProperties(){this._context.font=this._getFontSetting(),this._context.textBaseline=this._settings.textBaseline}_getFontSetting(){const t=[this._settings.fontFace],e=[];for(let r=0,o=t.length;r<o;r++)"serif"===t[r]||"sans-serif"===t[r]?e.push(t[r]):e.push(`"${t[r]}"`);return`${this._settings.fontStyle} ${this._settings.fontSize*this.getPrecision()}px ${e.join(",")}`}_load(){if(document.fonts){const e=this._getFontSetting();try{if(!document.fonts.check(e,this._settings.text))return document.fonts.load(e,this._settings.text).catch((t=>{console.warn("[Lightning] Font load error",t,e)})).then((()=>{document.fonts.check(e,this._settings.text)||console.warn("[Lightning] Font not found",e)}))}catch(t){console.warn("[Lightning] Can't check font loading for "+e)}}}calculateRenderInfo(){const t={},e=this.getPrecision(),r=this._settings.paddingLeft*e,o=this._settings.paddingRight*e,s=this._settings.fontSize*e;let n=null===this._settings.offsetY?null:this._settings.offsetY*e,i=(this._settings.lineHeight||s)*e;const a=this._settings.w*e,l=this._settings.h*e;let c=this._settings.wordWrapWidth*e;const h=this._settings.cutSx*e,d=this._settings.cutEx*e,u=this._settings.cutSy*e,p=this._settings.cutEy*e,f=(this._settings.letterSpacing||0)*e,m=this._settings.textIndent*e;this.setFontProperties();let g,x=a||2048/this.getPrecision(),y=x-r;if(y<10&&(x+=10-y,y=10),c||(c=y),this._settings.textOverflow&&!this._settings.wordWrap){let t;switch(this._settings.textOverflow){case"clip":t="";break;case"ellipsis":t=this._settings.maxLinesSuffix;break;default:t=this._settings.textOverflow}this._settings.text=this.wrapWord(this._settings.text,c-m,t)}if(this._settings.wordWrap)g=this.wrapText(this._settings.text,c,f,m);else{g={l:this._settings.text.split(/(?:\r\n|\r|\n)/),n:[]};const t=g.l.length;for(let e=0;e<t-1;e++)g.n.push(e)}let v=g.l;if(this._settings.maxLines&&v.length>this._settings.maxLines){const e=v.slice(0,this._settings.maxLines);let r,o=null;if(this._settings.maxLinesSuffix){const t=this._settings.maxLinesSuffix?this.measureText(this._settings.maxLinesSuffix):0,r=this.wrapText(e[e.length-1],c-t,f,m);e[e.length-1]=`${r.l[0]}${this._settings.maxLinesSuffix}`,o=[r.l.length>1?r.l[1]:""]}else o=[""];const s=v.length;let n=0;const i=g.n.length;for(r=this._settings.maxLines;r<s;r++)o[n]+=`${o[n]?" ":""}${v[r]}`,r+1<i&&g.n[r+1]&&n++;t.remainingText=o.join("\n"),t.moreTextLines=!0,v=e}else t.moreTextLines=!1,t.remainingText="";let _=0;const w=[];for(let S=0;S<v.length;S++){const t=this.measureText(v[S],f)+(0===S?m:0);w.push(t),_=Math.max(_,t)}let b;if(t.lineWidths=w,a||(x=_+r+o,y=_),i=i||s,l)b=l;else{const t="bottom"!=this._settings.textBaseline?.5*s:0;b=i*(v.length-1)+t+Math.max(i,s)+(n||0)}return null===n&&(n=s),t.w=x,t.h=b,t.lines=v,t.precision=e,x||(x=1),b||(b=1),(h||d)&&(x=Math.min(x,d-h)),(u||p)&&(b=Math.min(b,p-u)),t.width=x,t.innerWidth=y,t.height=b,t.fontSize=s,t.cutSx=h,t.cutSy=u,t.cutEx=d,t.cutEy=p,t.lineHeight=i,t.lineWidths=w,t.offsetY=n,t.paddingLeft=r,t.paddingRight=o,t.letterSpacing=f,t.textIndent=m,t}draw(t,e){const r=this.getPrecision(),o=e?.lines||t.lines,s=e?.lineWidths||t.lineWidths,n=e?e.lines.length*t.lineHeight:t.height;let i,a;this._canvas.width=Math.min(Math.ceil(t.width+this._settings.textRenderIssueMargin),2048),this._canvas.height=Math.min(Math.ceil(n),2048),this.setFontProperties(),t.fontSize>=128&&(this._context.globalAlpha=.01,this._context.fillRect(0,0,.01,.01),this._context.globalAlpha=1),(t.cutSx||t.cutSy)&&this._context.translate(-t.cutSx,-t.cutSy);const l=[];for(let h=0,d=o.length;h<d;h++)i=0===h?t.textIndent:0,a=h*t.lineHeight+t.offsetY,"middle"==this._settings.verticalAlign?a+=(t.lineHeight-t.fontSize)/2:"bottom"==this._settings.verticalAlign&&(a+=t.lineHeight-t.fontSize),"right"===this._settings.textAlign?i+=t.innerWidth-s[h]:"center"===this._settings.textAlign&&(i+=(t.innerWidth-s[h])/2),i+=t.paddingLeft,l.push({text:o[h],x:i,y:a,w:s[h]});if(this._settings.highlight){const e=this._settings.highlightColor,o=this._settings.highlightHeight*r||1.5*t.fontSize,s=this._settings.highlightOffset*r,n=null!==this._settings.highlightPaddingLeft?this._settings.highlightPaddingLeft*r:t.paddingLeft,i=null!==this._settings.highlightPaddingRight?this._settings.highlightPaddingRight*r:t.paddingRight;this._context.fillStyle=x(e);for(let r=0;r<l.length;r++){const e=l[r];this._context.fillRect(e.x-n,e.y-t.offsetY+s,e.w+i+n,o)}}let c=null;this._settings.shadow&&(c=[this._context.shadowColor,this._context.shadowOffsetX,this._context.shadowOffsetY,this._context.shadowBlur],this._context.shadowColor=x(this._settings.shadowColor),this._context.shadowOffsetX=this._settings.shadowOffsetX*r,this._context.shadowOffsetY=this._settings.shadowOffsetY*r,this._context.shadowBlur=this._settings.shadowBlur*r),this._context.fillStyle=x(this._settings.textColor);for(let h=0,d=l.length;h<d;h++){const e=l[h];if(0===t.letterSpacing)this._context.fillText(e.text,e.x,e.y);else{const r=e.text.split("");let o=e.x;for(let s=0,n=r.length;s<n;s++)this._context.fillText(r[s],o,e.y),o+=this.measureText(r[s],t.letterSpacing)}}c&&(this._context.shadowColor=c[0],this._context.shadowOffsetX=c[1],this._context.shadowOffsetY=c[2],this._context.shadowBlur=c[3]),(t.cutSx||t.cutSy)&&this._context.translate(t.cutSx,t.cutSy),this.renderInfo=t}wrapWord(t,e,r){const o=this._context.measureText(r).width,s=t.length,n=this._context.measureText(t).width;if(n<=e)return t;let i=Math.floor(e*s/n),a=this._context.measureText(t.substring(0,i)).width+o;if(a>e)for(;i>0&&(a=this._context.measureText(t.substring(0,i)).width+o,a>e);)i-=1;else for(;i<s;){if(a=this._context.measureText(t.substring(0,i)).width+o,!(a<e)){i-=1;break}i+=1}return t.substring(0,i)+(e>=o?r:"")}wrapText(t,e,r,o=0){const s=t.split(/\r?\n/g);let n=[];const i=[];for(let a=0;a<s.length;a++){const t=[];let l="",c=e-o;const h=s[a].split(" ");for(let s=0;s<h.length;s++){const n=this.measureText(h[s],r),i=n+this.measureText(" ",r);0===s||i>c?(s>0&&(t.push(l),l=""),l+=h[s],c=e-n-(0===s?o:0)):(c-=i,l+=` ${h[s]}`)}t.push(l),l="",n=n.concat(t),a<s.length-1&&i.push(n.length)}return{l:n,n:i}}measureText(t,e=0){return e?t.split("").reduce(((t,r)=>t+this._context.measureText(r).width+e),0):this._context.measureText(t).width}mergeDefaults(t){return{text:"",w:0,h:0,fontStyle:"normal",fontSize:40,fontFace:null,wordWrap:!0,wordWrapWidth:0,wordBreak:!1,textOverflow:"",lineHeight:null,textBaseline:"alphabetic",textAlign:"left",verticalAlign:"top",offsetY:null,maxLines:0,maxLinesSuffix:"..",textColor:[1,1,1,1],paddingLeft:0,paddingRight:0,shadow:!1,shadowColor:[0,0,0,1],shadowOffsetX:0,shadowOffsetY:0,shadowBlur:5,highlight:!1,highlightHeight:0,highlightColor:[0,0,0,1],highlightOffset:0,highlightPaddingLeft:0,highlightPaddingRight:0,letterSpacing:0,textIndent:0,cutSx:0,cutEx:0,cutSy:0,cutEy:0,advancedRenderer:!1,fontBaselineRatio:0,precision:1,textRenderIssueMargin:0,...t}}}const rt="undefined"==typeof self?globalThis:self,ot=rt.document?.fonts||rt.fonts;class st extends V{canvas;context;constructor(t){super(t),"undefined"!=typeof OffscreenCanvas?this.canvas=new OffscreenCanvas(0,0):this.canvas=document.createElement("canvas");let e=this.canvas.getContext("2d");e||(this.canvas=document.createElement("canvas"),e=this.canvas.getContext("2d")),n(e),this.context=e}getPropertySetters(){return{fontFamily:(t,e)=>{t.props.fontFamily=e,t.fontInfo=void 0,this.markForReload(t)},fontWeight:(t,e)=>{t.props.fontWeight=e,t.fontInfo=void 0,this.markForReload(t)},fontStyle:(t,e)=>{t.props.fontStyle=e,t.fontInfo=void 0,this.markForReload(t)},fontStretch:(t,e)=>{t.props.fontStretch=e,t.fontInfo=void 0,this.markForReload(t)},fontSize:(t,e)=>{t.props.fontSize=e,t.fontInfo=void 0,this.markForReload(t)},text:(t,e)=>{t.props.text=e,this.markForReload(t)},textAlign:(t,e)=>{t.props.textAlign=e,this.markForReload(t)},color:(t,e)=>{t.props.color=e,this.markForReload(t)},x:(t,e)=>{t.props.x=e},y:(t,e)=>{t.props.y=e},contain:(t,e)=>{t.props.contain=e,this.markForReload(t)},width:(t,e)=>{t.props.width=e,this.markForReload(t)},height:(t,e)=>{t.props.height=e,this.markForReload(t)},offsetY:(t,e)=>{t.props.offsetY=e,this.markForReload(t)},scrollY:(t,e)=>{t.props.scrollY=e},letterSpacing:(t,e)=>{t.props.letterSpacing=e,this.markForReload(t)}}}canRenderFont(t){return!0}isFontFaceSupported(t){return t instanceof y}addFontFace(t){n(t instanceof y),ot.add(t.fontFace)}createState(t){return{props:t,status:"initialState",emitter:new r,canvasPages:void 0,lightning2TextRenderer:new et(this.canvas,this.context),renderWindow:void 0,renderInfo:void 0,forceFullLayoutCalc:!1,textW:0,textH:0,fontInfo:void 0,fontFaceLoadedHandler:void 0,debugData:{updateCount:0,layoutCount:0,drawCount:0,lastLayoutNumCharacters:0,layoutSum:0,drawSum:0,bufferSize:0}}}updateState(t){if("initialState"===t.status&&this.setStatus(t,"loading"),!t.fontInfo){const e=function(t){const{fontFamily:e,fontStyle:r,fontWeight:o,fontStretch:s,fontSize:n}=t;return[r,o,s,`${n}px`,e].join(" ")}(t.props);if(t.fontInfo={cssString:e,loaded:!1},!t.fontInfo.loaded)return void ot.load(e).then(this.onFontLoaded.bind(this,t,e)).catch(this.onFontLoadError.bind(this,t,e))}if(!t.fontInfo.loaded)return;if(!t.renderInfo){t.lightning2TextRenderer.settings={text:t.props.text,textAlign:t.props.textAlign,fontFace:t.props.fontFamily,fontSize:t.props.fontSize,fontStyle:[t.props.fontStretch,t.props.fontStyle,t.props.fontWeight].join(" "),textColor:a(t.props.color),offsetY:t.props.fontSize+t.props.offsetY,wordWrap:"none"!==t.props.contain,wordWrapWidth:"none"===t.props.contain?void 0:t.props.width,letterSpacing:t.props.letterSpacing};const e=performance.now();t.renderInfo=t.lightning2TextRenderer.calculateRenderInfo(),console.log("Render info calculated in",performance.now()-e,"ms"),t.textH=t.renderInfo.lineHeight*t.renderInfo.lines.length,t.textW=t.renderInfo.width,t.renderWindow=void 0}const{x:e,y:r,width:o,height:s,scrollY:n,contain:i}=t.props;let{renderWindow:l,canvasPages:c}=t;const h={x1:0,y1:0,x2:this.stage.options.appWidth,y2:this.stage.options.appHeight},d=p(h,{x1:e,y1:r,x2:"none"!==i?e+o:1/0,y2:"both"===i?r+s:1/0}),u=d.y2-d.y1,f=Math.ceil(u/t.renderInfo.lineHeight);if(l&&c){const o=e+l.x1,s=r-n+l.y1,i=e+l.x2,a=r-n+l.y2;if(o<=d.x1&&i>=d.x2&&s<=d.y1&&a>=d.y2)return;a<d.y2?(l.y1+=f*t.renderInfo.lineHeight,l.y2+=f*t.renderInfo.lineHeight,c.push(c.shift()),c[2].lineNumStart=c[1].lineNumStart+f,c[2].lineNumEnd=c[2].lineNumStart+f,c[2].valid=!1):s>d.y1&&(l.y1-=f*t.renderInfo.lineHeight,l.y2-=f*t.renderInfo.lineHeight,c.unshift(c.pop()),c[0].lineNumStart=c[1].lineNumStart-f,c[0].lineNumEnd=c[0].lineNumStart+f,c[0].valid=!1)}else{const e=t.renderInfo.lineHeight*f,r=Math.ceil(n/e)*f,s=r-f,i=r+f;c=[{texture:c?.[0].texture,lineNumStart:s,lineNumEnd:s+f,valid:!1},{texture:c?.[1].texture,lineNumStart:r,lineNumEnd:r+f,valid:!1},{texture:c?.[2].texture,lineNumStart:i,lineNumEnd:i+f,valid:!1}],t.canvasPages=c;const a=Math.ceil(n/e)*e;l={x1:0,y1:a-e,x2:o,y2:a+2*e}}t.renderWindow=l;const m=performance.now();for(const a of c)a.valid||(a.lineNumStart<0?(a.texture=this.stage.txManager.loadTexture("ImageTexture",{src:""}),a.valid=!0):(t.lightning2TextRenderer.draw(t.renderInfo,{lines:t.renderInfo.lines.slice(a.lineNumStart,a.lineNumEnd),lineWidths:t.renderInfo.lineWidths.slice(a.lineNumStart,a.lineNumEnd)}),0!==this.canvas.width&&0!==this.canvas.height&&(a.texture=this.stage.txManager.loadTexture("ImageTexture",{src:this.context.getImageData(0,0,this.canvas.width,this.canvas.height)},{preload:!0})),a.valid=!0));console.log("pageDrawTime",performance.now()-m,"ms"),this.setStatus(t,"loaded")}renderQuads(t,e){const{stage:r}=this,{canvasPages:o,textW:s=0,textH:i=0,renderWindow:a}=t;if(!o||!a)return;const{x:l,y:c,scrollY:h,contain:d,width:u,height:p}=t.props,f={x:l,y:c,width:"none"!==d?u:s,height:"both"===d?p:i};v({x:0,y:0,width:r.options.appWidth,height:r.options.appHeight},f),n(o,"canvasPages is not defined"),n(a,"renderWindow is not defined");const m=(a.y2-a.y1)/3,{zIndex:g,alpha:x}=t.props;o[0].valid&&this.stage.renderer.addRenderable({alpha:x,clippingRect:e,colorBl:4294967295,colorBr:4294967295,colorTl:4294967295,colorTr:4294967295,width:o[0].texture?.dimensions?.width||0,height:o[0].texture?.dimensions?.height||0,texture:o[0].texture,textureOptions:{},shader:null,shaderProps:null,zIndex:g,worldScale:1,scale:1,wpx:l,wpy:c-h+a.y1,ta:1,tb:0,tc:0,td:1}),o[1].valid&&this.stage.renderer.addRenderable({alpha:x,clippingRect:e,colorBl:4294967295,colorBr:4294967295,colorTl:4294967295,colorTr:4294967295,width:o[1].texture?.dimensions?.width||0,height:o[1].texture?.dimensions?.height||0,texture:o[1].texture,textureOptions:{},shader:null,shaderProps:null,zIndex:g,worldScale:1,scale:1,wpx:l,wpy:c-h+a.y1+m,ta:1,tb:0,tc:0,td:1}),o[2].valid&&this.stage.renderer.addRenderable({alpha:x,clippingRect:e,colorBl:4294967295,colorBr:4294967295,colorTl:4294967295,colorTr:4294967295,width:o[2].texture?.dimensions?.width||0,height:o[2].texture?.dimensions?.height||0,texture:o[2].texture,textureOptions:{},shader:null,shaderProps:null,zIndex:g,worldScale:1,scale:1,wpx:l,wpy:c-h+a.y1+m+m,ta:1,tb:0,tc:0,td:1})}markForReload(t){t.renderInfo=void 0,this.setStatus(t,"loading")}onFontLoaded(t,e){e===t.fontInfo?.cssString&&t.fontInfo&&(t.fontInfo.loaded=!0,this.updateState(t))}onFontLoadError(t,e,r){e===t.fontInfo?.cssString&&t.fontInfo&&(t.fontInfo.loaded=!0,console.error(`CanvasTextRenderer: Error loading font '${t.fontInfo.cssString}'`,r),this.updateState(t))}}t("S",class{options;animationManager;txManager;fontManager;textRenderers;shManager;renderer;scene;deltaTime=0;lastFrameTime=0;currentFrameTime=0;constructor(t){this.options=t;const{canvas:e,clearColor:r,rootId:o,debug:s,appWidth:i,appHeight:a}=t;this.txManager=new G,this.shManager=new W,this.animationManager=new N,s?.monitorTextureCache&&setInterval((()=>{n(this.txManager);const t=this.txManager.getDebugInfo();console.log("Texture ID Cache Size: ",t.idCacheSize),console.log("Texture Key Cache Size: ",t.keyCacheSize)}),1e3),this.renderer=new _({stage:this,canvas:e,pixelRatio:t.devicePhysicalPixelRatio*t.deviceLogicalPixelRatio,clearColor:r??4278190080,bufferMemory:2e6,txManager:this.txManager,shManager:this.shManager}),this.txManager.renderer=this.renderer,this.textRenderers={canvas:new st(this),sdf:new tt(this)},this.fontManager=new K(this.textRenderers);const l=new S(this,{id:o,x:0,y:0,width:i,height:a,alpha:1,clipping:!1,color:0,colorTop:0,colorBottom:0,colorLeft:0,colorRight:0,colorTl:0,colorTr:0,colorBl:0,colorBr:0,zIndex:0,zIndexLocked:0,scale:1,mountX:0,mountY:0,mount:0,pivot:.5,pivotX:.5,pivotY:.5,rotation:0,parent:null,texture:null,textureOptions:null,shader:null,shaderProps:null});this.scene=new T(l),(t=>{const e=()=>{t.drawFrame(),requestAnimationFrame(e)};requestAnimationFrame(e)})(this)}drawFrame(){const{renderer:t,scene:e,animationManager:r}=this;e?.root&&(this.lastFrameTime=this.currentFrameTime,this.currentFrameTime=performance?performance.now():Date.now(),this.deltaTime=this.lastFrameTime?this.currentFrameTime-this.lastFrameTime:100/6,r.update(this.deltaTime),t?.reset(),e?.root?.hasUpdates&&e?.root?.update(this.deltaTime),this.addQuads(e.root),t?.sortRenderables(),t?.render())}addQuads(t,e=null){n(this.renderer);let r=t.clipping?{x:t.worldContext.px,y:t.worldContext.py,width:t.width,height:t.height}:null;e&&r?r=v(e,r):e&&(r=e),t.renderQuads(this.renderer,r),t.children.forEach((t=>{0!==t.alpha&&this.addQuads(t,r)}))}resolveTextRenderer(t,e=null){let r=e,o=!1;if(r){const e=this.textRenderers[r];e?e.canRenderFont(t)||(console.warn(`Cannot use override text renderer '${r}' for font`,t),r=null,o=!0):(console.warn(`Text renderer override '${r}' not found.`),r=null,o=!0)}if(!r){for(const[e,o]of Object.entries(this.textRenderers))if("canvas"!==e&&o.canRenderFont(t)){r=e;break}r||(r="canvas")}o&&console.warn(`Falling back to text renderer ${String(r)}`);const s=this.textRenderers[r];return n(s,"resolvedTextRenderer undefined"),s}get root(){return this.scene?.root||null}}),t("c",class extends S{textRenderer;trState;updateScheduled;_textRendererOverride=null;constructor(t,e){super(t,e),this.updateScheduled=!1,this._textRendererOverride=e.textRendererOverride;const{resolvedTextRenderer:r,textRendererState:o}=this.resolveTextRendererAndState({x:this.absX,y:this.absY,width:e.width,height:e.height,textAlign:e.textAlign,color:e.color,alpha:e.alpha,zIndex:e.zIndex,contain:e.contain,scrollable:e.scrollable,scrollY:e.scrollY,offsetY:e.offsetY,letterSpacing:e.letterSpacing,debug:e.debug,fontFamily:e.fontFamily,fontSize:e.fontSize,fontStretch:e.fontStretch,fontStyle:e.fontStyle,fontWeight:e.fontWeight,text:e.text},void 0);this.textRenderer=r,this.trState=o}onTextLoaded=()=>{this.emit("textLoaded",{width:this.trState.textW,height:this.trState.textH})};onTextFailed=(t,e)=>{this.emit("textFailed",e)};get width(){return this.trState.props.width}set width(t){this.textRenderer.set.width(this.trState,t),this.updateText()}get height(){return this.trState.props.height}set height(t){this.textRenderer.set.height(this.trState,t),this.updateText()}get alpha(){return this.trState.props.alpha}set alpha(t){this.textRenderer.set.alpha(this.trState,t),this.updateText()}get color(){return this.trState.props.color}set color(t){this.textRenderer.set.color(this.trState,t),this.updateText()}get text(){return this.trState.props.text}set text(t){this.textRenderer.set.text(this.trState,t),this.updateText()}get textRendererOverride(){return this._textRendererOverride}set textRendererOverride(t){this._textRendererOverride=t;const{resolvedTextRenderer:e,textRendererState:r}=this.resolveTextRendererAndState(this.trState.props,this.trState);this.textRenderer=e,this.trState=r}get fontSize(){return this.trState.props.fontSize}set fontSize(t){this.textRenderer.set.fontSize(this.trState,t),this.updateText()}get fontFamily(){return this.trState.props.fontFamily}set fontFamily(t){this.textRenderer.set.fontFamily(this.trState,t),this.updateText()}get fontStretch(){return this.trState.props.fontStretch}set fontStretch(t){this.textRenderer.set.fontStretch(this.trState,t),this.updateText()}get fontStyle(){return this.trState.props.fontStyle}set fontStyle(t){this.textRenderer.set.fontStyle(this.trState,t),this.updateText()}get fontWeight(){return this.trState.props.fontWeight}set fontWeight(t){this.textRenderer.set.fontWeight(this.trState,t),this.updateText()}get textAlign(){return this.trState.props.textAlign}set textAlign(t){this.textRenderer.set.textAlign(this.trState,t),this.updateText()}get contain(){return this.trState.props.contain}set contain(t){this.textRenderer.set.contain(this.trState,t),this.updateText()}get scrollable(){return this.trState.props.scrollable}set scrollable(t){this.textRenderer.set.scrollable(this.trState,t),this.updateText()}get scrollY(){return this.trState.props.scrollY}set scrollY(t){this.textRenderer.set.scrollY(this.trState,t),this.updateText()}get offsetY(){return this.trState.props.offsetY}set offsetY(t){this.textRenderer.set.offsetY(this.trState,t),this.updateText()}get letterSpacing(){return this.trState.props.letterSpacing}set letterSpacing(t){this.textRenderer.set.letterSpacing(this.trState,t),this.updateText()}get debug(){return this.trState.props.debug}set debug(t){this.textRenderer.set.debug(this.trState,t),this.updateText()}update(t){super.update(t),this.textRenderer.set.x(this.trState,this.worldContext.px),this.textRenderer.set.y(this.trState,this.worldContext.py),"loading"===this.trState.status&&this.updateText()}updateText(){this.updateScheduled||(this.updateScheduled=!0,queueMicrotask((()=>{this.updateScheduled=!1,this.textRenderer.updateState(this.trState)})))}renderQuads(t,e){this.textRenderer.renderQuads(this.trState,e)}resolveTextRendererAndState(t,e){const r=this.stage.resolveTextRenderer(t,this._textRendererOverride),o=r.createState(t);return e&&["loading","loaded","failed"].forEach((t=>{e.emitter.off(t)})),o.emitter.on("loading",(()=>{o.emitter.once("fontLoaded",(()=>{this.updateText()})),o.emitter.once("loaded",(()=>{o.emitter.off("fontLoaded")}))})),o.emitter.on("loaded",this.onTextLoaded),o.emitter.on("failed",this.onTextFailed),this.updateText(),{resolvedTextRenderer:r,textRendererState:o}}});const nt=function(t,e,r){return t()},it=self;function at(t,e){if(!t)throw new Error(e||"Assertion failed")}class lt{threadx;sharedObjectStruct;mutations;waitPromise=null;mutationsQueued=!1;static staticInitialized=!1;_id;_typeId;initialized=!1;destroying=!1;curProps;static extractBuffer(t){if(t.destroying||!t.sharedObjectStruct)throw new Error("SharedObject.extractBuffer(): SharedObject is or was being destroyed.");return t.sharedObjectStruct.buffer}constructor(t,e){this.curProps=e,this.threadx=pt.instance,this.sharedObjectStruct=t,this._id=t.id,this._typeId=t.typeId;const r=this.constructor;if(!Object.prototype.hasOwnProperty.call(r,"staticInitialized")||!r.staticInitialized){r.staticInitialized=!0;const t=Object.getPrototypeOf(this);Object.keys(e).forEach((e=>{Object.defineProperty(t,e,{get:function(){return this.curProps[e]},set:function(t){this.curProps[e]=t,this.mutations[e]=!0,this.queueMutations()}})}))}this.mutations={},this._executeMutations(),this.initialized=!0}get typeId(){return this._typeId}get id(){return this._id}processDirtyProperties(){if(!this.sharedObjectStruct)throw new Error("SharedObject was destroyed");const{sharedObjectStruct:t,mutations:e,curProps:r}=this;t.constructor.propDefs.forEach(((o,s)=>{if(t.isDirty(s)){const s=o.name;delete e[s];const n=r[s];r[s]=t[s],this.initialized&&this.onPropertyChange(s,t[s],n)}})),t.resetDirty()}onPropertyChange(t,e,r){}queueMutations(){this.mutationsQueued||(this.mutationsQueued=!0,queueMicrotask((()=>{this.mutationsQueued=!1,this.sharedObjectStruct&&this.mutationMicrotask().catch(console.error)})))}async mutationMicrotask(){if(!this.sharedObjectStruct)throw new Error("SharedObject was destroyed");await this.sharedObjectStruct.lockAsync((async()=>{this._executeMutations()})),this.destroying&&this.finishDestroy()}flush(){if(this.destroying||!this.sharedObjectStruct)throw new Error("SharedObject was destroyed");this.sharedObjectStruct.lock((()=>{this._executeMutations()}))}onDestroy(){}destroy(){const t=this.sharedObjectStruct;!this.destroying&&t&&(this.emit("beforeDestroy",{},{localOnly:!0}),this.destroying=!0,this.onDestroy(),this.queueMutations())}finishDestroy(){const t=this.sharedObjectStruct;this.destroying&&t&&(this.threadx.forgetObjects([this],{silent:!0}).catch(console.error),this.sharedObjectStruct=null,t.notify(),this.emit("afterDestroy",{},{localOnly:!0}),this.eventListeners={})}get isDestroyed(){return null===this.sharedObjectStruct}_executeMutations(){if(!this.sharedObjectStruct)return;this.sharedObjectStruct.notifyValue!==this.threadx.workerId&&this.sharedObjectStruct.isDirty()&&this.processDirtyProperties();const{mutations:t}=this;this.mutations={};for(const o in t)if(Object.prototype.hasOwnProperty.call(t,o)){const t=this.curProps[o];this.sharedObjectStruct[o],this.sharedObjectStruct[o]=t}this.waitPromise&&(this.waitPromise=null);let e=this.sharedObjectStruct.notifyValue;this.sharedObjectStruct.isDirty()&&(this.sharedObjectStruct.notify(this.threadx.workerId),e=this.threadx.workerId);const r=this.sharedObjectStruct.waitAsync(e).then((async t=>{this.waitPromise===r&&this.sharedObjectStruct&&(at("ok"===t),this.waitPromise=null,await this.mutationMicrotask())}));this.waitPromise=r}eventListeners={};on(t,e){let r=this.eventListeners[t];r||(r=[]),r.push(e),this.eventListeners[t]=r}off(t,e){const r=this.eventListeners[t];if(!r)return;const o=r.indexOf(e);o>=0&&r.splice(o,1)}once(t,e){const r=(o,s)=>{this.off(t,r),e(o,s)};this.on(t,r)}emit(t,e,r={}){const o=this.eventListeners[t];r.localOnly||pt.instance.__sharedObjectEmit(this,t,e),o&&[...o].forEach((t=>{t(this,e)}))}}function ct(t){return t>=65&&t<=90||t>=48&&t<=57}function ht(t){let e=0;if(0===t.length)throw new Error("genTypeId: Type ID string must be at least 1 character");if(t.length>4)throw new Error("genTypeId: Type ID string must be 4 characters or less");for(let r=0;r<t.length;r++){let o=t.charCodeAt(r);if(o!=o)o=0;else if(!ct(o))throw new Error(`genTypeId: Invalid character '${t[r]}' (char code: ${o}) in type ID string. A-Z and 0-9 only.`);e|=o<<8*r}return e}function dt(t){const e=[];for(let r=0;r<4;r++){const o=255&t;if(ct(o))e.push(String.fromCharCode(o));else if(0!==o||0===r)return"????";t>>>=8}return e.join("")}function ut(t,e){return"object"==typeof e&&null!==e&&"threadXMessageType"in e&&e.threadXMessageType===t}class pt{static init(t){if(it.THREADX)throw new Error("ThreadX.init(): ThreadX already initialized.");const e=new pt(t);return it.THREADX=e,e}static destroy(){it.THREADX?delete it.THREADX:console.warn("ThreadX.destroy(): ThreadX is not initialized.")}static get workerId(){if(!it.THREADX)throw new Error("ThreadX not initialized");return it.THREADX.workerId}static get workerName(){if(!it.THREADX)throw new Error("ThreadX not initialized");return it.THREADX.workerName}static get instance(){if(!it.THREADX)throw new Error("ThreadX not initialized");return it.THREADX}workerId;workerName;sharedObjectFactory;onSharedObjectCreated;onBeforeObjectForgotten;onUserMessage;sharedObjects=new Map;sharedObjectData=new WeakMap;workers=new Map;workerReadyPromises=new Map;pendingAsyncMsgs=new Map;nextAsyncMsgId=0;nextUniqueId=0;suppressSharedObjectEmit=!1;constructor(t){this.workerId=t.workerId,this.workerName=t.workerName,this.nextUniqueId=1e13*t.workerId+1,this.sharedObjectFactory=t.sharedObjectFactory,this.onSharedObjectCreated=t.onObjectShared,this.onBeforeObjectForgotten=t.onBeforeObjectForgotten,this.onUserMessage=t.onMessage;const e=it;"function"==typeof e.DedicatedWorkerGlobalScope&&(this.registerWorker("parent",e),this.sendMessage("parent",{threadXMessageType:"ready"}))}registerWorker(t,e){let r,o;this.workers.set(t,e),"parent"===t?(o=Promise.resolve(),r=()=>{}):o=new Promise((t=>{r=t})),this.workerReadyPromises.set(t,{promise:o,resolve:r}),this.listenForWorkerMessages(t,e)}closeWorker(t){if(!this.workers.has(t))throw new Error(`Worker ${t} not registered.`);this.closeWorkerAsync(t).catch(console.error)}async closeWorkerAsync(t,e=5e3){const r=this.workers.get(t);if(!r)throw new Error(`Worker ${t} not registered.`);const o=await Promise.race([new Promise((t=>{setTimeout((()=>{t(!1)}),e)})),this.sendMessageAsync(t,{threadXMessageType:"close"})]);return this.workers.delete(t),this.workerReadyPromises.delete(t),o?"graceful":(console.warn(`threadX.closeWorkerAsync(): Worker "${t}" did not respond to "close" message within ${e}ms. Forcing termination.`),r.terminate?.(),"forced")}listenForWorkerMessages(t,e){e.addEventListener("message",(r=>{const{data:o}=r,s=o.__asyncMsgId;this.onMessage(t,o).then((t=>{void 0!==s&&e.postMessage({threadXMessageType:"response",asyncMsgId:s,data:t})})).catch((t=>{void 0!==s&&e.postMessage({threadXMessageType:"response",asyncMsgId:s,error:!0,data:t})}))}))}async shareObjects(t,e){for(const r of e)this.sharedObjects.get(r.id)?console.warn(`ThreadX.shareObject(): SharedObject ${r.id} (TypeID: ${dt(r.typeId)}) is already shared.`):(this.sharedObjects.set(r.id,r),this.sharedObjectData.set(r,{workerName:t,shareConfirmed:!1,emitQueue:null}));await this.sendMessageAsync(t,{threadXMessageType:"shareObjects",buffers:e.map((t=>lt.extractBuffer(t)))});for(const r of e){const t=this.sharedObjectData.get(r);if(t){t.shareConfirmed=!0;const{emitQueue:e}=t;if(e){for(const t of e)this.__sharedObjectEmit(r,t[0],t[1]);t.emitQueue=null}}}}async forgetObjects(t,e={}){const r=new Map;for(const s of t)if(this.sharedObjects.has(s.id)){const t=this.sharedObjectData.get(s);at(t);let e=r.get(t.workerName);e||(e=[],r.set(t.workerName,e)),e.push(s),this.sharedObjects.delete(s.id),this.sharedObjectData.delete(s)}else e.silent||console.warn(`ThreadX.forgetObject(): SharedObject ${s.id} (TypeID: ${dt(s.typeId)}) is not shared.`);const o=[];for(const[s,n]of r)o.push(this.sendMessageAsync(s,{threadXMessageType:"forgetObjects",objectIds:n.map((t=>t.id))}));await Promise.all(o)}sendMessage(t,e,r){if(!this.workers.get(t))throw new Error(`ThreadX.sendMessage(): Worker '${t}' not registered.`);this.sendMessageAsync(t,e,r,{skipResponseWait:!0}).catch(console.error)}async sendMessageAsync(t,e,r,o={}){const s=this.workers.get(t);if(!s)throw new Error(`ThreadX.execMessage(): Worker '${t}' not registered.`);if(await this.workerReadyPromises.get(t).promise,o.skipResponseWait)return void s.postMessage(e,r);const n=this.nextAsyncMsgId++,i=new Promise(((t,e)=>{this.pendingAsyncMsgs.set(n,{resolve:t,reject:e})}));return e.__asyncMsgId=n,s.postMessage(e,r),i}async onMessage(t,e){if(ut("shareObjects",e))e.buffers.forEach((e=>{const r=this.sharedObjectFactory?.(e);if(!r)throw new Error("ThreadX.onMesasge(): Failed to create shared object.");this.sharedObjects.set(r.id,r),this.sharedObjectData.set(r,{workerName:t,shareConfirmed:!0,emitQueue:null}),this.onSharedObjectCreated?.(r)}));else if(ut("forgetObjects",e))e.objectIds.forEach((t=>{const e=this.sharedObjects.get(t);e&&(this.onBeforeObjectForgotten?.(e),this.sharedObjects.delete(t),e.destroy())}));else if(ut("sharedObjectEmit",e)){const t=this.sharedObjects.get(e.sharedObjectId);if(!t)return;this.suppressSharedObjectEmit=!0,t.emit(e.eventName,e.data),this.suppressSharedObjectEmit=!1}else if(ut("response",e)){const t=this.pendingAsyncMsgs.get(e.asyncMsgId);if(!t)throw new Error(`ThreadX.onMessage(): Received response for unknown request (ID: ${e.asyncMsgId})`);this.pendingAsyncMsgs.delete(e.asyncMsgId),e.error?t.reject(e.data):t.resolve(e.data)}else{if(ut("close",e))return it.close(),!0;if(ut("ready",e))return this.workerReadyPromises.get(t)?.resolve(),!0;if(this.onUserMessage)return await this.onUserMessage(e)}}getSharedObjectById(t){return this.sharedObjects.get(t)||null}generateUniqueId(){return this.nextUniqueId++}__sharedObjectEmit(t,e,r){if(this.suppressSharedObjectEmit)return;const o=this.sharedObjectData.get(t);if(!o)return;if(!o.shareConfirmed)return o.emitQueue||(o.emitQueue=[]),void o.emitQueue.push([e,r]);const s=this.workers.get(o.workerName);at(s,"Worker not found"),s.postMessage({threadXMessageType:"sharedObjectEmit",sharedObjectId:t.id,eventName:e,data:r})}}t("T",pt);const ft=255;function mt(t,e,r){return t===e}function gt(t,e){return t===e}function xt(t,e){return function(r,o,s){const n=r.constructor;Object.prototype.hasOwnProperty.call(n,"staticInitialized")&&n.staticInitialized||n.initStatic();let i=n.size,a=0,l=0;"string"===t?(i+=i%2,a=i/2,l=512):"int32"===t||"boolean"===t?(i+=i%4,a=i/4,l=4):"number"===t&&(i+=i%8,a=i/8,l=8);const c=n.propDefs,h=c.length,d={propNum:h,name:o,type:t,byteOffset:i,offset:a,byteSize:l};c.push(d),n.size=i+l,s.get=function(){let r;if("string"===t){const t=this.uint16array[a];if(!t)return"";if(t>ft)throw new Error(`get SharedObject.${o}: Text length is too long. Length: ${t}`);r=String.fromCharCode(...this.uint16array.slice(a+1,a+1+t))}else"int32"===t?r=this.int32array[a]:"boolean"===t?r=!!this.int32array[a]:"number"===t&&(r=this.float64array[a]);return e?.bufferToProp&&(r=e.bufferToProp(r)),r},s.set=function(r){if(e?.propToBuffer&&(r=e.propToBuffer(r)),mt("string",t)){if(!gt(r,this[o])){this.setDirty(h);let t=r.length;t>ft&&(console.error(`set SharedObject.${o}: Text length is too long. Truncating...`,t),t=ft),this.uint16array[a]=t;const e=a+1,s=e+t;let n=0;for(let o=e;o<s;o++)this.uint16array[o]=r.charCodeAt(n++)}}else mt("int32",t)?gt(r,this[o])||(this.setDirty(h),this.int32array[a]=r):mt("boolean",t)?gt(r,this[o])||(this.setDirty(h),this.int32array[a]=r?1:0):mt("number",t)&&(gt(r,this[o])||(this.setDirty(h),this.float64array[a]=r))}}}class yt{buffer;lockId=Math.floor(4294967295*Math.random());uint16array;int32array;float64array;static staticInitialized=!1;static typeId=0;static typeIdStr="";static size=32;static propDefs=[];constructor(t){const e=this.constructor;Object.prototype.hasOwnProperty.call(e,"staticInitialized")&&e.staticInitialized||e.initStatic();const r=!t;t||(t=new SharedArrayBuffer(8*Math.ceil(e.size/8))),this.buffer=t,this.uint16array=new Uint16Array(t),this.int32array=new Int32Array(t),this.float64array=new Float64Array(t);const o=e.typeId;if(r)this.int32array[0]=o,this.float64array[2]=pt.instance.generateUniqueId();else if(this.int32array[0]!==o)throw new Error(`BufferStruct: TypeId mismatch. Expected '${e.typeIdStr}', got '${dt(this.int32array[0])}'`)}static extractTypeId(t){return t.byteLength<yt.size||t.byteLength%8!=0?0:new Int32Array(t)[0]||0}static initStatic(){const t=dt(this.typeId);if("????"===t)throw new Error("BufferStruct.typeId must be set to a valid 32-bit integer");this.typeIdStr=t,this.propDefs=[...this.propDefs],this.staticInitialized=!0}setDirty(t){const e=Math.floor(t/32),r=t-32*e;this.int32array[6+e]=this.int32array[6+e]|1<<r}resetDirty(){this.int32array[1]=0,this.int32array[6]=0,this.int32array[7]=0}isDirty(t){if(void 0!==t){const e=Math.floor(t/32),r=t-32*e;return!!(this.int32array[6+e]&1<<r)}return!(!this.int32array[6]&&!this.int32array[7])}get typeId(){return this.int32array[0]}get id(){return this.float64array[2]}get notifyValue(){return Atomics.load(this.int32array,1)}get isLocked(){return 0!==Atomics.load(this.int32array,2)}lock(t){let e,r=Atomics.compareExchange(this.int32array,2,0,this.lockId);for(;0!==r;){try{Atomics.wait(this.int32array,2,r)}catch(o){if(!(o instanceof TypeError&&"Atomics.wait cannot be called in this context"===o.message))throw o}r=Atomics.compareExchange(this.int32array,2,0,this.lockId)}try{e=t()}finally{Atomics.store(this.int32array,2,0),Atomics.notify(this.int32array,2)}return e}async lockAsync(t){let e,r=Atomics.compareExchange(this.int32array,2,0,this.lockId);for(;0!==r;){const t=Atomics.waitAsync(this.int32array,2,r);await t.value,r=Atomics.compareExchange(this.int32array,2,0,this.lockId)}try{e=await t()}finally{Atomics.store(this.int32array,2,0),Atomics.notify(this.int32array,2)}return e}notify(t){return void 0!==t&&Atomics.store(this.int32array,1,t),Atomics.notify(this.int32array,1)}wait(t,e=1/0){return Atomics.wait(this.int32array,1,t,e)}async waitAsync(t,e=1/0){return Atomics.waitAsync(this.int32array,1,t,e).value}}t("B",yt);var vt=globalThis&&globalThis.__decorate||function(t,e,r,o){var s,n=arguments.length,i=n<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,r):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,r,o);else for(var a=t.length-1;a>=0;a--)(s=t[a])&&(i=(n<3?s(i):n>3?s(e,r,i):s(e,r))||i);return n>3&&i&&Object.defineProperty(e,r,i),i};class _t extends yt{static typeId=ht("NODE");get x(){return 0}set x(t){}get y(){return 0}set y(t){}get width(){return 0}set width(t){}get height(){return 0}set height(t){}get alpha(){return 1}set alpha(t){}get clipping(){return!1}set clipping(t){}get color(){return 0}set color(t){}get colorTop(){return 0}set colorTop(t){}get colorBottom(){return 0}set colorBottom(t){}get colorLeft(){return 0}set colorLeft(t){}get colorRight(){return 0}set colorRight(t){}get colorTl(){return 0}set colorTl(t){}get colorTr(){return 0}set colorTr(t){}get colorBl(){return 0}set colorBl(t){}get colorBr(){return 0}set colorBr(t){}get scale(){return 1}set scale(t){}get mount(){return 0}set mount(t){}get mountX(){return 0}set mountX(t){}get mountY(){return 0}set mountY(t){}get pivot(){return.5}set pivot(t){}get pivotX(){return.5}set pivotX(t){}get pivotY(){return.5}set pivotY(t){}get rotation(){return 0}set rotation(t){}get parentId(){return 0}set parentId(t){}get zIndex(){return 0}set zIndex(t){}get zIndexLocked(){return 0}set zIndexLocked(t){}}t("N",_t),vt([xt("number")],_t.prototype,"x",null),vt([xt("number")],_t.prototype,"y",null),vt([xt("number")],_t.prototype,"width",null),vt([xt("number")],_t.prototype,"height",null),vt([xt("number")],_t.prototype,"alpha",null),vt([xt("boolean")],_t.prototype,"clipping",null),vt([xt("number")],_t.prototype,"color",null),vt([xt("number")],_t.prototype,"colorTop",null),vt([xt("number")],_t.prototype,"colorBottom",null),vt([xt("number")],_t.prototype,"colorLeft",null),vt([xt("number")],_t.prototype,"colorRight",null),vt([xt("number")],_t.prototype,"colorTl",null),vt([xt("number")],_t.prototype,"colorTr",null),vt([xt("number")],_t.prototype,"colorBl",null),vt([xt("number")],_t.prototype,"colorBr",null),vt([xt("number")],_t.prototype,"scale",null),vt([xt("number")],_t.prototype,"mount",null),vt([xt("number")],_t.prototype,"mountX",null),vt([xt("number")],_t.prototype,"mountY",null),vt([xt("number")],_t.prototype,"pivot",null),vt([xt("number")],_t.prototype,"pivotX",null),vt([xt("number")],_t.prototype,"pivotY",null),vt([xt("number")],_t.prototype,"rotation",null),vt([xt("number")],_t.prototype,"parentId",null),vt([xt("number")],_t.prototype,"zIndex",null),vt([xt("number")],_t.prototype,"zIndexLocked",null),t("d",class extends lt{constructor(t,e){super(t,{...e,x:t.x,y:t.y,width:t.width,height:t.height,alpha:t.alpha,clipping:t.clipping,color:t.color,colorTop:t.colorTop,colorBottom:t.colorBottom,colorLeft:t.colorLeft,colorRight:t.colorRight,colorTl:t.colorTl,colorTr:t.colorTr,colorBl:t.colorBl,colorBr:t.colorBr,parentId:t.parentId,zIndex:t.zIndex,zIndexLocked:t.zIndexLocked,scale:t.scale,mount:t.mount,mountX:t.mountX,mountY:t.mountY,pivot:t.pivot,pivotX:t.pivotX,pivotY:t.pivotY,rotation:t.rotation})}});var wt=globalThis&&globalThis.__decorate||function(t,e,r,o){var s,n=arguments.length,i=n<3?e:null===o?o=Object.getOwnPropertyDescriptor(e,r):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,r,o);else for(var a=t.length-1;a>=0;a--)(s=t[a])&&(i=(n<3?s(i):n>3?s(e,r,i):s(e,r))||i);return n>3&&i&&Object.defineProperty(e,r,i),i};class bt extends _t{static typeId=ht("TEXT");get text(){return""}set text(t){}get textRendererOverride(){return null}set textRendererOverride(t){}get fontSize(){return 0}set fontSize(t){}get fontFamily(){return""}set fontFamily(t){}get fontStretch(){return"normal"}set fontStretch(t){}get fontStyle(){return"normal"}set fontStyle(t){}get fontWeight(){return"normal"}set fontWeight(t){}get textAlign(){return"left"}set textAlign(t){}get contain(){return"none"}set contain(t){}get scrollable(){return!1}set scrollable(t){}get scrollY(){return 0}set scrollY(t){}get offsetY(){return 0}set offsetY(t){}get letterSpacing(){return 0}set letterSpacing(t){}}t("e",bt),wt([xt("string")],bt.prototype,"text",null),wt([xt("string",{propToBuffer:t=>t??"$$null",bufferToProp:t=>"$$null"===t?null:t})],bt.prototype,"textRendererOverride",null),wt([xt("number")],bt.prototype,"fontSize",null),wt([xt("string")],bt.prototype,"fontFamily",null),wt([xt("string")],bt.prototype,"fontStretch",null),wt([xt("string")],bt.prototype,"fontStyle",null),wt([xt("string")],bt.prototype,"fontWeight",null),wt([xt("string")],bt.prototype,"textAlign",null),wt([xt("string")],bt.prototype,"contain",null),wt([xt("boolean")],bt.prototype,"scrollable",null),wt([xt("number")],bt.prototype,"scrollY",null),wt([xt("number")],bt.prototype,"offsetY",null),wt([xt("number")],bt.prototype,"letterSpacing",null)}}}));
//# sourceMappingURL=TextNodeStruct-legacy-4e399b28.js.map
