var Ce=Object.defineProperty;var Ie=(a,s,t)=>s in a?Ce(a,s,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[s]=t;var n=(a,s,t)=>(Ie(a,typeof s!="symbol"?s+"":s,t),t);import{E as Wt,g as Re,m as se,a as M,b as Et,c as it,T as de,d as ke,e as Me,i as Ee,S as re,f as fe,B as Oe,h as ze,j as Fe,k as Bt,W as oe,l as ue,n as De,o as Ae,C as Pe}from"./CoreExtension-c81fcba3.js";class cs extends Wt{constructor(t,e,r){super();n(this,"node");n(this,"props");n(this,"settings");n(this,"propStartValues",{});n(this,"restoreValues",{});n(this,"progress",0);n(this,"timingFunction");this.node=t,this.props=e,this.settings=r,this.propStartValues={},Object.keys(e).forEach(o=>{this.propStartValues[o]=t[o]}),this.timingFunction=o=>o,r.easing&&typeof r.easing=="string"&&(this.timingFunction=Re(r.easing))}reset(){this.progress=0,this.update(0)}restore(){this.reset(),Object.keys(this.props).forEach(t=>{this.node[t]=this.propStartValues[t]})}reverse(){this.progress=0,Object.keys(this.props).forEach(t=>{const e=this.props[t],r=this.propStartValues[t];this.props[t]=r,this.propStartValues[t]=e}),this.settings.loop||(this.settings.stopMethod=!1)}applyEasing(t,e,r){return(this.timingFunction(t)||t)*(r-e)+e}update(t){const{duration:e,loop:r,easing:o}=this.settings;if(!e){this.emit("finished",{});return}this.progress+=t/e,this.progress>1&&(this.progress=r?0:1,this.emit("finished",{})),Object.keys(this.props).forEach(i=>{const l=this.props[i],c=this.propStartValues[i],h=l;if(i.indexOf("color")!==-1){const d=o?this.timingFunction(this.progress)||this.progress:this.progress,m=se(c,h,d);this.node[i]=o?m:se(c,h,this.progress)}else this.node[i]=o?this.applyEasing(this.progress,c,h):c+(h-c)*this.progress})}}class hs{constructor(s,t){n(this,"manager");n(this,"animation");n(this,"stoppedPromise",null);n(this,"stoppedResolve",null);n(this,"state");this.manager=s,this.animation=t,this.state="stopped"}start(){return this.makeStoppedPromise(),this.animation.once("finished",this.finished.bind(this)),this.manager.activeAnimations.has(this.animation)||this.manager.registerAnimation(this.animation),this.state="running",this}stop(){return this.manager.unregisterAnimation(this.animation),this.stoppedResolve!==null&&(this.stoppedResolve(),this.stoppedResolve=null),this.animation.reset(),this.state="stopped",this}pause(){return this.manager.unregisterAnimation(this.animation),this.state="paused",this}restore(){return this.stoppedResolve=null,this.animation.restore(),this}waitUntilStopped(){this.makeStoppedPromise();const s=this.stoppedPromise;return M(s),s}makeStoppedPromise(){this.stoppedResolve===null&&(this.stoppedPromise=new Promise(s=>{this.stoppedResolve=s}))}finished(){M(this.stoppedResolve);const{loop:s,stopMethod:t}=this.animation.settings;if(t==="reverse"){this.animation.reverse(),this.start();return}this.stoppedResolve(),this.stoppedResolve=null,!s&&this.manager.unregisterAnimation(this.animation)}}const L=0,X=3,W=6,$=1,j=4,U=7,q=2,Z=5,J=8;class G{constructor(s){n(this,"data");s?(this.data=new Float32Array(9),this.data[L]=s[0],this.data[X]=s[3],this.data[W]=s[6],this.data[$]=s[1],this.data[j]=s[4],this.data[U]=s[7],this.data[q]=s[2],this.data[Z]=s[5],this.data[J]=s[8]):this.data=new Float32Array(9)}static get temp(){return $e}static multiply(s,t,e){const r=s.data[L]*t.data[L]+s.data[X]*t.data[$]+s.data[W]*t.data[q],o=s.data[L]*t.data[X]+s.data[X]*t.data[j]+s.data[W]*t.data[Z],i=s.data[L]*t.data[W]+s.data[X]*t.data[U]+s.data[W]*t.data[J],l=s.data[$]*t.data[L]+s.data[j]*t.data[$]+s.data[U]*t.data[q],c=s.data[$]*t.data[X]+s.data[j]*t.data[j]+s.data[U]*t.data[Z],h=s.data[$]*t.data[W]+s.data[j]*t.data[U]+s.data[U]*t.data[J],d=s.data[q]*t.data[L]+s.data[Z]*t.data[$]+s.data[J]*t.data[q],m=s.data[q]*t.data[X]+s.data[Z]*t.data[j]+s.data[J]*t.data[Z],g=s.data[q]*t.data[W]+s.data[Z]*t.data[U]+s.data[J]*t.data[J];return e||(e=new G),e.data[L]=r,e.data[X]=o,e.data[W]=i,e.data[$]=l,e.data[j]=c,e.data[U]=h,e.data[q]=d,e.data[Z]=m,e.data[J]=g,e}static identity(s){return s||(s=new G),s.data[L]=1,s.data[X]=0,s.data[W]=0,s.data[$]=0,s.data[j]=1,s.data[U]=0,s.data[q]=0,s.data[Z]=0,s.data[J]=1,s}static translate(s,t,e){return e||(e=new G),e.data[L]=1,e.data[X]=0,e.data[W]=s,e.data[$]=0,e.data[j]=1,e.data[U]=t,e.data[q]=0,e.data[Z]=0,e.data[J]=1,e}static scale(s,t,e){return e||(e=new G),e.data[L]=s,e.data[X]=0,e.data[W]=0,e.data[$]=0,e.data[j]=t,e.data[U]=0,e.data[q]=0,e.data[Z]=0,e.data[J]=1,e}static rotate(s,t){const e=Math.cos(s),r=Math.sin(s);return t||(t=new G),t.data[L]=e,t.data[X]=-r,t.data[W]=0,t.data[$]=r,t.data[j]=e,t.data[U]=0,t.data[q]=0,t.data[Z]=0,t.data[J]=1,t}static copy(s,t,e){return t||(t=new G),t.data[0]=s.data[0],t.data[1]=s.data[1],t.data[2]=s.data[2],t.data[3]=s.data[3],t.data[4]=s.data[4],t.data[5]=s.data[5],t.data[6]=s.data[6],t.data[7]=s.data[7],t.data[8]=s.data[8],t}translate(s,t){return this.data[W]=this.data[L]*s+this.data[X]*t+this.data[W],this.data[U]=this.data[$]*s+this.data[j]*t+this.data[U],this}scale(s,t){return this.data[L]=this.data[L]*s,this.data[X]=this.data[X]*t,this.data[$]=this.data[$]*s,this.data[j]=this.data[j]*t,this}rotate(s){if(s===0||!(s%Math.PI*2))return this;const t=Math.cos(s),e=Math.sin(s),r=this.data[L]*t+this.data[X]*e,o=this.data[X]*t-this.data[L]*e,i=this.data[$]*t+this.data[j]*e,l=this.data[j]*t-this.data[$]*e;return this.data[L]=r,this.data[X]=o,this.data[$]=i,this.data[j]=l,this}multiply(s){return G.multiply(this,s,this)}get tx(){return this.data[W]}get ty(){return this.data[U]}get ta(){return this.data[L]}get tb(){return this.data[X]}get tc(){return this.data[$]}get td(){return this.data[j]}transformPoint(s,t){return[this.data[L]*s+this.data[X]*t+this.data[W],this.data[$]*s+this.data[j]*t+this.data[$]]}}const $e=new G;class pe extends Wt{constructor(t,e){super();n(this,"stage");n(this,"children",[]);n(this,"props");n(this,"recalculationType",6);n(this,"hasUpdates",!0);n(this,"globalTransform");n(this,"scaleRotateTransform");n(this,"localTransform");n(this,"isComplex",!1);n(this,"onTextureLoaded",(t,e)=>{this.emit("loaded",{type:"texture",dimensions:e})});n(this,"onTextureFailed",(t,e)=>{this.emit("failed",{type:"texture",error:e})});this.stage=t,this.props={...e,parent:null},this.parent=e.parent,this.updateScaleRotateTransform()}loadTexture(t,e,r=null){this.props.texture&&this.unloadTexture();const{txManager:o}=this.stage,i=o.loadTexture(t,e,r);this.props.texture=i,this.props.textureOptions=r,queueMicrotask(()=>{i.state==="loaded"?this.onTextureLoaded(i,i.dimensions):i.state==="failed"&&this.onTextureFailed(i,i.error),i.on("loaded",this.onTextureLoaded),i.on("failed",this.onTextureFailed)})}unloadTexture(){this.props.texture&&(this.props.texture.off("loaded",this.onTextureLoaded),this.props.texture.off("failed",this.onTextureFailed)),this.props.texture=null,this.props.textureOptions=null}loadShader(t,e){const r=this.stage.renderer.getShaderManager();M(r);const{shader:o,props:i}=r.loadShader(t,e);this.props.shader=o,this.props.shaderProps=i}setHasUpdates(){if(!this.props.alpha)return;this.hasUpdates=!0;let t=this==null?void 0:this.props.parent;for(;t;)t.hasUpdates=!0,t=t==null?void 0:t.props.parent}setRecalculationType(t){this.recalculationType|=t,this.setHasUpdates()}updateScaleRotateTransform(){this.setRecalculationType(4),this.scaleRotateTransform=G.rotate(this.props.rotation,this.scaleRotateTransform).scale(this.props.scaleX,this.props.scaleY),this.updateLocalTransform()}updateLocalTransform(){M(this.scaleRotateTransform),this.setRecalculationType(2);const t=this.props.pivotX*this.props.width,e=this.props.pivotY*this.props.height,r=this.props.mountX*this.props.width,o=this.props.mountY*this.props.height;this.localTransform=G.translate(t-r+this.props.x,e-o+this.props.y,this.localTransform).multiply(this.scaleRotateTransform).translate(-t,-e)}update(t){var r;M(this.localTransform);const e=(r=this.parent)==null?void 0:r.globalTransform;e?this.globalTransform=G.copy(e,this.globalTransform).multiply(this.localTransform):this.globalTransform=G.copy(this.localTransform,this.globalTransform),this.children.length&&this.children.forEach(o=>{o.update(t)}),this.hasUpdates=!1,this.recalculationType=0}renderQuads(t,e){const{width:r,height:o,colorTl:i,colorTr:l,colorBl:c,colorBr:h,texture:d,textureOptions:m,shader:g,shaderProps:u}=this.props,{zIndex:y,worldAlpha:p,globalTransform:x}=this;M(x),t.addRenderable({width:r,height:o,colorTl:i,colorTr:l,colorBl:c,colorBr:h,texture:d,textureOptions:m,zIndex:y,shader:g,shaderProps:u,alpha:p,clippingRect:e,tx:x.tx,ty:x.ty,ta:x.ta,tb:x.tb,tc:x.tc,td:x.td})}get id(){return this.props.id}get x(){return this.props.x}set x(t){this.props.x!==t&&(this.props.x=t,this.updateLocalTransform())}get absX(){var t,e,r;return this.props.x+(((t=this.props.parent)==null?void 0:t.absX)||((r=(e=this.props.parent)==null?void 0:e.globalTransform)==null?void 0:r.tx)||0)}get absY(){var t,e;return this.props.y+((e=(t=this.props.parent)==null?void 0:t.absY)!=null?e:0)}get y(){return this.props.y}set y(t){this.props.y!==t&&(this.props.y=t,this.updateLocalTransform())}get width(){return this.props.width}set width(t){this.props.width!==t&&(this.props.width=t,this.updateLocalTransform())}get height(){return this.props.height}set height(t){this.props.height!==t&&(this.props.height=t,this.updateLocalTransform())}get scale(){return this.scaleX}set scale(t){this.scaleX=t,this.scaleY=t}get scaleX(){return this.props.scaleX}set scaleX(t){this.props.scaleX!==t&&(this.props.scaleX=t,this.updateScaleRotateTransform())}get scaleY(){return this.props.scaleY}set scaleY(t){this.props.scaleY!==t&&(this.props.scaleY=t,this.updateScaleRotateTransform())}get worldScaleX(){var t,e;return this.props.scaleX*((e=(t=this.props.parent)==null?void 0:t.worldScaleX)!=null?e:1)||this.props.scaleX}get worldScaleY(){var t,e;return this.props.scaleY*((e=(t=this.props.parent)==null?void 0:t.worldScaleY)!=null?e:1)||this.props.scaleY}get mount(){return this.props.mount}set mount(t){this.props.mountX=t,this.props.mountY=t,this.props.mount=t,this.updateLocalTransform()}get mountX(){return this.props.mountX}set mountX(t){this.props.mountX=t,this.updateLocalTransform()}get mountY(){return this.props.mountY}set mountY(t){this.props.mountY=t,this.updateLocalTransform()}get pivot(){return this.props.pivot}set pivot(t){(this.props.pivotX!==t||this.props.pivotY!==t)&&(this.props.pivotX=t,this.props.pivotY=t,this.updateLocalTransform())}get pivotX(){return this.props.pivotX}set pivotX(t){this.props.pivotX=t,this.updateLocalTransform()}get pivotY(){return this.props.pivotY}set pivotY(t){this.props.pivotY=t,this.updateLocalTransform()}get rotation(){return this.props.rotation}set rotation(t){this.props.rotation!==t&&(this.props.rotation=t,this.updateScaleRotateTransform())}get alpha(){return this.props.alpha}set alpha(t){this.props.alpha=t}get worldAlpha(){const t=this.props,e=t.parent;return t.alpha*((e==null?void 0:e.worldAlpha)||1)}get clipping(){return this.props.clipping}set clipping(t){this.props.clipping=t}get color(){return this.props.color}set color(t){(this.props.colorTl!==t||this.props.colorTr!==t||this.props.colorBl!==t||this.props.colorBr!==t)&&(this.colorTl=t,this.colorTr=t,this.colorBl=t,this.colorBr=t),this.props.color=t}get colorTop(){return this.props.colorTop}set colorTop(t){(this.props.colorTl!==t||this.props.colorTr!==t)&&(this.colorTl=t,this.colorTr=t),this.props.colorTop=t}get colorBottom(){return this.props.colorBottom}set colorBottom(t){(this.props.colorBl!==t||this.props.colorBr!==t)&&(this.colorBl=t,this.colorBr=t),this.props.colorBottom=t}get colorLeft(){return this.props.colorLeft}set colorLeft(t){(this.props.colorTl!==t||this.props.colorBl!==t)&&(this.colorTl=t,this.colorBl=t),this.props.colorLeft=t}get colorRight(){return this.props.colorRight}set colorRight(t){(this.props.colorTr!==t||this.props.colorBr!==t)&&(this.colorTr=t,this.colorBr=t),this.props.colorRight=t}get colorTl(){return this.props.colorTl}set colorTl(t){this.props.colorTl=t}get colorTr(){return this.props.colorTr}set colorTr(t){this.props.colorTr=t}get colorBl(){return this.props.colorBl}set colorBl(t){this.props.colorBl=t}get colorBr(){return this.props.colorBr}set colorBr(t){this.props.colorBr=t}get zIndexLocked(){return this.props.zIndexLocked||0}set zIndexLocked(t){this.props.zIndexLocked=t}get zIndex(){var o,i;const t=this.props,e=t.zIndex||0,r=((o=t.parent)==null?void 0:o.zIndex)||0;return(i=t.parent)!=null&&i.zIndexLocked?e<r?e:r:e}set zIndex(t){this.props.zIndex=t}get parent(){return this.props.parent}set parent(t){const e=this.props.parent;if(e!==t){if(this.props.parent=t,e){const r=e.children.indexOf(this);M(r!==-1,"CoreNode.parent: Node not found in old parent's children!"),e.children.splice(r,1)}t&&t.children.push(this),this.updateScaleRotateTransform()}}}class Le{constructor(s){n(this,"root");this.root=s}getNodeByType(s){return[]}getNodeById(s){return null}update(s){this.root.update(s)}}const Xe=a=>{const s=()=>{a.drawFrame(),requestAnimationFrame(s)};requestAnimationFrame(s)},je=()=>performance?performance.now():Date.now();class me extends Et{constructor(s){super({renderer:s,attributes:["a_position","a_textureCoordinate","a_color"],uniforms:[{name:"u_resolution",uniform:"uniform2fv"},{name:"u_pixelRatio",uniform:"uniform1f"},{name:"u_texture",uniform:"uniform2fv"}]})}bindTextures(s){const{gl:t}=this;t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,s[0].ctxTexture)}}n(me,"shaderSources",{vertex:"\n      # ifdef GL_FRAGMENT_PRESICISON_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      attribute vec2 a_position;\n      attribute vec2 a_textureCoordinate;\n      attribute vec4 a_color;\n\n      uniform vec2 u_resolution;\n      uniform float u_pixelRatio;\n\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoordinate;\n\n      void main() {\n        vec2 normalized = a_position * u_pixelRatio / u_resolution;\n        vec2 zero_two = normalized * 2.0;\n        vec2 clip_space = zero_two - 1.0;\n\n        // pass to fragment\n        v_color = a_color;\n        v_textureCoordinate = a_textureCoordinate;\n\n        // flip y\n        gl_Position = vec4(clip_space * vec2(1.0, -1.0), 0, 1);\n      }\n    ",fragment:"\n      # ifdef GL_FRAGMENT_PRESICISON_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      uniform vec2 u_resolution;\n      uniform sampler2D u_texture;\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoordinate;\n\n      void main() {\n          vec4 color = texture2D(u_texture, v_textureCoordinate);\n          gl_FragColor = vec4(v_color) * texture2D(u_texture, v_textureCoordinate);\n      }\n    "});class ge extends Et{constructor(t){super({renderer:t,attributes:["a_position","a_textureCoordinate","a_color","a_textureIndex"],uniforms:[{name:"u_resolution",uniform:"uniform2fv"},{name:"u_pixelRatio",uniform:"uniform1f"},{name:"u_textures[0]",uniform:"uniform1iv"}]});n(this,"supportsIndexedTextures",!0)}bindTextures(t){const{renderer:e,gl:r}=this;if(t.length>e.system.parameters.MAX_VERTEX_TEXTURE_IMAGE_UNITS)throw new Error("DefaultShaderBatched: Cannot bind more than ".concat(e.system.parameters.MAX_VERTEX_TEXTURE_IMAGE_UNITS," textures"));t.forEach((i,l)=>{r.activeTexture(r.TEXTURE0+l),r.bindTexture(r.TEXTURE_2D,i.ctxTexture)});const o=Array.from(Array(t.length).keys());this.setUniform("u_textures[0]",o)}}n(ge,"shaderSources",{vertex:"\n      # ifdef GL_FRAGMENT_PRESICISON_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      attribute vec2 a_textureCoordinate;\n      attribute vec2 a_position;\n      attribute vec4 a_color;\n      attribute float a_textureIndex;\n      attribute float a_depth;\n\n      uniform vec2 u_resolution;\n      uniform float u_pixelRatio;\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoordinate;\n      varying float v_textureIndex;\n\n      void main(){\n        vec2 normalized = a_position * u_pixelRatio / u_resolution;\n        vec2 zero_two = normalized * 2.0;\n        vec2 clip_space = zero_two - 1.0;\n\n        // pass to fragment\n        v_color = a_color;\n        v_textureCoordinate = a_textureCoordinate;\n        v_textureIndex = a_textureIndex;\n\n        // flip y\n        gl_Position = vec4(clip_space * vec2(1.0, -1.0), 0, 1);\n      }\n    ",fragment:t=>"\n      #define txUnits ".concat(t,"\n      # ifdef GL_FRAGMENT_PRESICISON_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      uniform vec2 u_resolution;\n      uniform sampler2D u_image;\n      uniform sampler2D u_textures[txUnits];\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoordinate;\n      varying float v_textureIndex;\n\n      vec4 sampleFromTexture(sampler2D textures[").concat(t,"], int idx, vec2 uv) {\n        ").concat(Array.from(Array(t).keys()).map(e=>"\n          ".concat(e!==0?"else ":"","if (idx == ").concat(e,") {\n            return texture2D(textures[").concat(e,"], uv);\n          }\n        ")).join(""),"\n        return texture2D(textures[0], uv);\n      }\n\n      void main(){\n        gl_FragColor = vec4(v_color) * sampleFromTexture(u_textures, int(v_textureIndex), v_textureCoordinate);\n      }\n    ")});class B{constructor(s){n(this,"priority",1);n(this,"name","");n(this,"ref");n(this,"target");n(this,"passParameters","");n(this,"declaredUniforms","");n(this,"uniformInfo",{});const{ref:t,target:e,props:r={}}=s;this.ref=t,this.target=e;const o={},i=[];let l="";const c=this.constructor.uniforms||{};for(const h in c){const d=c[h],m=d.type,g="".concat(t,"_").concat(h);let u="";d.size&&(u="[".concat(d.size(r),"]")),i.push(g),l+="uniform ".concat(m," ").concat(g).concat(u,";"),o[h]={name:g,uniform:c[h].method}}this.passParameters=i.join(","),this.declaredUniforms=l,this.uniformInfo=o}static getEffectKey(s){return""}static getMethodParameters(s,t){const e=[];for(const r in s){const o=s[r];let i="";o.size&&(i="[".concat(o.size(t),"]")),e.push("".concat(o.type," ").concat(r).concat(i))}return e.join(",")}static resolveDefaults(s){return{}}static makeEffectKey(s){return!1}}n(B,"uniforms",{}),n(B,"methods"),n(B,"onShaderMask"),n(B,"onColorize"),n(B,"onEffectMask");class ht extends B{constructor(){super(...arguments);n(this,"name","radius")}static getEffectKey(){return"radius"}static resolveDefaults(t){var e;return{radius:(e=t.radius)!=null?e:10}}}n(ht,"z$__type__Props"),n(ht,"uniforms",{radius:{value:0,method:"uniform4fv",type:"vec4",validator:t=>{let e=t;return Array.isArray(e)?e.length===2?e=[e[0],e[1],e[0],e[1]]:e.length===3?e=[e[0],e[1],e[2],e[0]]:e.length!==4&&(e=[e[0],e[0],e[0],e[0]]):typeof e=="number"&&(e=[e,e,e,e]),e}}}),n(ht,"methods",{fillMask:"\n      float function(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n    ",boxDist:"\n      float function(vec2 p, vec2 size, float radius) {\n        size -= vec2(radius);\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n      }\n    "}),n(ht,"onShaderMask","\n  vec2 halfDimensions = u_dimensions * 0.5;\n  float r = radius[0] * step(v_textureCoordinate.x, 0.5) * step(v_textureCoordinate.y, 0.5);\n  r = r + radius[1] * step(0.5, v_textureCoordinate.x) * step(v_textureCoordinate.y, 0.5);\n  r = r + radius[2] * step(0.5, v_textureCoordinate.x) * step(0.5, v_textureCoordinate.y);\n  r = r + radius[3] * step(v_textureCoordinate.x, 0.5) * step(0.5, v_textureCoordinate.y);\n  return $boxDist(v_textureCoordinate.xy * u_dimensions - halfDimensions, halfDimensions, r);\n  "),n(ht,"onEffectMask","\n  return mix(vec4(0.0), maskColor, $fillMask(shaderMask));\n  ");class yt extends B{constructor(){super(...arguments);n(this,"name","border")}static getEffectKey(){return"border"}static resolveDefaults(t){var e,r;return{width:(e=t.width)!=null?e:10,color:(r=t.color)!=null?r:4294967295}}}n(yt,"z$__type__Props"),n(yt,"uniforms",{width:{value:0,method:"uniform1f",type:"float"},color:{value:4294967295,validator:t=>it(t),method:"uniform4fv",type:"vec4"}}),n(yt,"onEffectMask","\n  float mask = clamp(shaderMask + width, 0.0, 1.0) - clamp(shaderMask, 0.0, 1.0);\n  return mix(shaderColor, maskColor, mask);\n  "),n(yt,"onColorize","\n    return color;\n  ");class dt extends B{constructor(){super(...arguments);n(this,"name","linearGradient")}static getEffectKey(t){return"linearGradient".concat(t.colors.length)}static resolveDefaults(t){var o,i;const e=(o=t.colors)!=null?o:[4278190080,4294967295];let r=t.stops;if(!r){r=[];const l=e.length-1;for(let c=0;c<e.length;c++)r.push(c*(1/l))}return{colors:e,stops:r,angle:(i=t.angle)!=null?i:0}}}n(dt,"z$__type__Props"),n(dt,"uniforms",{angle:{value:0,method:"uniform1f",type:"float"},colors:{value:4294967295,validator:t=>t.map(r=>it(r)).reduce((r,o)=>r.concat(o),[]),size:t=>t.colors.length,method:"uniform4fv",type:"vec4"},stops:{value:[],validator:(t,e)=>{var l;const r=(l=e.colors)!=null?l:[];let o=t;const i=t;if(o.length===0||o&&o.length!==r.length){for(let c=0;c<r.length;c++)o[c]?(i[c]=o[c],o[c-1]===void 0&&i[c-2]!==void 0&&(i[c-1]=i[c-2]+(o[c]-i[c-2])/2)):i[c]=c*(1/(r.length-1));o=i}return i},size:t=>t.colors.length,method:"uniform1fv",type:"float"}}),n(dt,"methods",{fromLinear:"\n      vec4 function(vec4 linearRGB) {\n        vec4 higher = vec4(1.055)*pow(linearRGB, vec4(1.0/2.4)) - vec4(0.055);\n        vec4 lower = linearRGB * vec4(12.92);\n        return mix(higher, lower, 1.0);\n      }\n    ",toLinear:"\n      vec4 function(vec4 sRGB) {\n        vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));\n        vec4 lower = sRGB/vec4(12.92);\n        return mix(higher, lower, 1.0);\n      }\n    ",calcPoint:"\n      vec2 function(float d, float angle) {\n        return d * vec2(cos(angle), sin(angle)) + (u_dimensions * 0.5);\n      }\n    "}),n(dt,"ColorLoop",t=>{let e="";for(let r=2;r<t;r++)e+="colorOut = mix(colorOut, colors[".concat(r,"], clamp((dist - stops[").concat(r-1,"]) / (stops[").concat(r,"] - stops[").concat(r-1,"]), 0.0, 1.0));");return e}),n(dt,"onColorize",t=>{const e=t.colors.length||1;return"\n      float a = angle - (PI / 180.0 * 90.0);\n      float lineDist = abs(u_dimensions.x * cos(a)) + abs(u_dimensions.y * sin(a));\n      vec2 f = $calcPoint(lineDist * 0.5, a);\n      vec2 t = $calcPoint(lineDist * 0.5, a + PI);\n      vec2 gradVec = t - f;\n      float dist = dot(v_textureCoordinate.xy * u_dimensions - f, gradVec) / dot(gradVec, gradVec);\n\n      float stopCalc = (dist - stops[0]) / (stops[1] - stops[0]);\n      vec4 colorOut = $fromLinear(mix($toLinear(colors[0]), $toLinear(colors[1]), stopCalc));\n      for(int i = 1; i < ".concat(e,"-1; i++) {\n        stopCalc = (dist - stops[i]) / (stops[i + 1] - stops[i]);\n        colorOut = mix(colorOut, colors[i + 1], clamp(stopCalc, 0.0, 1.0));\n      }\n      return mix(maskColor, colorOut, clamp(colorOut.a, 0.0, 1.0));\n    ")});class qt extends B{constructor(){super(...arguments);n(this,"name","grayscale")}static getEffectKey(){return"grayscale"}}n(qt,"onColorize","\n    vec3 color = pow(maskColor.rgb, vec3(2.0));\n    float gray = dot(color, vec3(0.2126, 0.7152, 0.0722));\n    float gammaGray = sqrt(gray);\n    return vec4(gammaGray, gammaGray, gammaGray, 1.0);\n  ");class ft extends B{constructor(){super(...arguments);n(this,"name","borderRight")}static getEffectKey(){return"borderRight"}static resolveDefaults(t){var e,r;return{width:(e=t.width)!=null?e:10,color:(r=t.color)!=null?r:4294967295}}}n(ft,"z$__type__Props"),n(ft,"uniforms",{width:{value:0,method:"uniform1f",type:"float"},color:{value:4294967295,validator:t=>it(t),method:"uniform4fv",type:"vec4"}}),n(ft,"methods",{fillMask:"\n      float function(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n    ",rectDist:"\n      float function(vec2 p, vec2 size) {\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n      }\n    "}),n(ft,"onEffectMask","\n  vec2 pos = vec2(u_dimensions.x - width * 0.5, 0.0);\n  float mask = $rectDist(v_textureCoordinate.xy * u_dimensions - pos, vec2(width*0.5, u_dimensions.y));\n  return mix(shaderColor, maskColor, $fillMask(mask));\n  "),n(ft,"onColorize","\n    return color;\n  ");class ut extends B{constructor(){super(...arguments);n(this,"name","borderTop")}static getEffectKey(){return"borderTop"}static resolveDefaults(t){var e,r;return{width:(e=t.width)!=null?e:10,color:(r=t.color)!=null?r:4294967295}}}n(ut,"z$__type__Props"),n(ut,"uniforms",{width:{value:0,method:"uniform1f",type:"float"},color:{value:4294967295,validator:t=>it(t),method:"uniform4fv",type:"vec4"}}),n(ut,"methods",{fillMask:"\n      float function(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n    ",rectDist:"\n      float function(vec2 p, vec2 size) {\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n      }\n    "}),n(ut,"onEffectMask","\n  vec2 pos = vec2(0.0, width * 0.5);\n  float mask = $rectDist(v_textureCoordinate.xy * u_dimensions - pos, vec2(u_dimensions.x, width*0.5));\n  return mix(shaderColor, maskColor, $fillMask(mask));\n  "),n(ut,"onColorize","\n    return color;\n  ");class pt extends B{constructor(){super(...arguments);n(this,"name","borderBottom")}static getEffectKey(){return"borderBottom"}static resolveDefaults(t){var e,r;return{width:(e=t.width)!=null?e:10,color:(r=t.color)!=null?r:4294967295}}}n(pt,"z$__type__Props"),n(pt,"uniforms",{width:{value:0,method:"uniform1f",type:"float"},color:{value:4294967295,validator:t=>it(t),method:"uniform4fv",type:"vec4"}}),n(pt,"methods",{fillMask:"\n      float function(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n    ",rectDist:"\n      float function(vec2 p, vec2 size) {\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n      }\n    "}),n(pt,"onEffectMask","\n  vec2 pos = vec2(0.0, u_dimensions.y - width * 0.5);\n  float mask = $rectDist(v_textureCoordinate.xy * u_dimensions - pos, vec2(u_dimensions.x, width*0.5));\n  return mix(shaderColor, maskColor, $fillMask(mask));\n  "),n(pt,"onColorize","\n    return color;\n  ");class mt extends B{constructor(){super(...arguments);n(this,"name","borderLeft")}static getEffectKey(){return"borderLeft"}static resolveDefaults(t){var e,r;return{width:(e=t.width)!=null?e:10,color:(r=t.color)!=null?r:4294967295}}}n(mt,"z$__type__Props"),n(mt,"uniforms",{width:{value:0,method:"uniform1f",type:"float"},color:{value:4294967295,validator:t=>it(t),method:"uniform4fv",type:"vec4"}}),n(mt,"methods",{fillMask:"\n      float function(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n    ",rectDist:"\n      float function(vec2 p, vec2 size) {\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n      }\n    "}),n(mt,"onEffectMask","\n  vec2 pos = vec2(width * 0.5, 0.0);\n  float mask = $rectDist(v_textureCoordinate.xy * u_dimensions - pos, vec2(width*0.5, u_dimensions.y));\n  return mix(shaderColor, maskColor, $fillMask(mask));\n  "),n(mt,"onColorize","\n    return color;\n  ");class vt extends B{constructor(){super(...arguments);n(this,"name","glitch")}static getEffectKey(t){return"glitch"}static resolveDefaults(t){var e,r,o,i,l;return{amplitude:(e=t.amplitude)!=null?e:.2,narrowness:(r=t.narrowness)!=null?r:4,blockiness:(o=t.blockiness)!=null?o:2,minimizer:(i=t.minimizer)!=null?i:8,time:(l=t.time)!=null?l:Date.now()}}}n(vt,"z$__type__Props"),n(vt,"uniforms",{amplitude:{value:0,method:"uniform1f",type:"float"},narrowness:{value:0,method:"uniform1f",type:"float"},blockiness:{value:0,method:"uniform1f",type:"float"},minimizer:{value:0,method:"uniform1f",type:"float"},time:{value:0,method:"uniform1f",validator:t=>(Date.now()-t)%1e3,type:"float"}}),n(vt,"methods",{rand:"\n      float function(vec2 p, float time) {\n        float t = floor(time * 20.) / 10.;\n        return fract(sin(dot(p, vec2(t * 12.9898, t * 78.233))) * 43758.5453);\n      }\n    ",noise:"\n      float function(vec2 uv, float blockiness, float time) {\n        vec2 lv = fract(uv);\n        vec2 id = floor(uv);\n\n        float n1 = rand(id, time);\n        float n2 = rand(id+vec2(1,0), time);\n        float n3 = rand(id+vec2(0,1), time);\n        float n4 = rand(id+vec2(1,1), time);\n        vec2 u = smoothstep(0.0, 1.0 + blockiness, lv);\n        return mix(mix(n1, n2, u.x), mix(n3, n4, u.x), u.y);\n      }\n    ",fbm:"\n      float function(vec2 uv, int count, float blockiness, float complexity, float time) {\n        float val = 0.0;\n        float amp = 0.5;\n        const int MAX_ITERATIONS = 10;\n\n        for(int i = 0; i < MAX_ITERATIONS; i++) {\n          if(i >= count) {break;}\n          val += amp * noise(uv, blockiness, time);\n          amp *= 0.5;\n          uv *= complexity;\n        }\n        return val;\n      }\n    "}),n(vt,"onColorize","\n    vec2 uv = v_textureCoordinate.xy;\n    float aspect = u_dimensions.x / u_dimensions.y;\n    vec2 a = vec2(uv.x * aspect , uv.y);\n    vec2 uv2 = vec2(a.x / u_dimensions.x, exp(a.y));\n\n    float shift = amplitude * pow($fbm(uv2, 4, blockiness, narrowness, time), minimizer);\n    float colR = texture2D(u_texture, vec2(uv.x + shift, uv.y)).r * (1. - shift);\n    float colG = texture2D(u_texture, vec2(uv.x - shift, uv.y)).g * (1. - shift);\n    float colB = texture2D(u_texture, vec2(uv.x - shift, uv.y)).b * (1. - shift);\n\n    vec3 f = vec3(colR, colG, colB);\n    return vec4(f, texture2D(u_texture, vec2(uv.x - shift, uv.y)).a);\n  ");class Ct extends B{constructor(){super(...arguments);n(this,"name","fadeOut")}static getEffectKey(){return"fadeOut"}static resolveDefaults(t){var e;return{fade:(e=t.fade)!=null?e:10}}}n(Ct,"z$__type__Props"),n(Ct,"uniforms",{fade:{value:0,method:"uniform4fv",type:"vec4",validator:t=>{let e=t;return Array.isArray(e)?e.length===2?e=[e[0],e[1],e[0],e[1]]:e.length===3?e=[e[0],e[1],e[2],e[0]]:e.length!==4&&(e=[e[0],e[0],e[0],e[0]]):typeof e=="number"&&(e=[e,e,e,e]),e}}}),n(Ct,"onColorize","\n  vec2 point = v_textureCoordinate.xy * u_dimensions.xy;\n  vec2 pos1;\n  vec2 pos2;\n  vec2 d;\n  float c;\n  vec4 result = maskColor;\n\n\n  if(fade[0] > 0.0) {\n    pos1 = vec2(point.x, point.y);\n    pos2 = vec2(point.x, point.y + fade[0]);\n    d = pos2 - pos1;\n    c = dot(pos1, d) / dot(d, d);\n    result = mix(vec4(0.0), result, smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0)));\n  }\n\n  if(fade[1] > 0.0) {\n    pos1 = vec2(point.x - u_dimensions.x - fade[1], v_textureCoordinate.y);\n    pos2 = vec2(point.x - u_dimensions.x, v_textureCoordinate.y);\n    d = pos1 - pos2;\n    c = dot(pos2, d) / dot(d, d);\n    result = mix(vec4(0.0), result, smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0)));\n  }\n\n  if(fade[2] > 0.0) {\n    pos1 = vec2(v_textureCoordinate.x, point.y - u_dimensions.y - fade[2]);\n    pos2 = vec2(v_textureCoordinate.x, point.y - u_dimensions.y);\n    d = pos1 - pos2;\n    c = dot(pos2, d) / dot(d, d);\n    result = mix(vec4(0.0), result, smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0)));\n  }\n\n  if(fade[3] > 0.0) {\n    pos1 = vec2(point.x, point.y);\n    pos2 = vec2(point.x + fade[3], point.y);\n    d = pos2 - pos1;\n    c = dot(pos1, d) / dot(d, d);\n    result = mix(vec4(0.0), result, smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0)));\n  }\n\n  return result;\n  ");class It extends B{constructor(){super(...arguments);n(this,"name","radialGradient")}static getEffectKey(t){return"radialGradient".concat(t.colors.length)}static resolveDefaults(t){var o,i,l,c,h;const e=(o=t.colors)!=null?o:[4278190080,4294967295];let r=t.stops;if(!r){r=[];const d=e.length-1;for(let m=0;m<e.length;m++)r.push(m*(1/d))}return{colors:e,stops:r,width:(i=t.width)!=null?i:0,height:(c=(l=t.height)!=null?l:t.width)!=null?c:0,pivot:(h=t.pivot)!=null?h:[.5,.5]}}}n(It,"z$__type__Props"),n(It,"uniforms",{width:{value:0,method:"uniform1f",type:"float"},height:{value:0,method:"uniform1f",type:"float"},pivot:{value:[.5,.5],method:"uniform2fv",type:"vec2"},colors:{value:4294967295,validator:t=>t.map(r=>it(r)).reduce((r,o)=>r.concat(o),[]),size:t=>t.colors.length,method:"uniform4fv",type:"vec4"},stops:{value:[],validator:(t,e)=>{var l;const r=(l=e.colors)!=null?l:[];let o=t;const i=t;if(o.length===0||o&&o.length!==r.length){for(let c=0;c<r.length;c++)o[c]?(i[c]=o[c],o[c-1]===void 0&&i[c-2]!==void 0&&(i[c-1]=i[c-2]+(o[c]-i[c-2])/2)):i[c]=c*(1/(r.length-1));o=i}return i},size:t=>t.colors.length,method:"uniform1fv",type:"float"}}),n(It,"onColorize",t=>{const e=t.colors.length||1;return"\n      vec2 point = v_textureCoordinate.xy * u_dimensions;\n      vec2 projection = vec2(pivot.x * u_dimensions.x, pivot.y * u_dimensions.y);\n\n      float dist = length((point - projection) / vec2(width, height));\n\n      float stopCalc = (dist - stops[0]) / (stops[1] - stops[0]);\n      vec4 colorOut = mix(colors[0], colors[1], stopCalc);\n      for(int i = 1; i < ".concat(e,"-1; i++) {\n        stopCalc = (dist - stops[i]) / (stops[i + 1] - stops[i]);\n        colorOut = mix(colorOut, colors[i + 1], clamp(stopCalc, 0.0, 1.0));\n      }\n      return mix(maskColor, colorOut, clamp(colorOut.a, 0.0, 1.0));\n    ")});const Ht={radius:ht,border:yt,borderBottom:pt,borderLeft:mt,borderRight:ft,borderTop:ut,fadeOut:Ct,linearGradient:dt,radialGradient:It,grayscale:qt,glitch:vt},ot=class ot extends Et{constructor(t,e,r){const o=ot.createShader(e,r);super({renderer:t,attributes:["a_position","a_textureCoordinate","a_color"],uniforms:[{name:"u_resolution",uniform:"uniform2fv"},{name:"u_pixelRatio",uniform:"uniform1f"},{name:"u_texture",uniform:"uniform2fv"},{name:"u_dimensions",uniform:"uniform2fv"},{name:"u_alpha",uniform:"uniform1f"},...o.uniforms],shaderSources:{vertex:o.vertex,fragment:o.fragment}});n(this,"effects",[]);this.effects=o.effects}bindTextures(t){const{gl:e}=this;e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,t[0].ctxTexture)}bindProps(t){var e;(e=t.effects)==null||e.forEach((r,o)=>{var d;const i=this.effects[o],l=Ht[i.name],c=(d=r.props)!=null?d:{},h=i.uniformInfo;Object.keys(c).forEach(m=>{const g=l.uniforms[m],u=h[m];let y=g.validator?g.validator(c[m],c):c[m];Array.isArray(y)&&(y=new Float32Array(y)),this.setUniform(u.name,y)})})}static createShader(t,e){const r={},o={};let i="";const l=[],c=[],h=t.effects.map(y=>{const p=e[y.type],x=p.getEffectKey(y.props||{});r[x]=r[x]?++r[x]:1;const f=r[x];f===1&&c.push({key:x,type:y.type,props:y.props});const b=new p({ref:"".concat(x).concat(f===1?"":f),target:x,props:y.props});return i+=b.declaredUniforms,l.push(...Object.values(b.uniformInfo)),b});let d="";c==null||c.forEach(y=>{var F;const p=e[y.type],x=p.resolveDefaults((F=y.props)!=null?F:{}),f=[];for(const v in p.methods){let C=v;const R=p.methods[v];o[v]&&o[v]!==R&&(C=ot.resolveMethodDuplicate(v,R,o)),o[C]=R.replace("function",C),f.push({m:v,cm:C})}let b=p.onShaderMask instanceof Function?p.onShaderMask(x):p.onShaderMask,S=p.onColorize instanceof Function?p.onColorize(x):p.onColorize,T=p.onEffectMask instanceof Function?p.onEffectMask(x):p.onEffectMask;f.forEach(v=>{const{m:C,cm:R}=v,D=new RegExp("\\$".concat(C),"g");b&&(b=b.replace(D,R)),S&&(S=S.replace(D,R)),T&&(T=T.replace(D,R))});const z=p.getMethodParameters(p.uniforms,x),P=z.length>0?", ".concat(z):"";b&&(d+="\n        float fx_".concat(y.key,"_onShaderMask(float shaderMask ").concat(P,") {\n          ").concat(b,"\n        }\n        ")),S&&(d+="\n          vec4 fx_".concat(y.key,"_onColorize(float shaderMask, vec4 maskColor, vec4 shaderColor").concat(P,") {\n            ").concat(S,"\n          }\n        ")),T&&(d+="\n          vec4 fx_".concat(y.key,"_onEffectMask(float shaderMask, vec4 maskColor, vec4 shaderColor").concat(P,") {\n            ").concat(T,"\n          }\n        "))});let m="";for(const y in o)m+=o[y];let g="mix(shaderColor, maskColor, clamp(-(lng_DefaultMask), 0.0, 1.0))",u="\n\n    ";for(let y=0;y<h.length;y++){const p=h[y],x=p.passParameters.length>0?", ".concat(p.passParameters):"",f=Ht[p.name];f.onShaderMask&&(u+="\n        shaderMask = fx_".concat(p.target,"_onShaderMask(shaderMask ").concat(x,");\n        ")),f.onColorize&&(u+="\n        maskColor = fx_".concat(p.target,"_onColorize(shaderMask, maskColor, shaderColor").concat(x,");\n        ")),f.onEffectMask&&(g="fx_".concat(p.target,"_onEffectMask(shaderMask, maskColor, shaderColor").concat(x,")"));const b=h[y+1];(b===void 0||Ht[b.name].onEffectMask)&&(u+="\n          shaderColor = ".concat(g,";\n        "))}return{effects:h,uniforms:l,fragment:ot.fragment(i,m,d,u),vertex:ot.vertex()}}static resolveMethodDuplicate(t,e,r,o=0){const i=t+(o>0?o:"");return r[i]&&r[i]!==e?this.resolveMethodDuplicate(t,e,r,++o):i}static resolveDefaults(t,e){var r;return{effects:((r=t.effects)!=null?r:[]).map(o=>({type:o.type,props:e[o.type].resolveDefaults(o.props||{})})),$dimensions:{width:0,height:0},$alpha:0}}static makeCacheKey(t,e){var o;let r="";return(o=t.effects)==null||o.forEach(i=>{const c=e[i.type].getEffectKey(i.props||{});r+=",".concat(c)}),"DynamicShader".concat(r)}};n(ot,"z$__type__Props"),n(ot,"vertex",()=>"\n    # ifdef GL_FRAGMENT_PRESICISON_HIGH\n    precision highp float;\n    # else\n    precision mediump float;\n    # endif\n\n    attribute vec2 a_textureCoordinate;\n    attribute vec2 a_position;\n    attribute vec4 a_color;\n    attribute float a_textureIndex;\n\n    uniform vec2 u_resolution;\n    uniform float u_pixelRatio;\n\n    varying vec4 v_color;\n    varying vec2 v_textureCoordinate;\n    varying float v_textureIndex;\n\n    void main(){\n      vec2 normalized = a_position * u_pixelRatio / u_resolution;\n      vec2 zero_two = normalized * 2.0;\n      vec2 clip_space = zero_two - 1.0;\n\n      // pass to fragment\n      v_color = a_color;\n      v_textureCoordinate = a_textureCoordinate;\n      v_textureIndex = a_textureIndex;\n\n      // flip y\n      gl_Position = vec4(clip_space * vec2(1.0, -1.0), 0, 1);\n    }\n  "),n(ot,"fragment",(t,e,r,o)=>"\n    # ifdef GL_FRAGMENT_PRESICISON_HIGH\n    precision highp float;\n    # else\n    precision mediump float;\n    # endif\n\n    #define PI 3.14159265359\n\n    uniform vec2 u_resolution;\n    uniform vec2 u_dimensions;\n    uniform float u_alpha;\n    uniform float u_radius;\n    uniform sampler2D u_texture;\n    uniform float u_pixelRatio;\n\n    ".concat(t,"\n\n    varying vec4 v_color;\n    varying vec2 v_textureCoordinate;\n\n    ").concat(e,"\n\n    ").concat(r,"\n\n    void main() {\n      vec2 p = v_textureCoordinate.xy * u_dimensions - u_dimensions * 0.5;\n      vec2 d = abs(p) - (u_dimensions) * 0.5;\n      float lng_DefaultMask = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n\n      vec4 shaderColor = vec4(0.0);\n      float shaderMask = lng_DefaultMask;\n\n      vec4 maskColor = texture2D(u_texture, v_textureCoordinate) * v_color;\n\n      shaderColor = mix(shaderColor, maskColor, clamp(-(lng_DefaultMask + 0.5), 0.0, 1.0));\n\n      ").concat(o,"\n\n      gl_FragColor = shaderColor * u_alpha;\n    }\n  "));let _t=ot;class Ut extends Et{constructor(s){super({renderer:s,attributes:["a_position","a_textureCoordinate","a_color"],uniforms:[{name:"u_resolution",uniform:"uniform2fv"},{name:"u_pixelRatio",uniform:"uniform1f"},{name:"u_texture",uniform:"uniform2f"},{name:"u_dimensions",uniform:"uniform2fv"},{name:"u_radius",uniform:"uniform1f"}]})}static resolveDefaults(s){return{radius:s.radius||10,$dimensions:{width:0,height:0}}}bindTextures(s){const{gl:t}=this;t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,s[0].ctxTexture)}bindProps(s){this.setUniform("u_radius",s.radius)}canBatchShaderProps(s,t){return s.radius===t.radius&&s.$dimensions.width===t.$dimensions.width&&s.$dimensions.height===t.$dimensions.height}}n(Ut,"z$__type__Props"),n(Ut,"shaderSources",{vertex:"\n      # ifdef GL_FRAGMENT_PRESICISON_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      attribute vec2 a_position;\n      attribute vec2 a_textureCoordinate;\n      attribute vec4 a_color;\n      attribute float a_textureIndex;\n      attribute float a_depth;\n\n      uniform vec2 u_resolution;\n      uniform float u_pixelRatio;\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoordinate;\n\n      void main() {\n        vec2 normalized = a_position * u_pixelRatio / u_resolution;\n        vec2 zero_two = normalized * 2.0;\n        vec2 clip_space = zero_two - 1.0;\n\n        // pass to fragment\n        v_color = a_color;\n        v_textureCoordinate = a_textureCoordinate;\n\n        // flip y\n        gl_Position = vec4(clip_space * vec2(1.0, -1.0), 0, 1);\n      }\n    ",fragment:"\n      # ifdef GL_FRAGMENT_PRESICISON_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      uniform vec2 u_resolution;\n      uniform vec2 u_dimensions;\n      uniform float u_radius;\n      uniform sampler2D u_texture;\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoordinate;\n\n      float boxDist(vec2 p, vec2 size, float radius){\n        size -= vec2(radius);\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n      }\n\n      float fillMask(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n\n      void main() {\n        vec4 color = texture2D(u_texture, v_textureCoordinate) * v_color;\n        vec2 halfDimensions = u_dimensions * 0.5;\n\n        float d = boxDist(v_textureCoordinate.xy * u_dimensions - halfDimensions, halfDimensions + 0.5, u_radius);\n        gl_FragColor = mix(vec4(0.0), color, fillMask(d));\n      }\n    "});const Ye=new Float32Array([1,0,0,0,1,0,0,0,1]),Yt=class Yt extends Et{constructor(s){super({renderer:s,attributes:["a_position","a_textureCoordinate"],uniforms:[{name:"u_resolution",uniform:"uniform2fv"},{name:"u_transform",uniform:"uniformMatrix3fv"},{name:"u_scrollY",uniform:"uniform1f"},{name:"u_pixelRatio",uniform:"uniform1f"},{name:"u_texture",uniform:"uniform2f"},{name:"u_color",uniform:"uniform4fv"},{name:"u_size",uniform:"uniform1f"},{name:"u_distanceRange",uniform:"uniform1f"},{name:"u_debug",uniform:"uniform1i"}]})}bindTextures(s){const{gl:t}=this;t.activeTexture(t.TEXTURE0),t.bindTexture(t.TEXTURE_2D,s[0].ctxTexture)}bindProps(s){const t=Yt.resolveDefaults(s);for(const e in t)if(e==="transform")this.setUniform("u_transform",!1,t[e]);else if(e==="scrollY")this.setUniform("u_scrollY",t[e]);else if(e==="color"){const r=it(t.color);this.setUniform("u_color",r)}else e==="size"?this.setUniform("u_size",t[e]):e==="distanceRange"?this.setUniform("u_distanceRange",t[e]):e==="debug"&&this.setUniform("u_debug",t[e]?1:0)}static resolveDefaults(s={}){var t,e,r,o,i,l;return{transform:(t=s.transform)!=null?t:Ye,scrollY:(e=s.scrollY)!=null?e:0,color:(r=s.color)!=null?r:4294967295,size:(o=s.size)!=null?o:16,distanceRange:(i=s.distanceRange)!=null?i:1,debug:(l=s.debug)!=null?l:!1}}};n(Yt,"shaderSources",{vertex:"\n      // an attribute is an input (in) to a vertex shader.\n      // It will receive data from a buffer\n      attribute vec2 a_position;\n      attribute vec2 a_textureCoordinate;\n\n      uniform vec2 u_resolution;\n      uniform mat3 u_transform;\n      uniform float u_scrollY;\n      uniform float u_pixelRatio;\n      uniform float u_size;\n\n      varying vec2 v_texcoord;\n\n      void main() {\n        vec2 scrolledPosition = a_position * u_size - vec2(0, u_scrollY);\n        vec2 transformedPosition = (u_transform * vec3(scrolledPosition, 1)).xy;\n        gl_Position = vec4((transformedPosition * u_pixelRatio / u_resolution * 2.0 - 1.0) * vec2(1, -1), 0, 1);\n        v_texcoord = a_textureCoordinate;\n      }\n    ",fragment:"\n      precision highp float;\n\n      uniform vec4 u_color;\n      uniform sampler2D u_texture;\n      uniform float u_distanceRange;\n      uniform float u_pixelRatio;\n      uniform int u_debug;\n\n      varying vec2 v_texcoord;\n\n      float median(float r, float g, float b) {\n          return max(min(r, g), min(max(r, g), b));\n      }\n\n      void main() {\n          vec3 sample = texture2D(u_texture, v_texcoord).rgb;\n          if (u_debug == 1) {\n            gl_FragColor = vec4(sample.r, sample.g, sample.b, 1.0);\n            return;\n          }\n          float scaledDistRange = u_distanceRange * u_pixelRatio;\n          float sigDist = scaledDistRange * (median(sample.r, sample.g, sample.b) - 0.5);\n          float opacity = clamp(sigDist + 0.5, 0.0, 1.0) * u_color.a;\n\n          // Build the final color.\n          // IMPORTANT: We must premultiply the color by the alpha value before returning it.\n          gl_FragColor = vec4(u_color.r * opacity, u_color.g * opacity, u_color.b * opacity, opacity);\n      }\n    "});let Nt=Yt;class We{constructor(){n(this,"shCache",new Map);n(this,"shConstructors",{});n(this,"attachedShader",null);n(this,"effectConstructors",{});n(this,"renderer");this.registerShaderType("DefaultShader",me),this.registerShaderType("DefaultShaderBatched",ge),this.registerShaderType("RoundedRectangle",Ut),this.registerShaderType("DynamicShader",_t),this.registerShaderType("SdfShader",Nt),this.registerEffectType("border",yt),this.registerEffectType("borderBottom",pt),this.registerEffectType("borderLeft",mt),this.registerEffectType("borderRight",ft),this.registerEffectType("borderTop",ut),this.registerEffectType("fadeOut",Ct),this.registerEffectType("linearGradient",dt),this.registerEffectType("radialGradient",It),this.registerEffectType("grayscale",qt),this.registerEffectType("glitch",vt),this.registerEffectType("radius",ht)}registerShaderType(s,t){this.shConstructors[s]=t}registerEffectType(s,t){this.effectConstructors[s]=t}loadShader(s,t){if(!this.renderer)throw new Error("Renderer is not been defined");const e=this.shConstructors[s];if(!e)throw new Error('Shader type "'.concat(s,'" is not registered'));if(s==="DynamicShader")return this.loadDynamicShader(t);const r=e.resolveDefaults(t),o=e.makeCacheKey(r)||e.name;if(o&&this.shCache.has(o))return{shader:this.shCache.get(o),props:r};const i=new e(this.renderer,t);return o&&this.shCache.set(o,i),{shader:i,props:r}}loadDynamicShader(s){if(!this.renderer)throw new Error("Renderer is not been defined");const t=_t.resolveDefaults(s,this.effectConstructors),e=_t.makeCacheKey(t,this.effectConstructors);if(e&&this.shCache.has(e))return{shader:this.shCache.get(e),props:t};const r=new _t(this.renderer,s,this.effectConstructors);return e&&this.shCache.set(e,r),{shader:r,props:t}}useShader(s){this.attachedShader!==s&&(this.attachedShader&&this.attachedShader.detach(),s.attach(),this.attachedShader=s)}}class Be{constructor(){n(this,"activeAnimations",new Set)}registerAnimation(s){this.activeAnimations.add(s)}unregisterAnimation(s){this.activeAnimations.delete(s)}update(s){this.activeAnimations.forEach(t=>{t.update(s)})}}const Rt=class Rt extends de{constructor(t,e){super(t);n(this,"props");this.props=Rt.resolveDefaults(e)}async getTextureData(){const{src:t,premultiplyAlpha:e}=this.props;if(!t)return{data:null};if(t instanceof ImageData)return{data:t,premultiplyAlpha:e};const o=await(await fetch(t)).blob();return{data:await createImageBitmap(o,{premultiplyAlpha:e?"premultiply":"none",colorSpaceConversion:"none",imageOrientation:"none"})}}static makeCacheKey(t){const e=Rt.resolveDefaults(t);return e.src instanceof ImageData?!1:"ImageTexture,".concat(e.src,",").concat(e.premultiplyAlpha)}static resolveDefaults(t){var e,r;return{src:(e=t.src)!=null?e:"",premultiplyAlpha:(r=t.premultiplyAlpha)!=null?r:!0}}};n(Rt,"z$__type__Props");let Gt=Rt;const kt=class kt extends de{constructor(t,e){super(t);n(this,"props");this.props=kt.resolveDefaults(e)}async getTextureData(){const{width:t,height:e}=this.props,r=t*e*4,o=new Uint8ClampedArray(r);for(let i=0;i<r;i+=4){const l=Math.floor(Math.random()*256);o[i]=l,o[i+1]=l,o[i+2]=l,o[i+3]=255}return{data:new ImageData(o,t,e)}}static makeCacheKey(t){const e=kt.resolveDefaults(t);return"NoiseTexture,".concat(e.width,",").concat(e.height,",").concat(e.cacheId)}static resolveDefaults(t){var e,r,o;return{width:(e=t.width)!=null?e:128,height:(r=t.height)!=null?r:128,cacheId:(o=t.cacheId)!=null?o:0}}};n(kt,"z$__type__Props");let Kt=kt;class He{constructor(){n(this,"usedMemory",0);n(this,"txConstructors",{});n(this,"textureKeyCache",new Map);n(this,"textureIdCache",new Map);n(this,"ctxTextureCache",new WeakMap);n(this,"textureRefCountMap",new WeakMap);n(this,"renderer");this.registerTextureType("ImageTexture",Gt),this.registerTextureType("ColorTexture",ke),this.registerTextureType("NoiseTexture",Kt),this.registerTextureType("SubTexture",Me)}registerTextureType(s,t){this.txConstructors[s]=t}loadTexture(s,t,e=null){var i;const r=this.txConstructors[s];if(!r)throw new Error('Texture type "'.concat(s,'" is not registered'));let o;if((e==null?void 0:e.id)!==void 0&&this.textureIdCache.has(e.id)&&(o=this.textureIdCache.get(e.id)),!o){const l=e==null?void 0:e.id,c=(i=e==null?void 0:e.cacheKey)!=null?i:r.makeCacheKey(t);c&&this.textureKeyCache.has(c)?o=this.textureKeyCache.get(c):o=new r(this,t),l&&this.addTextureIdToCache(l,c,o)}return e!=null&&e.preload&&this.getCtxTexture(o).load(),o}addTextureIdToCache(s,t,e){const{textureIdCache:r,textureRefCountMap:o}=this;r.set(s,e),o.has(e)?o.get(e).count++:(o.set(e,{cacheKey:t,count:1}),t&&this.textureKeyCache.set(t,e))}removeTextureIdFromCache(s){const{textureIdCache:t,textureRefCountMap:e}=this,r=t.get(s);if(r&&(t.delete(s),e.has(r))){const o=e.get(r);M(o),o.count--,o.count===0&&(e.delete(r),o.cacheKey&&this.textureKeyCache.delete(o.cacheKey))}}getDebugInfo(){return{keyCacheSize:this.textureKeyCache.size,idCacheSize:this.textureIdCache.size}}getCtxTexture(s){if(this.ctxTextureCache.has(s))return this.ctxTextureCache.get(s);const t=this.renderer.createCtxTexture(s);return this.ctxTextureCache.set(s,t),t}}class xe{constructor(s){n(this,"textRenderers");this.textRenderers=s}addFontFace(s){for(const t in this.textRenderers){const e=this.textRenderers[t];e&&e.isFontFaceSupported(s)&&e.addFontFace(s)}}static resolveFontFace(s,t){const e=[];return s.reduce((o,i)=>{if(o)return o;const l=i[t.fontFamily];if(!l)return;const c=new Set(l);for(const h of c)(h.descriptors.stretch!==t.fontStretch||h.descriptors.style!==t.fontStyle||h.descriptors.weight!==t.fontWeight)&&c.delete(h);return c.values().next().value},void 0)||e[0]}}const Ue={x:(a,s)=>{a.props.x=s},y:(a,s)=>{a.props.y=s},width:(a,s)=>{a.props.width=s},height:(a,s)=>{a.props.height=s},color:(a,s)=>{a.props.color=s},zIndex:(a,s)=>{a.props.zIndex=s},fontFamily:(a,s)=>{a.props.fontFamily=s},fontWeight:(a,s)=>{a.props.fontWeight=s},fontStyle:(a,s)=>{a.props.fontStyle=s},fontStretch:(a,s)=>{a.props.fontStretch=s},fontSize:(a,s)=>{a.props.fontSize=s},scaleX:(a,s)=>{a.props.scaleX=s},scaleY:(a,s)=>{a.props.scaleY=s},text:(a,s)=>{a.props.text=s},textAlign:(a,s)=>{a.props.textAlign=s},contain:(a,s)=>{a.props.contain=s},offsetY:(a,s)=>{a.props.offsetY=s},scrollable:(a,s)=>{a.props.scrollable=s},scrollY:(a,s)=>{a.props.scrollY=s},letterSpacing:(a,s)=>{a.props.letterSpacing=s},debug:(a,s)=>{a.props.debug=s}};class ye{constructor(s){n(this,"stage");n(this,"set");this.stage=s,this.set=Object.freeze({...Ue,...this.getPropertySetters()})}setStatus(s,t,e){s.status!==t&&(s.status=t,s.emitter.emit(t,e))}}const Ne=24;function Ge(a,s,t,e,r,o,i){let l=0;r&&(l=Math.min(Math.max(Math.floor(r.y1/a),0),o.length));const c=0,h=s/t+l*e;if(!(i&&h>=i/t))return{x:c,y:h,lineIndex:l}}class Lt{constructor(s,t=0){n(this,"iterator");n(this,"peekBuffer",[]);n(this,"_lastIndex");this.iterator=s,this.iterator=s,this._lastIndex=t-1,this.peekBuffer=[]}next(){const s=this.peekBuffer.length>0?this.peekBuffer.pop():this.iterator.next();return s.done?this._lastIndex=-1:this._lastIndex++,s}peek(){if(this.peekBuffer.length>0)return this.peekBuffer[0];const s=this.iterator.next();return this.peekBuffer.push(s),s}get lastIndex(){return this._lastIndex}}function*Xt(a,s=0){let t=s;for(;t<a.length;){const e=a.codePointAt(t);if(e===void 0)throw new Error("Invalid Unicode code point");yield e,t+=e<=65535?1:2}}function Ke(a,s,t){const e=t.shapeText(s,new Lt(Xt(a,0),0));let r=0;for(const o of e)o.mapped&&(r+=o.xAdvance);return r}function Ve(a,s,t,e,r,o,i,l,c,h,d,m,g,u,y,p){M(u,"Font face must be loaded"),M(u.loaded,"Font face must be loaded"),M(u.data,"Font face must be loaded"),M(u.shaper,"Font face must be loaded");const x=u.data.info.size,f=l/x,b=o/f,S=c/f,T=m[a],z=(T==null?void 0:T.codepointIndex)||0,P=(T==null?void 0:T.maxX)||0,F=(T==null?void 0:T.maxY)||0;let v=P,C=F,R=s,D=t,w=0;const I={codepointIndex:-1,bufferOffset:-1,xStart:-1},O=u.shaper,Y={letterSpacing:S};let st=O.shapeText(Y,new Lt(Xt(e,z),z)),V,nt=-1;const Tt=[],Jt="...",Te=i/f,be=Ke(Jt,Y,O);let Ot=!0;for(;Ot;){const lt=d!=="both"||p||D+x+x<=Te,rt=lt?b:b-be;let H=0;for(;(V=st.next())&&!V.done;){const A=V.value;if(a===m.length)m.push({codepointIndex:A.cluster,maxY:C,maxX:v});else if(a>m.length)throw new Error("Unexpected lineCache length");if(A.codepoint===32||A.codepoint===10?I.codepointIndex!==-1&&(I.codepointIndex=-1,H=R):I.codepointIndex===-1&&(I.codepointIndex=A.cluster,I.bufferOffset=w,I.xStart=H),A.mapped){const bt=R+A.xOffset+A.width;if(d!=="none"&&bt>=rt&&I.codepointIndex!==-1&&I.codepointIndex<A.cluster&&I.xStart>0)if(lt){st=O.shapeText(Y,new Lt(Xt(e,I.codepointIndex),I.codepointIndex)),w=I.bufferOffset;break}else st=O.shapeText(Y,new Lt(Xt(Jt,0),0)),R=I.xStart,w=I.bufferOffset;else{const Q=R+A.xOffset,wt=D+A.yOffset,we=g?D+x>=g.y1/f:!0,Se=g?D<=g.y2/f:!0;if(we&&Se){nt===-1&&(nt=w);const zt=u.getAtlasEntry(A.glyphId),Ft=zt.x/u.data.common.scaleW,Dt=zt.y/u.data.common.scaleH,te=zt.width/u.data.common.scaleW,ee=zt.height/u.data.common.scaleH;h[w++]=Q,h[w++]=wt,h[w++]=Ft,h[w++]=Dt,h[w++]=Q+A.width,h[w++]=wt,h[w++]=Ft+te,h[w++]=Dt,h[w++]=Q,h[w++]=wt+A.height,h[w++]=Ft,h[w++]=Dt+ee,h[w++]=Q+A.width,h[w++]=wt+A.height,h[w++]=Ft+te,h[w++]=Dt+ee}C=Math.max(C,wt+A.height),R+=A.xAdvance,v=Math.max(v,R)}}else if(A.codepoint===10)break}nt!==-1&&(Tt.push({bufferStart:nt,bufferEnd:w}),nt=-1),R=0,D+=x,a++,I.codepointIndex=-1,H=0,(!y&&d==="both"&&g&&D>g.y2/f||V&&V.done||d==="both"&&!p&&!lt)&&(Ot=!1)}if(r==="center"){const lt=d==="none"?v:b;for(let rt=0;rt<Tt.length;rt++){const H=Tt[rt],A=h[H.bufferEnd-4]-h[H.bufferStart],bt=(lt-A)/2;for(let Q=H.bufferStart;Q<H.bufferEnd;Q+=4)h[Q]+=bt}}else if(r==="right"){const lt=d==="none"?v:b;for(let rt=0;rt<Tt.length;rt++){const H=Tt[rt],A=H.bufferEnd===H.bufferStart?0:h[H.bufferEnd-4]-h[H.bufferStart],bt=lt-A;for(let Q=H.bufferStart;Q<H.bufferEnd;Q+=4)h[Q]+=bt}}return M(V),{bufferNumFloats:w,bufferNumQuads:w/16,layoutNumCharacters:V.done?e.length-z:V.value.cluster-z+1,fullyProcessed:!!V.done,maxX:v,maxY:C}}function Qe(a,s,t,e,r,o){const i=e*r,l=o.x1-a,c=o.y1-s;return Ee(o)?{x1:l,y1:c+t-i,x2:l+(o.x2-o.x1),y2:c+t+(o.y2-o.y1)+i}:{x1:0,y1:0,x2:0,y2:0}}class qe extends ye{constructor(t){super(t);n(this,"ssdfFontFamilies",{});n(this,"msdfFontFamilies",{});n(this,"sdfShader");this.sdfShader=this.stage.shManager.loadShader("SdfShader").shader}getPropertySetters(){return{fontFamily:(t,e)=>{t.props.fontFamily=e,t.trFontFace=void 0,this.invalidateCache(t)},fontWeight:(t,e)=>{t.props.fontWeight=e,t.trFontFace=void 0,this.invalidateCache(t)},fontStyle:(t,e)=>{t.props.fontStyle=e,t.trFontFace=void 0,this.invalidateCache(t)},fontStretch:(t,e)=>{t.props.fontStretch=e,t.trFontFace=void 0,this.invalidateCache(t)},fontSize:(t,e)=>{t.props.fontSize=e,this.invalidateCache(t)},text:(t,e)=>{t.props.text=e,this.invalidateCache(t)},textAlign:(t,e)=>{t.props.textAlign=e,this.invalidateCache(t)},color:(t,e)=>{t.props.color=e},x:(t,e)=>{t.props.x=e},y:(t,e)=>{t.props.y=e},contain:(t,e)=>{t.props.contain=e,this.invalidateCache(t)},width:(t,e)=>{t.props.width=e,this.invalidateCache(t)},height:(t,e)=>{t.props.height=e,this.invalidateCache(t)},offsetY:(t,e)=>{t.props.offsetY=e,this.invalidateCache(t)},scrollable:(t,e)=>{t.props.scrollable=e,this.invalidateCache(t)},scrollY:(t,e)=>{t.props.scrollY=e},letterSpacing:(t,e)=>{t.props.letterSpacing=e,this.invalidateCache(t)},debug:(t,e)=>{t.props.debug=e}}}canRenderFont(t){const{fontFamily:e}=t;return e in this.ssdfFontFamilies||e in this.msdfFontFamilies||e==="$$SDF_FAILURE_TEST$$"}isFontFaceSupported(t){return t instanceof re}addFontFace(t){M(t instanceof re);const e=t.fontFamily,r=t.type==="ssdf"?this.ssdfFontFamilies:t.type==="msdf"?this.msdfFontFamilies:void 0;if(!r){console.warn("Invalid font face type: ".concat(t.type));return}let o=r[e];o||(o=new Set,r[e]=o),o.add(t)}createState(t){return{props:t,status:"initialState",emitter:new Wt,lineCache:[],forceFullLayoutCalc:!1,renderWindow:void 0,bufferNumFloats:0,bufferNumQuads:0,vertexBuffer:void 0,webGlBuffers:null,bufferUploaded:!1,textH:void 0,textW:void 0,distanceRange:0,trFontFace:void 0,debugData:{updateCount:0,layoutCount:0,lastLayoutNumCharacters:0,layoutSum:0,drawSum:0,drawCount:0,bufferSize:0}}}updateState(t){performance.now();let{trFontFace:e}=t;const{textH:r,lineCache:o,debugData:i,forceFullLayoutCalc:l}=t;if(i.updateCount++,t.status==="initialState"&&this.setStatus(t,"loading"),!e&&(e=this.resolveFontFace(t.props),t.trFontFace=e,!e)){const O="SdfTextRenderer: Could not resolve font face for family: '".concat(t.props.fontFamily,"'");console.error(O),this.setStatus(t,"failed",new Error(O));return}if(!e.loaded){e.on("loaded",function O(){t.emitter.emit("fontLoaded",{}),e==null||e.off("fontLoaded",O)});return}M(e.data,"Font face data should be loaded");const{text:c,fontSize:h,x:d,y:m,contain:g,width:u,height:y,scrollable:p}=t.props,x=g==="both"&&p?t.props.scrollY:0;let{renderWindow:f}=t;const b=e.data.info.size,S=h/b;t.distanceRange=S*e.data.distanceField.distanceRange;const T=c.length*Ne;let z=t.vertexBuffer;(!z||z.length<T)&&(z=new Float32Array(T*2));const P={x1:0,y1:0,x2:this.stage.options.appWidth,y2:this.stage.options.appHeight},F={x1:d,y1:m,x2:g!=="none"?d+u:1/0,y2:g==="both"?m+y:1/0},v=fe(P,F);if(!l&&f){if(d+f.x1<=v.x1&&d+f.x2>=v.x2&&m-x+f.y1<=v.y1&&m-x+f.y2>=v.y2)return;t.renderWindow=f=void 0}const{offsetY:C,textAlign:R}=t.props;if(!f){const O=v.y2-v.y1,Y=Math.ceil(O/b);f=Qe(d,m,x,b,Y,v)}const D=Ge(h,C,S,b,f,o,r);if(!D){this.setStatus(t,"loaded");return}const{letterSpacing:w}=t.props,I=Ve(D.lineIndex,D.x,D.y,c,R,u,y,h,w,z,g,o,f,e,l,p);t.bufferUploaded=!1,t.bufferNumFloats=I.bufferNumFloats,t.bufferNumQuads=I.bufferNumQuads,t.vertexBuffer=z,t.renderWindow=f,i.lastLayoutNumCharacters=I.layoutNumCharacters,i.bufferSize=z.byteLength,I.fullyProcessed&&(t.textW=I.maxX*S,t.textH=I.maxY*S),this.setStatus(t,"loaded")}renderQuads(t,e,r,o){var D,w,I;if(!t.vertexBuffer)return;performance.now();const{renderer:i}=this.stage;this.stage.options;const{fontSize:l,color:c,contain:h,scrollable:d,zIndex:m,debug:g}=t.props,u=h==="both"&&d?t.props.scrollY:0,{textW:y=0,textH:p=0,distanceRange:x,vertexBuffer:f,bufferNumFloats:b,bufferUploaded:S,renderWindow:T,debugData:z,trFontFace:P}=t;let{webGlBuffers:F}=t;if(!F){const O=i.gl,Y=4*Float32Array.BYTES_PER_ELEMENT,st=O.createBuffer();M(st),t.webGlBuffers=new Oe([{buffer:st,attributes:{a_position:{name:"a_position",size:2,type:O.FLOAT,normalized:!1,stride:Y,offset:0},a_textureCoordinate:{name:"a_textureCoordinate",size:2,type:O.FLOAT,normalized:!1,stride:Y,offset:2*Float32Array.BYTES_PER_ELEMENT}}}]),t.bufferUploaded=!1,M(t.webGlBuffers),F=t.webGlBuffers}if(!S){const O=i.gl,Y=(D=F==null?void 0:F.getBuffer("a_textureCoordinate"))!=null?D:null;O.bindBuffer(O.ARRAY_BUFFER,Y),O.bufferData(O.ARRAY_BUFFER,f,O.STATIC_DRAW),t.bufferUploaded=!0}M(P);const v=new ze(i.gl,i.options,F,this.sdfShader,{transform:e.data,color:Fe(c,o),size:l/(((w=P.data)==null?void 0:w.info.size)||0),scrollY:u,distanceRange:x,debug:g.sdfShaderDebug},o,r,{height:p,width:y},0,m),C=(I=t.trFontFace)==null?void 0:I.texture;M(C);const R=this.stage.txManager.getCtxTexture(C);v.addTexture(R),v.length=t.bufferNumFloats,v.numQuads=t.bufferNumQuads,i.addRenderable(v)}resolveFontFace(t){return xe.resolveFontFace([this.msdfFontFamilies,this.ssdfFontFamilies],t)}invalidateCache(t){t.renderWindow=void 0,t.textH=void 0,t.textW=void 0,t.lineCache=[],this.setStatus(t,"loading")}}const ie=2048;class Ze{constructor(s,t){n(this,"_canvas");n(this,"_context");n(this,"_settings");n(this,"renderInfo");this._canvas=s,this._context=t,this._settings=this.mergeDefaults({})}set settings(s){this._settings=this.mergeDefaults(s)}get settings(){return this._settings}getPrecision(){return this._settings.precision}setFontProperties(){this._context.font=this._getFontSetting(),this._context.textBaseline=this._settings.textBaseline}_getFontSetting(){const s=[this._settings.fontFace],t=[];for(let e=0,r=s.length;e<r;e++)s[e]==="serif"||s[e]==="sans-serif"?t.push(s[e]):t.push('"'.concat(s[e],'"'));return"".concat(this._settings.fontStyle," ").concat(this._settings.fontSize*this.getPrecision(),"px ").concat(t.join(","))}_load(){if(document.fonts){const s=this._getFontSetting();try{if(!document.fonts.check(s,this._settings.text))return document.fonts.load(s,this._settings.text).catch(t=>{console.warn("[Lightning] Font load error",t,s)}).then(()=>{document.fonts.check(s,this._settings.text)||console.warn("[Lightning] Font not found",s)})}catch(t){console.warn("[Lightning] Can't check font loading for "+s)}}}calculateRenderInfo(){const s={},t=this.getPrecision(),e=this._settings.paddingLeft*t,r=this._settings.paddingRight*t,o=this._settings.fontSize*t;let i=this._settings.offsetY===null?null:this._settings.offsetY*t,l=(this._settings.lineHeight||o)*t;const c=this._settings.w*t,h=this._settings.h*t;let d=this._settings.wordWrapWidth*t;const m=this._settings.cutSx*t,g=this._settings.cutEx*t,u=this._settings.cutSy*t,y=this._settings.cutEy*t,p=(this._settings.letterSpacing||0)*t,x=this._settings.textIndent*t;this.setFontProperties();let f=c||2048/this.getPrecision(),b=f-e;if(b<10&&(f+=10-b,b=10),d||(d=b),this._settings.textOverflow&&!this._settings.wordWrap){let v;switch(this._settings.textOverflow){case"clip":v="";break;case"ellipsis":v=this._settings.maxLinesSuffix;break;default:v=this._settings.textOverflow}this._settings.text=this.wrapWord(this._settings.text,d-x,v)}let S;if(this._settings.wordWrap)S=this.wrapText(this._settings.text,d,p,x);else{S={l:this._settings.text.split(/(?:\r\n|\r|\n)/),n:[]};const v=S.l.length;for(let C=0;C<v-1;C++)S.n.push(C)}let T=S.l;if(this._settings.maxLines&&T.length>this._settings.maxLines){const v=T.slice(0,this._settings.maxLines);let C=null;if(this._settings.maxLinesSuffix){const O=this._settings.maxLinesSuffix?this.measureText(this._settings.maxLinesSuffix):0,Y=this.wrapText(v[v.length-1],d-O,p,x);v[v.length-1]="".concat(Y.l[0]).concat(this._settings.maxLinesSuffix),C=[Y.l.length>1?Y.l[1]:""]}else C=[""];let R;const D=T.length;let w=0;const I=S.n.length;for(R=this._settings.maxLines;R<D;R++)C[w]+="".concat(C[w]?" ":"").concat(T[R]),R+1<I&&S.n[R+1]&&w++;s.remainingText=C.join("\n"),s.moreTextLines=!0,T=v}else s.moreTextLines=!1,s.remainingText="";let z=0;const P=[];for(let v=0;v<T.length;v++){const C=this.measureText(T[v],p)+(v===0?x:0);P.push(C),z=Math.max(z,C)}s.lineWidths=P,c||(f=z+e+r,b=z),l=l||o;let F;if(h)F=h;else{const v=this._settings.textBaseline!="bottom"?.5*o:0;F=l*(T.length-1)+v+Math.max(l,o)+(i||0)}return i===null&&(i=o),s.w=f,s.h=F,s.lines=T,s.precision=t,f||(f=1),F||(F=1),(m||g)&&(f=Math.min(f,g-m)),(u||y)&&(F=Math.min(F,y-u)),s.width=f,s.innerWidth=b,s.height=F,s.fontSize=o,s.cutSx=m,s.cutSy=u,s.cutEx=g,s.cutEy=y,s.lineHeight=l,s.lineWidths=P,s.offsetY=i,s.paddingLeft=e,s.paddingRight=r,s.letterSpacing=p,s.textIndent=x,s}draw(s,t){const e=this.getPrecision(),r=(t==null?void 0:t.lines)||s.lines,o=(t==null?void 0:t.lineWidths)||s.lineWidths,i=t?t.lines.length*s.lineHeight:s.height;this._canvas.width=Math.min(Math.ceil(s.width+this._settings.textRenderIssueMargin),ie),this._canvas.height=Math.min(Math.ceil(i),ie),this.setFontProperties(),s.fontSize>=128&&(this._context.globalAlpha=.01,this._context.fillRect(0,0,.01,.01),this._context.globalAlpha=1),(s.cutSx||s.cutSy)&&this._context.translate(-s.cutSx,-s.cutSy);let l,c;const h=[];for(let m=0,g=r.length;m<g;m++)l=m===0?s.textIndent:0,c=m*s.lineHeight+s.offsetY,this._settings.verticalAlign=="middle"?c+=(s.lineHeight-s.fontSize)/2:this._settings.verticalAlign=="bottom"&&(c+=s.lineHeight-s.fontSize),this._settings.textAlign==="right"?l+=s.innerWidth-o[m]:this._settings.textAlign==="center"&&(l+=(s.innerWidth-o[m])/2),l+=s.paddingLeft,h.push({text:r[m],x:l,y:c,w:o[m]});if(this._settings.highlight){const m=this._settings.highlightColor,g=this._settings.highlightHeight*e||s.fontSize*1.5,u=this._settings.highlightOffset*e,y=this._settings.highlightPaddingLeft!==null?this._settings.highlightPaddingLeft*e:s.paddingLeft,p=this._settings.highlightPaddingRight!==null?this._settings.highlightPaddingRight*e:s.paddingRight;this._context.fillStyle=Bt(m);for(let x=0;x<h.length;x++){const f=h[x];this._context.fillRect(f.x-y,f.y-s.offsetY+u,f.w+p+y,g)}}let d=null;this._settings.shadow&&(d=[this._context.shadowColor,this._context.shadowOffsetX,this._context.shadowOffsetY,this._context.shadowBlur],this._context.shadowColor=Bt(this._settings.shadowColor),this._context.shadowOffsetX=this._settings.shadowOffsetX*e,this._context.shadowOffsetY=this._settings.shadowOffsetY*e,this._context.shadowBlur=this._settings.shadowBlur*e),this._context.fillStyle=Bt(this._settings.textColor);for(let m=0,g=h.length;m<g;m++){const u=h[m];if(s.letterSpacing===0)this._context.fillText(u.text,u.x,u.y);else{const y=u.text.split("");let p=u.x;for(let x=0,f=y.length;x<f;x++)this._context.fillText(y[x],p,u.y),p+=this.measureText(y[x],s.letterSpacing)}}d&&(this._context.shadowColor=d[0],this._context.shadowOffsetX=d[1],this._context.shadowOffsetY=d[2],this._context.shadowBlur=d[3]),(s.cutSx||s.cutSy)&&this._context.translate(s.cutSx,s.cutSy),this.renderInfo=s}wrapWord(s,t,e){const r=this._context.measureText(e).width,o=s.length,i=this._context.measureText(s).width;if(i<=t)return s;let l=Math.floor(t*o/i),c=this._context.measureText(s.substring(0,l)).width+r;if(c>t)for(;l>0&&(c=this._context.measureText(s.substring(0,l)).width+r,c>t);)l-=1;else for(;l<o;)if(c=this._context.measureText(s.substring(0,l)).width+r,c<t)l+=1;else{l-=1;break}return s.substring(0,l)+(t>=r?e:"")}wrapText(s,t,e,r=0){const o=s.split(/\r?\n/g);let i=[];const l=[];for(let c=0;c<o.length;c++){const h=[];let d="",m=t-r;const g=o[c].split(" ");for(let u=0;u<g.length;u++){const y=this.measureText(g[u],e),p=y+this.measureText(" ",e);u===0||p>m?(u>0&&(h.push(d),d=""),d+=g[u],m=t-y-(u===0?r:0)):(m-=p,d+=" ".concat(g[u]))}h.push(d),d="",i=i.concat(h),c<o.length-1&&l.push(i.length)}return{l:i,n:l}}measureText(s,t=0){return t?s.split("").reduce((e,r)=>e+this._context.measureText(r).width+t,0):this._context.measureText(s).width}mergeDefaults(s){return{text:"",w:0,h:0,fontStyle:"normal",fontSize:40,fontFace:null,wordWrap:!0,wordWrapWidth:0,wordBreak:!1,textOverflow:"",lineHeight:null,textBaseline:"alphabetic",textAlign:"left",verticalAlign:"top",offsetY:null,maxLines:0,maxLinesSuffix:"..",textColor:[1,1,1,1],paddingLeft:0,paddingRight:0,shadow:!1,shadowColor:[0,0,0,1],shadowOffsetX:0,shadowOffsetY:0,shadowBlur:5,highlight:!1,highlightHeight:0,highlightColor:[0,0,0,1],highlightOffset:0,highlightPaddingLeft:0,highlightPaddingRight:0,letterSpacing:0,textIndent:0,cutSx:0,cutEx:0,cutSy:0,cutEy:0,advancedRenderer:!1,fontBaselineRatio:0,precision:1,textRenderIssueMargin:0,...s}}}const ne=typeof self>"u"?globalThis:self;var he;const ae=((he=ne.document)==null?void 0:he.fonts)||ne.fonts;function Je(a){const{fontFamily:s,fontStyle:t,fontWeight:e,fontStretch:r,fontSize:o}=a;return[t,e,r,"".concat(o,"px"),s].join(" ")}class ts extends ye{constructor(t){super(t);n(this,"canvas");n(this,"context");typeof OffscreenCanvas<"u"?this.canvas=new OffscreenCanvas(0,0):this.canvas=document.createElement("canvas");let e=this.canvas.getContext("2d");e||(this.canvas=document.createElement("canvas"),e=this.canvas.getContext("2d")),M(e),this.context=e}getPropertySetters(){return{fontFamily:(t,e)=>{t.props.fontFamily=e,t.fontInfo=void 0,this.markForReload(t)},fontWeight:(t,e)=>{t.props.fontWeight=e,t.fontInfo=void 0,this.markForReload(t)},fontStyle:(t,e)=>{t.props.fontStyle=e,t.fontInfo=void 0,this.markForReload(t)},fontStretch:(t,e)=>{t.props.fontStretch=e,t.fontInfo=void 0,this.markForReload(t)},fontSize:(t,e)=>{t.props.fontSize=e,t.fontInfo=void 0,this.markForReload(t)},text:(t,e)=>{t.props.text=e,this.markForReload(t)},textAlign:(t,e)=>{t.props.textAlign=e,this.markForReload(t)},color:(t,e)=>{t.props.color=e,this.markForReload(t)},x:(t,e)=>{t.props.x=e},y:(t,e)=>{t.props.y=e},contain:(t,e)=>{t.props.contain=e,this.markForReload(t)},width:(t,e)=>{t.props.width=e,this.markForReload(t)},height:(t,e)=>{t.props.height=e,this.markForReload(t)},offsetY:(t,e)=>{t.props.offsetY=e,this.markForReload(t)},scrollY:(t,e)=>{t.props.scrollY=e},letterSpacing:(t,e)=>{t.props.letterSpacing=e,this.markForReload(t)}}}canRenderFont(t){return!0}isFontFaceSupported(t){return t instanceof oe}addFontFace(t){M(t instanceof oe),ae.add(t.fontFace)}createState(t){return{props:t,status:"initialState",emitter:new Wt,canvasPages:void 0,lightning2TextRenderer:new Ze(this.canvas,this.context),renderWindow:void 0,renderInfo:void 0,forceFullLayoutCalc:!1,textW:0,textH:0,fontInfo:void 0,fontFaceLoadedHandler:void 0,debugData:{updateCount:0,layoutCount:0,drawCount:0,lastLayoutNumCharacters:0,layoutSum:0,drawSum:0,bufferSize:0}}}updateState(t){if(t.status==="initialState"&&this.setStatus(t,"loading"),!t.fontInfo){const f=Je(t.props);if(t.fontInfo={cssString:f,loaded:!1},!t.fontInfo.loaded){ae.load(f).then(this.onFontLoaded.bind(this,t,f)).catch(this.onFontLoadError.bind(this,t,f));return}}if(!t.fontInfo.loaded)return;if(!t.renderInfo){t.lightning2TextRenderer.settings={text:t.props.text,textAlign:t.props.textAlign,fontFace:t.props.fontFamily,fontSize:t.props.fontSize,fontStyle:[t.props.fontStretch,t.props.fontStyle,t.props.fontWeight].join(" "),textColor:it(t.props.color),offsetY:t.props.fontSize+t.props.offsetY,wordWrap:t.props.contain!=="none",wordWrapWidth:t.props.contain==="none"?void 0:t.props.width,letterSpacing:t.props.letterSpacing};const f=performance.now();t.renderInfo=t.lightning2TextRenderer.calculateRenderInfo(),console.log("Render info calculated in",performance.now()-f,"ms"),t.textH=t.renderInfo.lineHeight*t.renderInfo.lines.length,t.textW=t.renderInfo.width,t.renderWindow=void 0}const{x:e,y:r,width:o,height:i,scrollY:l,contain:c}=t.props;let{renderWindow:h,canvasPages:d}=t;const m={x1:0,y1:0,x2:this.stage.options.appWidth,y2:this.stage.options.appHeight},g={x1:e,y1:r,x2:c!=="none"?e+o:1/0,y2:c==="both"?r+i:1/0},u=fe(m,g),y=u.y2-u.y1,p=Math.ceil(y/t.renderInfo.lineHeight);if(h&&d){const f=e+h.x1,b=r-l+h.y1,S=e+h.x2,T=r-l+h.y2;if(f<=u.x1&&S>=u.x2&&b<=u.y1&&T>=u.y2)return;T<u.y2?(h.y1+=p*t.renderInfo.lineHeight,h.y2+=p*t.renderInfo.lineHeight,d.push(d.shift()),d[2].lineNumStart=d[1].lineNumStart+p,d[2].lineNumEnd=d[2].lineNumStart+p,d[2].valid=!1):b>u.y1&&(h.y1-=p*t.renderInfo.lineHeight,h.y2-=p*t.renderInfo.lineHeight,d.unshift(d.pop()),d[0].lineNumStart=d[1].lineNumStart-p,d[0].lineNumEnd=d[0].lineNumStart+p,d[0].valid=!1)}else{const f=t.renderInfo.lineHeight*p,S=Math.ceil(l/f)*p,T=S-p,z=S+p;d=[{texture:d==null?void 0:d[0].texture,lineNumStart:T,lineNumEnd:T+p,valid:!1},{texture:d==null?void 0:d[1].texture,lineNumStart:S,lineNumEnd:S+p,valid:!1},{texture:d==null?void 0:d[2].texture,lineNumStart:z,lineNumEnd:z+p,valid:!1}],t.canvasPages=d;const P=Math.ceil(l/f)*f;h={x1:0,y1:P-f,x2:o,y2:P+f*2}}t.renderWindow=h;const x=performance.now();for(const f of d)if(!f.valid){if(f.lineNumStart<0){f.texture=this.stage.txManager.loadTexture("ImageTexture",{src:""}),f.valid=!0;continue}t.lightning2TextRenderer.draw(t.renderInfo,{lines:t.renderInfo.lines.slice(f.lineNumStart,f.lineNumEnd),lineWidths:t.renderInfo.lineWidths.slice(f.lineNumStart,f.lineNumEnd)}),this.canvas.width===0||this.canvas.height===0||(f.texture=this.stage.txManager.loadTexture("ImageTexture",{src:this.context.getImageData(0,0,this.canvas.width,this.canvas.height)},{preload:!0})),f.valid=!0}console.log("pageDrawTime",performance.now()-x,"ms"),this.setStatus(t,"loaded")}renderQuads(t,e,r,o){var F,v,C,R,D,w,I,O,Y,st,V,nt;const{stage:i}=this,{canvasPages:l,textW:c=0,textH:h=0,renderWindow:d}=t;if(!l||!d)return;const{x:m,y:g,scrollY:u,contain:y,width:p,height:x}=t.props,f={x:m,y:g,width:y!=="none"?p:c,height:y==="both"?x:h};ue({x:0,y:0,width:i.options.appWidth,height:i.options.appHeight},f),M(l,"canvasPages is not defined"),M(d,"renderWindow is not defined");const S=(d.y2-d.y1)/3,{zIndex:T,color:z}=t.props,P=o*De(z);l[0].valid&&this.stage.renderer.addRenderable({alpha:P,clippingRect:r,colorBl:4294967295,colorBr:4294967295,colorTl:4294967295,colorTr:4294967295,width:((v=(F=l[0].texture)==null?void 0:F.dimensions)==null?void 0:v.width)||0,height:((R=(C=l[0].texture)==null?void 0:C.dimensions)==null?void 0:R.height)||0,texture:l[0].texture,textureOptions:{},shader:null,shaderProps:null,zIndex:T,tx:e.tx,ty:e.ty-u+d.y1,ta:e.ta,tb:e.tb,tc:e.tc,td:e.td}),l[1].valid&&this.stage.renderer.addRenderable({alpha:P,clippingRect:r,colorBl:4294967295,colorBr:4294967295,colorTl:4294967295,colorTr:4294967295,width:((w=(D=l[1].texture)==null?void 0:D.dimensions)==null?void 0:w.width)||0,height:((O=(I=l[1].texture)==null?void 0:I.dimensions)==null?void 0:O.height)||0,texture:l[1].texture,textureOptions:{},shader:null,shaderProps:null,zIndex:T,tx:e.tx,ty:e.ty-u+d.y1+S,ta:e.ta,tb:e.tb,tc:e.tc,td:e.td}),l[2].valid&&this.stage.renderer.addRenderable({alpha:P,clippingRect:r,colorBl:4294967295,colorBr:4294967295,colorTl:4294967295,colorTr:4294967295,width:((st=(Y=l[2].texture)==null?void 0:Y.dimensions)==null?void 0:st.width)||0,height:((nt=(V=l[2].texture)==null?void 0:V.dimensions)==null?void 0:nt.height)||0,texture:l[2].texture,textureOptions:{},shader:null,shaderProps:null,zIndex:T,tx:e.tx,ty:e.ty-u+d.y1+S+S,ta:e.ta,tb:e.tb,tc:e.tc,td:e.td})}markForReload(t){t.renderInfo=void 0,this.setStatus(t,"loading")}onFontLoaded(t,e){var r;e!==((r=t.fontInfo)==null?void 0:r.cssString)||!t.fontInfo||(t.fontInfo.loaded=!0,this.updateState(t))}onFontLoadError(t,e,r){var o;e!==((o=t.fontInfo)==null?void 0:o.cssString)||!t.fontInfo||(t.fontInfo.loaded=!0,console.error("CanvasTextRenderer: Error loading font '".concat(t.fontInfo.cssString,"'"),r),this.updateState(t))}}const es=2e6;class ds{constructor(s){n(this,"options");n(this,"animationManager");n(this,"txManager");n(this,"fontManager");n(this,"textRenderers");n(this,"shManager");n(this,"renderer");n(this,"scene");n(this,"deltaTime",0);n(this,"lastFrameTime",0);n(this,"currentFrameTime",0);this.options=s;const{canvas:t,clearColor:e,rootId:r,debug:o,appWidth:i,appHeight:l}=s;this.txManager=new He,this.shManager=new We,this.animationManager=new Be,o!=null&&o.monitorTextureCache&&setInterval(()=>{M(this.txManager);const h=this.txManager.getDebugInfo();console.log("Texture ID Cache Size: ",h.idCacheSize),console.log("Texture Key Cache Size: ",h.keyCacheSize)},1e3),this.renderer=new Ae({stage:this,canvas:t,pixelRatio:s.devicePhysicalPixelRatio*s.deviceLogicalPixelRatio,clearColor:e!=null?e:4278190080,bufferMemory:es,txManager:this.txManager,shManager:this.shManager}),this.txManager.renderer=this.renderer,this.textRenderers={canvas:new ts(this),sdf:new qe(this)},this.fontManager=new xe(this.textRenderers);const c=new pe(this,{id:r,x:0,y:0,width:i,height:l,alpha:1,clipping:!1,color:0,colorTop:0,colorBottom:0,colorLeft:0,colorRight:0,colorTl:0,colorTr:0,colorBl:0,colorBr:0,zIndex:0,zIndexLocked:0,scaleX:1,scaleY:1,mountX:0,mountY:0,mount:0,pivot:.5,pivotX:.5,pivotY:.5,rotation:0,parent:null,texture:null,textureOptions:null,shader:null,shaderProps:null});this.scene=new Le(c),Xe(this)}drawFrame(){var r,o;const{renderer:s,scene:t,animationManager:e}=this;t!=null&&t.root&&(this.lastFrameTime=this.currentFrameTime,this.currentFrameTime=je(),this.deltaTime=this.lastFrameTime?this.currentFrameTime-this.lastFrameTime:100/6,e.update(this.deltaTime),s==null||s.reset(),(r=t==null?void 0:t.root)!=null&&r.hasUpdates&&((o=t==null?void 0:t.root)==null||o.update(this.deltaTime)),this.addQuads(t.root),s==null||s.sortRenderables(),s==null||s.render())}addQuads(s,t=null){M(this.renderer&&s.globalTransform);const e=s.globalTransform,r=e.tb!==0||e.tc!==0;let o=s.clipping&&!r?{x:e.tx,y:e.ty,width:s.width*e.ta,height:s.height*e.td}:null;t&&o?o=ue(t,o):t&&(o=t),s.renderQuads(this.renderer,o),s.children.forEach(i=>{i.worldAlpha!==0&&this.addQuads(i,o)})}resolveTextRenderer(s,t=null){let e=t,r=!1;if(e){const i=this.textRenderers[e];i?i.canRenderFont(s)||(console.warn("Cannot use override text renderer '".concat(e,"' for font"),s),e=null,r=!0):(console.warn("Text renderer override '".concat(e,"' not found.")),e=null,r=!0)}if(!e){for(const[i,l]of Object.entries(this.textRenderers))if(i!=="canvas"&&l.canRenderFont(s)){e=i;break}e||(e="canvas")}r&&console.warn("Falling back to text renderer ".concat(String(e)));const o=this.textRenderers[e];return M(o,"resolvedTextRenderer undefined"),o}get root(){var s;return((s=this.scene)==null?void 0:s.root)||null}}class fs extends pe{constructor(t,e){super(t,e);n(this,"textRenderer");n(this,"trState");n(this,"updateScheduled");n(this,"_textRendererOverride",null);n(this,"onTextLoaded",()=>{const{contain:t}=this,e=this.trState.props.width,r=this.trState.props.height,o=this.trState.textW||0,i=this.trState.textH||0;t==="both"?(this.props.width=e,this.props.height=r):t==="width"?(this.props.width=e,this.props.height=i):t==="none"&&(this.props.width=o,this.props.height=i),this.updateLocalTransform(),this.emit("loaded",{type:"text",dimensions:{width:this.trState.textW||0,height:this.trState.textH||0}})});n(this,"onTextFailed",(t,e)=>{this.emit("failed",{type:"text",error:e})});this.updateScheduled=!1,this._textRendererOverride=e.textRendererOverride;const{resolvedTextRenderer:r,textRendererState:o}=this.resolveTextRendererAndState({x:this.absX,y:this.absY,width:e.width,height:e.height,textAlign:e.textAlign,color:e.color,zIndex:e.zIndex,contain:e.contain,scaleX:e.scaleX,scaleY:e.scaleY,scrollable:e.scrollable,scrollY:e.scrollY,offsetY:e.offsetY,letterSpacing:e.letterSpacing,debug:e.debug,fontFamily:e.fontFamily,fontSize:e.fontSize,fontStretch:e.fontStretch,fontStyle:e.fontStyle,fontWeight:e.fontWeight,text:e.text},void 0);this.textRenderer=r,this.trState=o}get width(){return this.trState.props.width}set width(t){this.textRenderer.set.width(this.trState,t),this.updateText()}get height(){return this.trState.props.height}set height(t){this.textRenderer.set.height(this.trState,t),this.updateText()}get color(){return this.trState.props.color}set color(t){this.textRenderer.set.color(this.trState,t),this.updateText()}get text(){return this.trState.props.text}set text(t){this.textRenderer.set.text(this.trState,t),this.updateText()}get textRendererOverride(){return this._textRendererOverride}set textRendererOverride(t){this._textRendererOverride=t;const{resolvedTextRenderer:e,textRendererState:r}=this.resolveTextRendererAndState(this.trState.props,this.trState);this.textRenderer=e,this.trState=r}get fontSize(){return this.trState.props.fontSize}set fontSize(t){this.textRenderer.set.fontSize(this.trState,t),this.updateText()}get fontFamily(){return this.trState.props.fontFamily}set fontFamily(t){this.textRenderer.set.fontFamily(this.trState,t),this.updateText()}get fontStretch(){return this.trState.props.fontStretch}set fontStretch(t){this.textRenderer.set.fontStretch(this.trState,t),this.updateText()}get fontStyle(){return this.trState.props.fontStyle}set fontStyle(t){this.textRenderer.set.fontStyle(this.trState,t),this.updateText()}get fontWeight(){return this.trState.props.fontWeight}set fontWeight(t){this.textRenderer.set.fontWeight(this.trState,t),this.updateText()}get textAlign(){return this.trState.props.textAlign}set textAlign(t){this.textRenderer.set.textAlign(this.trState,t),this.updateText()}get contain(){return this.trState.props.contain}set contain(t){this.textRenderer.set.contain(this.trState,t),this.updateText()}get scrollable(){return this.trState.props.scrollable}set scrollable(t){this.textRenderer.set.scrollable(this.trState,t),this.updateText()}get scrollY(){return this.trState.props.scrollY}set scrollY(t){this.textRenderer.set.scrollY(this.trState,t),this.updateText()}get offsetY(){return this.trState.props.offsetY}set offsetY(t){this.textRenderer.set.offsetY(this.trState,t),this.updateText()}get letterSpacing(){return this.trState.props.letterSpacing}set letterSpacing(t){this.textRenderer.set.letterSpacing(this.trState,t),this.updateText()}get debug(){return this.trState.props.debug}set debug(t){this.textRenderer.set.debug(this.trState,t),this.updateText()}update(t){super.update(t),M(this.globalTransform),this.textRenderer.set.x(this.trState,this.globalTransform.tx),this.textRenderer.set.y(this.trState,this.globalTransform.ty),this.trState.status==="loading"&&this.textRenderer.updateState(this.trState)}updateText(){this.updateScheduled||(this.updateScheduled=!0,queueMicrotask(()=>{this.updateScheduled=!1,this.textRenderer.updateState(this.trState)}))}renderQuads(t,e){M(this.globalTransform),this.textRenderer.renderQuads(this.trState,this.globalTransform,e,this.worldAlpha)}resolveTextRendererAndState(t,e){const r=this.stage.resolveTextRenderer(t,this._textRendererOverride),o=r.createState(t);return e&&["loading","loaded","failed"].forEach(l=>{e.emitter.off(l)}),o.emitter.on("loading",()=>{o.emitter.once("fontLoaded",()=>{this.updateText()}),o.emitter.once("loaded",()=>{o.emitter.off("fontLoaded")})}),o.emitter.on("loaded",this.onTextLoaded),o.emitter.on("failed",this.onTextFailed),this.updateText(),{resolvedTextRenderer:r,textRendererState:o}}}const ss="modulepreload",rs=function(a){return"/"+a},le={},os=function(s,t,e){if(!t||t.length===0)return s();const r=document.getElementsByTagName("link");return Promise.all(t.map(o=>{if(o=rs(o),o in le)return;le[o]=!0;const i=o.endsWith(".css"),l=i?'[rel="stylesheet"]':"";if(!!e)for(let d=r.length-1;d>=0;d--){const m=r[d];if(m.href===o&&(!i||m.rel==="stylesheet"))return}else if(document.querySelector('link[href="'.concat(o,'"]').concat(l)))return;const h=document.createElement("link");if(h.rel=i?"stylesheet":ss,i||(h.as="script",h.crossOrigin=""),h.href=o,document.head.appendChild(h),i)return new Promise((d,m)=>{h.addEventListener("load",d),h.addEventListener("error",()=>m(new Error("Unable to preload CSS for ".concat(o))))})})).then(()=>s()).catch(o=>{const i=new Event("vite:preloadError",{cancelable:!0});if(i.payload=o,window.dispatchEvent(i),!i.defaultPrevented)throw o})};function is(a){return a.prototype instanceof Pe}async function us(a,s){let t;try{console.log("Loading core extension",a),t=await os(()=>import(a),[])}catch(r){console.error("The core extension module at '".concat(a,"' could not be loaded.")),console.error(r);return}if(!t.default){console.error("The core extension module at '".concat(a,"' does not have a default export."));return}const e=t.default;if(is(e)){const r=new e;try{await r.run(s)}catch(o){console.error("The core extension at '".concat(a,"' threw an error.")),console.error(o)}}else console.error("The core extension at '".concat(a,"' does not extend CoreExtension."))}const tt=typeof self>"u"?globalThis:self;function Vt(a,s){if(!a)throw new Error(s||"Assertion failed")}class Zt{constructor(s,t){n(this,"threadx");n(this,"sharedObjectStruct");n(this,"mutations");n(this,"waitPromise",null);n(this,"mutationsQueued",!1);n(this,"_id");n(this,"_typeId");n(this,"initialized",!1);n(this,"destroying",!1);n(this,"curProps");n(this,"eventListeners",{});this.curProps=t,this.threadx=Mt.instance,this.sharedObjectStruct=s,this._id=s.id,this._typeId=s.typeId;const e=this.constructor;if(!Object.prototype.hasOwnProperty.call(e,"staticInitialized")||!e.staticInitialized){e.staticInitialized=!0;const r=Object.getPrototypeOf(this);Object.keys(t).forEach(o=>{Object.defineProperty(r,o,{get:function(){return this.curProps[o]},set:function(i){this.curProps[o]=i,this.mutations[o]=!0,this.queueMutations()}})})}this.mutations={},this._executeMutations(),this.initialized=!0}static extractBuffer(s){if(s.destroying||!s.sharedObjectStruct)throw new Error("SharedObject.extractBuffer(): SharedObject is or was being destroyed.");return s.sharedObjectStruct.buffer}get typeId(){return this._typeId}get id(){return this._id}processDirtyProperties(){if(!this.sharedObjectStruct)throw new Error("SharedObject was destroyed");const{sharedObjectStruct:s,mutations:t,curProps:e}=this;s.constructor.propDefs.forEach((r,o)=>{if(s.isDirty(o)){const i=r.name;delete t[i];const l=e[i];e[i]=s[i],this.initialized&&this.onPropertyChange(i,s[i],l)}}),s.resetDirty()}onPropertyChange(s,t,e){}queueMutations(){this.mutationsQueued||(this.mutationsQueued=!0,queueMicrotask(()=>{this.mutationsQueued=!1,this.sharedObjectStruct&&this.mutationMicrotask().catch(console.error)}))}async mutationMicrotask(){if(!this.sharedObjectStruct)throw new Error("SharedObject was destroyed");await this.sharedObjectStruct.lockAsync(async()=>{this._executeMutations()}),this.destroying&&this.finishDestroy()}flush(){if(this.destroying||!this.sharedObjectStruct)throw new Error("SharedObject was destroyed");this.sharedObjectStruct.lock(()=>{this._executeMutations()})}onDestroy(){}destroy(){const s=this.sharedObjectStruct;this.destroying||!s||(this.emit("beforeDestroy",{},{localOnly:!0}),this.destroying=!0,this.onDestroy(),this.queueMutations())}finishDestroy(){const s=this.sharedObjectStruct;!this.destroying||!s||(this.threadx.forgetObjects([this],{silent:!0}).catch(console.error),this.sharedObjectStruct=null,s.notify(),this.emit("afterDestroy",{},{localOnly:!0}),this.eventListeners={})}get isDestroyed(){return this.sharedObjectStruct===null}_executeMutations(){if(!this.sharedObjectStruct)return;this.sharedObjectStruct.notifyValue!==this.threadx.workerId&&this.sharedObjectStruct.isDirty()&&this.processDirtyProperties();const{mutations:s}=this;this.mutations={};for(const r in s)if(Object.prototype.hasOwnProperty.call(s,r)){const o=this.curProps[r];this.sharedObjectStruct[r],this.sharedObjectStruct[r]=o}this.waitPromise&&(this.waitPromise=null);let t=this.sharedObjectStruct.notifyValue;this.sharedObjectStruct.isDirty()&&(this.sharedObjectStruct.notify(this.threadx.workerId),t=this.threadx.workerId);const e=this.sharedObjectStruct.waitAsync(t).then(async r=>{this.waitPromise===e&&this.sharedObjectStruct&&(Vt(r==="ok"),this.waitPromise=null,await this.mutationMicrotask())});this.waitPromise=e}on(s,t){let e=this.eventListeners[s];e||(e=[]),e.push(t),this.eventListeners[s]=e}off(s,t){const e=this.eventListeners[s];if(!e)return;const r=e.indexOf(t);r>=0&&e.splice(r,1)}once(s,t){const e=(r,o)=>{this.off(s,e),t(r,o)};this.on(s,e)}emit(s,t,e={}){const r=this.eventListeners[s];e.localOnly||Mt.instance.__sharedObjectEmit(this,s,t),r&&[...r].forEach(o=>{o(this,t)})}}n(Zt,"staticInitialized",!1);function ve(a){return a>=65&&a<=90||a>=48&&a<=57}function _e(a){let s=0;if(a.length===0)throw new Error("genTypeId: Type ID string must be at least 1 character");if(a.length>4)throw new Error("genTypeId: Type ID string must be 4 characters or less");for(let t=0;t<a.length;t++){let e=a.charCodeAt(t);if(e!==e)e=0;else if(!ve(e))throw new Error("genTypeId: Invalid character '".concat(a[t],"' (char code: ").concat(e,") in type ID string. A-Z and 0-9 only."));s|=e<<t*8}return s}function jt(a){const s=[];for(let t=0;t<4;t++){const e=a&255;if(ve(e))s.push(String.fromCharCode(e));else if(e!==0||t===0)return"????";a>>>=8}return s.join("")}function gt(a,s){return typeof s=="object"&&s!==null&&"threadXMessageType"in s&&s.threadXMessageType===a}function ns(a){return typeof a.DedicatedWorkerGlobalScope=="function"}class Mt{constructor(s){n(this,"workerId");n(this,"workerName");n(this,"sharedObjectFactory");n(this,"onSharedObjectCreated");n(this,"onBeforeObjectForgotten");n(this,"onUserMessage");n(this,"sharedObjects",new Map);n(this,"sharedObjectData",new WeakMap);n(this,"workers",new Map);n(this,"workerReadyPromises",new Map);n(this,"pendingAsyncMsgs",new Map);n(this,"nextAsyncMsgId",0);n(this,"nextUniqueId",0);n(this,"suppressSharedObjectEmit",!1);this.workerId=s.workerId,this.workerName=s.workerName,this.nextUniqueId=s.workerId*1e13+1,this.sharedObjectFactory=s.sharedObjectFactory,this.onSharedObjectCreated=s.onObjectShared,this.onBeforeObjectForgotten=s.onBeforeObjectForgotten,this.onUserMessage=s.onMessage;const t=tt;ns(t)&&(this.registerWorker("parent",t),this.sendMessage("parent",{threadXMessageType:"ready"}))}static init(s){if(tt.THREADX)throw new Error("ThreadX.init(): ThreadX already initialized.");const t=new Mt(s);return tt.THREADX=t,t}static destroy(){if(!tt.THREADX){console.warn("ThreadX.destroy(): ThreadX is not initialized.");return}delete tt.THREADX}static get workerId(){if(!tt.THREADX)throw new Error("ThreadX not initialized");return tt.THREADX.workerId}static get workerName(){if(!tt.THREADX)throw new Error("ThreadX not initialized");return tt.THREADX.workerName}static get instance(){if(!tt.THREADX)throw new Error("ThreadX not initialized");return tt.THREADX}registerWorker(s,t){this.workers.set(s,t);let e,r;s==="parent"?(r=Promise.resolve(),e=()=>{}):r=new Promise(o=>{e=o}),this.workerReadyPromises.set(s,{promise:r,resolve:e}),this.listenForWorkerMessages(s,t)}closeWorker(s){if(!this.workers.has(s))throw new Error("Worker ".concat(s," not registered."));this.closeWorkerAsync(s).catch(console.error)}async closeWorkerAsync(s,t=5e3){var o;const e=this.workers.get(s);if(!e)throw new Error("Worker ".concat(s," not registered."));const r=await Promise.race([new Promise(i=>{setTimeout(()=>{i(!1)},t)}),this.sendMessageAsync(s,{threadXMessageType:"close"})]);return this.workers.delete(s),this.workerReadyPromises.delete(s),r?"graceful":(console.warn('threadX.closeWorkerAsync(): Worker "'.concat(s,'" did not respond to "close" message within ').concat(t,"ms. Forcing termination.")),(o=e.terminate)==null||o.call(e),"forced")}listenForWorkerMessages(s,t){t.addEventListener("message",e=>{const{data:r}=e,o=r.__asyncMsgId;this.onMessage(s,r).then(i=>{o!==void 0&&t.postMessage({threadXMessageType:"response",asyncMsgId:o,data:i})}).catch(i=>{o!==void 0&&t.postMessage({threadXMessageType:"response",asyncMsgId:o,error:!0,data:i})})})}async shareObjects(s,t){for(const e of t)this.sharedObjects.get(e.id)?console.warn("ThreadX.shareObject(): SharedObject ".concat(e.id," (TypeID: ").concat(jt(e.typeId),") is already shared.")):(this.sharedObjects.set(e.id,e),this.sharedObjectData.set(e,{workerName:s,shareConfirmed:!1,emitQueue:null}));await this.sendMessageAsync(s,{threadXMessageType:"shareObjects",buffers:t.map(e=>Zt.extractBuffer(e))});for(const e of t){const r=this.sharedObjectData.get(e);if(r){r.shareConfirmed=!0;const{emitQueue:o}=r;if(o){for(const i of o)this.__sharedObjectEmit(e,i[0],i[1]);r.emitQueue=null}}}}async forgetObjects(s,t={}){const e=new Map;for(const o of s)if(!this.sharedObjects.has(o.id))t.silent||console.warn("ThreadX.forgetObject(): SharedObject ".concat(o.id," (TypeID: ").concat(jt(o.typeId),") is not shared."));else{const i=this.sharedObjectData.get(o);Vt(i);let l=e.get(i.workerName);l||(l=[],e.set(i.workerName,l)),l.push(o),this.sharedObjects.delete(o.id),this.sharedObjectData.delete(o)}const r=[];for(const[o,i]of e)r.push(this.sendMessageAsync(o,{threadXMessageType:"forgetObjects",objectIds:i.map(l=>l.id)}));await Promise.all(r)}sendMessage(s,t,e){if(!this.workers.get(s))throw new Error("ThreadX.sendMessage(): Worker '".concat(s,"' not registered."));this.sendMessageAsync(s,t,e,{skipResponseWait:!0}).catch(console.error)}async sendMessageAsync(s,t,e,r={}){const o=this.workers.get(s);if(!o)throw new Error("ThreadX.execMessage(): Worker '".concat(s,"' not registered."));if(await this.workerReadyPromises.get(s).promise,r.skipResponseWait){o.postMessage(t,e);return}const i=this.nextAsyncMsgId++,l=new Promise((c,h)=>{this.pendingAsyncMsgs.set(i,{resolve:c,reject:h})});return t.__asyncMsgId=i,o.postMessage(t,e),l}async onMessage(s,t){var e;if(gt("shareObjects",t))t.buffers.forEach(r=>{var i,l;const o=(i=this.sharedObjectFactory)==null?void 0:i.call(this,r);if(!o)throw new Error("ThreadX.onMesasge(): Failed to create shared object.");this.sharedObjects.set(o.id,o),this.sharedObjectData.set(o,{workerName:s,shareConfirmed:!0,emitQueue:null}),(l=this.onSharedObjectCreated)==null||l.call(this,o)});else if(gt("forgetObjects",t))t.objectIds.forEach(r=>{var i;const o=this.sharedObjects.get(r);o&&((i=this.onBeforeObjectForgotten)==null||i.call(this,o),this.sharedObjects.delete(r),o.destroy())});else if(gt("sharedObjectEmit",t)){const r=this.sharedObjects.get(t.sharedObjectId);if(!r)return;this.suppressSharedObjectEmit=!0,r.emit(t.eventName,t.data),this.suppressSharedObjectEmit=!1}else if(gt("response",t)){const r=this.pendingAsyncMsgs.get(t.asyncMsgId);if(!r)throw new Error("ThreadX.onMessage(): Received response for unknown request (ID: ".concat(t.asyncMsgId,")"));this.pendingAsyncMsgs.delete(t.asyncMsgId),t.error?r.reject(t.data):r.resolve(t.data)}else{if(gt("close",t))return tt.close(),!0;if(gt("ready",t))return(e=this.workerReadyPromises.get(s))==null||e.resolve(),!0;if(this.onUserMessage)return await this.onUserMessage(t)}}getSharedObjectById(s){return this.sharedObjects.get(s)||null}generateUniqueId(){return this.nextUniqueId++}__sharedObjectEmit(s,t,e){if(this.suppressSharedObjectEmit)return;const r=this.sharedObjectData.get(s);if(!r)return;if(!r.shareConfirmed){r.emitQueue||(r.emitQueue=[]),r.emitQueue.push([t,e]);return}const o=this.workers.get(r.workerName);Vt(o,"Worker not found"),o.postMessage({threadXMessageType:"sharedObjectEmit",sharedObjectId:s.id,eventName:t,data:e})}}const St=0,xt=1,et=2,ct=6,ce=2,At=255;function Pt(a,s,t){return a===s}function $t(a,s){return a===s}function _(a,s){return function(t,e,r){const o=t.constructor;(!Object.prototype.hasOwnProperty.call(o,"staticInitialized")||!o.staticInitialized)&&o.initStatic();let i=o.size,l=0,c=0;a==="string"?(i+=i%2,l=i/2,c=(At+1)*2):a==="int32"||a==="boolean"?(i+=i%4,l=i/4,c=4):a==="number"&&(i+=i%8,l=i/8,c=8);const h=o.propDefs,d=h.length,m={propNum:d,name:e,type:a,byteOffset:i,offset:l,byteSize:c};h.push(m),o.size=i+c,r.get=function(){let g;if(a==="string"){const u=this.uint16array[l];if(!u)return"";if(u>At)throw new Error("get SharedObject.".concat(e,": Text length is too long. Length: ").concat(u));g=String.fromCharCode(...this.uint16array.slice(l+1,l+1+u))}else a==="int32"?g=this.int32array[l]:a==="boolean"?g=!!this.int32array[l]:a==="number"&&(g=this.float64array[l]);return s!=null&&s.bufferToProp&&(g=s.bufferToProp(g)),g},r.set=function(g){if(s!=null&&s.propToBuffer&&(g=s.propToBuffer(g)),Pt("string",a)){if(!$t(g,this[e])){this.setDirty(d);let u=g.length;u>At&&(console.error("set SharedObject.".concat(e,": Text length is too long. Truncating..."),u),u=At),this.uint16array[l]=u;const y=l+1,p=y+u;let x=0;for(let f=y;f<p;f++)this.uint16array[f]=g.charCodeAt(x++)}}else Pt("int32",a)?$t(g,this[e])||(this.setDirty(d),this.int32array[l]=g):Pt("boolean",a)?$t(g,this[e])||(this.setDirty(d),this.int32array[l]=g?1:0):Pt("number",a)&&($t(g,this[e])||(this.setDirty(d),this.float64array[l]=g))}}}const at=class at{constructor(s){n(this,"buffer");n(this,"lockId",Math.floor(Math.random()*4294967295));n(this,"uint16array");n(this,"int32array");n(this,"float64array");const t=this.constructor;(!Object.prototype.hasOwnProperty.call(t,"staticInitialized")||!t.staticInitialized)&&t.initStatic();const e=!s;s||(s=new SharedArrayBuffer(Math.ceil(t.size/8)*8)),this.buffer=s,this.uint16array=new Uint16Array(s),this.int32array=new Int32Array(s),this.float64array=new Float64Array(s);const r=t.typeId;if(e)this.int32array[St]=r,this.float64array[ce]=Mt.instance.generateUniqueId();else if(this.int32array[St]!==r)throw new Error("BufferStruct: TypeId mismatch. Expected '".concat(t.typeIdStr,"', got '").concat(jt(this.int32array[St]),"'"))}static extractTypeId(s){return s.byteLength<at.size||s.byteLength%8!==0?0:new Int32Array(s)[St]||0}static initStatic(){const s=jt(this.typeId);if(s==="????")throw new Error("BufferStruct.typeId must be set to a valid 32-bit integer");this.typeIdStr=s,this.propDefs=[...this.propDefs],this.staticInitialized=!0}setDirty(s){const t=Math.floor(s/32),e=s-t*32;this.int32array[ct+t]=this.int32array[ct+t]|1<<e}resetDirty(){this.int32array[xt]=0,this.int32array[ct]=0,this.int32array[ct+1]=0}isDirty(s){if(s!==void 0){const t=Math.floor(s/32),e=s-t*32;return!!(this.int32array[ct+t]&1<<e)}return!!(this.int32array[ct]||this.int32array[ct+1])}get typeId(){return this.int32array[St]}get id(){return this.float64array[ce]}get notifyValue(){return Atomics.load(this.int32array,xt)}get isLocked(){return Atomics.load(this.int32array,et)!==0}lock(s){let t=Atomics.compareExchange(this.int32array,et,0,this.lockId);for(;t!==0;){try{Atomics.wait(this.int32array,et,t)}catch(r){if(!(r instanceof TypeError&&r.message==="Atomics.wait cannot be called in this context"))throw r}t=Atomics.compareExchange(this.int32array,et,0,this.lockId)}let e;try{e=s()}finally{Atomics.store(this.int32array,et,0),Atomics.notify(this.int32array,et)}return e}async lockAsync(s){let t=Atomics.compareExchange(this.int32array,et,0,this.lockId);for(;t!==0;)await Atomics.waitAsync(this.int32array,et,t).value,t=Atomics.compareExchange(this.int32array,et,0,this.lockId);let e;try{e=await s()}finally{Atomics.store(this.int32array,et,0),Atomics.notify(this.int32array,et)}return e}notify(s){return s!==void 0&&Atomics.store(this.int32array,xt,s),Atomics.notify(this.int32array,xt)}wait(s,t=1/0){return Atomics.wait(this.int32array,xt,s,t)}async waitAsync(s,t=1/0){return Atomics.waitAsync(this.int32array,xt,s,t).value}};n(at,"staticInitialized",!1),n(at,"typeId",0),n(at,"typeIdStr",""),n(at,"size",8*4),n(at,"propDefs",[]);let Qt=at;var E=globalThis&&globalThis.__decorate||function(a,s,t,e){var r=arguments.length,o=r<3?s:e===null?e=Object.getOwnPropertyDescriptor(s,t):e,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(a,s,t,e);else for(var l=a.length-1;l>=0;l--)(i=a[l])&&(o=(r<3?i(o):r>3?i(s,t,o):i(s,t))||o);return r>3&&o&&Object.defineProperty(s,t,o),o};class k extends Qt{get x(){return 0}set x(s){}get y(){return 0}set y(s){}get width(){return 0}set width(s){}get height(){return 0}set height(s){}get alpha(){return 1}set alpha(s){}get clipping(){return!1}set clipping(s){}get color(){return 0}set color(s){}get colorTop(){return 0}set colorTop(s){}get colorBottom(){return 0}set colorBottom(s){}get colorLeft(){return 0}set colorLeft(s){}get colorRight(){return 0}set colorRight(s){}get colorTl(){return 0}set colorTl(s){}get colorTr(){return 0}set colorTr(s){}get colorBl(){return 0}set colorBl(s){}get colorBr(){return 0}set colorBr(s){}get scaleX(){return 1}set scaleX(s){}get scaleY(){return 1}set scaleY(s){}get mount(){return 0}set mount(s){}get mountX(){return 0}set mountX(s){}get mountY(){return 0}set mountY(s){}get pivot(){return .5}set pivot(s){}get pivotX(){return .5}set pivotX(s){}get pivotY(){return .5}set pivotY(s){}get rotation(){return 0}set rotation(s){}get parentId(){return 0}set parentId(s){}get zIndex(){return 0}set zIndex(s){}get zIndexLocked(){return 0}set zIndexLocked(s){}}n(k,"typeId",_e("NODE"));E([_("number")],k.prototype,"x",null);E([_("number")],k.prototype,"y",null);E([_("number")],k.prototype,"width",null);E([_("number")],k.prototype,"height",null);E([_("number")],k.prototype,"alpha",null);E([_("boolean")],k.prototype,"clipping",null);E([_("number")],k.prototype,"color",null);E([_("number")],k.prototype,"colorTop",null);E([_("number")],k.prototype,"colorBottom",null);E([_("number")],k.prototype,"colorLeft",null);E([_("number")],k.prototype,"colorRight",null);E([_("number")],k.prototype,"colorTl",null);E([_("number")],k.prototype,"colorTr",null);E([_("number")],k.prototype,"colorBl",null);E([_("number")],k.prototype,"colorBr",null);E([_("number")],k.prototype,"scaleX",null);E([_("number")],k.prototype,"scaleY",null);E([_("number")],k.prototype,"mount",null);E([_("number")],k.prototype,"mountX",null);E([_("number")],k.prototype,"mountY",null);E([_("number")],k.prototype,"pivot",null);E([_("number")],k.prototype,"pivotX",null);E([_("number")],k.prototype,"pivotY",null);E([_("number")],k.prototype,"rotation",null);E([_("number")],k.prototype,"parentId",null);E([_("number")],k.prototype,"zIndex",null);E([_("number")],k.prototype,"zIndexLocked",null);class ps extends Zt{constructor(s,t){super(s,{...t,x:s.x,y:s.y,width:s.width,height:s.height,alpha:s.alpha,clipping:s.clipping,color:s.color,colorTop:s.colorTop,colorBottom:s.colorBottom,colorLeft:s.colorLeft,colorRight:s.colorRight,colorTl:s.colorTl,colorTr:s.colorTr,colorBl:s.colorBl,colorBr:s.colorBr,parentId:s.parentId,zIndex:s.zIndex,zIndexLocked:s.zIndexLocked,scaleX:s.scaleX,scaleY:s.scaleY,mount:s.mount,mountX:s.mountX,mountY:s.mountY,pivot:s.pivot,pivotX:s.pivotX,pivotY:s.pivotY,rotation:s.rotation})}}var K=globalThis&&globalThis.__decorate||function(a,s,t,e){var r=arguments.length,o=r<3?s:e===null?e=Object.getOwnPropertyDescriptor(s,t):e,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")o=Reflect.decorate(a,s,t,e);else for(var l=a.length-1;l>=0;l--)(i=a[l])&&(o=(r<3?i(o):r>3?i(s,t,o):i(s,t))||o);return r>3&&o&&Object.defineProperty(s,t,o),o};class N extends k{get text(){return""}set text(s){}get textRendererOverride(){return null}set textRendererOverride(s){}get fontSize(){return 0}set fontSize(s){}get fontFamily(){return""}set fontFamily(s){}get fontStretch(){return"normal"}set fontStretch(s){}get fontStyle(){return"normal"}set fontStyle(s){}get fontWeight(){return"normal"}set fontWeight(s){}get textAlign(){return"left"}set textAlign(s){}get contain(){return"none"}set contain(s){}get scrollable(){return!1}set scrollable(s){}get scrollY(){return 0}set scrollY(s){}get offsetY(){return 0}set offsetY(s){}get letterSpacing(){return 0}set letterSpacing(s){}}n(N,"typeId",_e("TEXT"));K([_("string")],N.prototype,"text",null);K([_("string",{propToBuffer(a){return a!=null?a:"$$null"},bufferToProp(a){return a==="$$null"?null:a}})],N.prototype,"textRendererOverride",null);K([_("number")],N.prototype,"fontSize",null);K([_("string")],N.prototype,"fontFamily",null);K([_("string")],N.prototype,"fontStretch",null);K([_("string")],N.prototype,"fontStyle",null);K([_("string")],N.prototype,"fontWeight",null);K([_("string")],N.prototype,"textAlign",null);K([_("string")],N.prototype,"contain",null);K([_("boolean")],N.prototype,"scrollable",null);K([_("number")],N.prototype,"scrollY",null);K([_("number")],N.prototype,"offsetY",null);K([_("number")],N.prototype,"letterSpacing",null);export{Qt as B,pe as C,k as N,ds as S,Mt as T,cs as a,hs as b,fs as c,ps as d,N as e,us as l};
//# sourceMappingURL=TextNodeStruct-90417aca.js.map
