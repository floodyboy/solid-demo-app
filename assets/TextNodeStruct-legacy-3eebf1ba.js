System.register(["./CoreExtension-legacy-f23b096e.js"],(function(t,e){"use strict";var r,s,o,n,i,a,l,c,h,d,u,p,f,m,g,x,y,v,_,b,w;return{setters:[t=>{r=t.E,s=t.g,o=t.m,n=t.a,i=t.b,a=t.c,l=t.T,c=t.d,h=t.e,d=t.i,u=t.S,p=t.f,f=t.B,m=t.h,g=t.j,x=t.k,y=t.W,v=t.l,_=t.n,b=t.o,w=t.C}],execute:function(){t("l",(async function(t,r){let s;try{console.log("Loading core extension",t),s=await lt((()=>e.import(t)),void 0)}catch(n){return console.error(`The core extension module at '${t}' could not be loaded.`),void console.error(n)}if(!s.default)return void console.error(`The core extension module at '${t}' does not have a default export.`);const o=s.default;if(o.prototype instanceof w){const e=new o;try{await e.run(r)}catch(n){console.error(`The core extension at '${t}' threw an error.`),console.error(n)}}else console.error(`The core extension at '${t}' does not extend CoreExtension.`)})),t("a",class extends r{node;props;settings;propStartValues={};restoreValues={};progress=0;timingFunction;constructor(t,e,r){super(),this.node=t,this.props=e,this.settings=r,this.propStartValues={},Object.keys(e).forEach((e=>{this.propStartValues[e]=t[e]})),this.timingFunction=t=>t,r.easing&&"string"==typeof r.easing&&(this.timingFunction=s(r.easing))}reset(){this.progress=0,this.update(0)}restore(){this.reset(),Object.keys(this.props).forEach((t=>{this.node[t]=this.propStartValues[t]}))}reverse(){this.progress=0,Object.keys(this.props).forEach((t=>{const e=this.props[t],r=this.propStartValues[t];this.props[t]=r,this.propStartValues[t]=e})),this.settings.loop||(this.settings.stopMethod=!1)}applyEasing(t,e,r){return(this.timingFunction(t)||t)*(r-e)+e}update(t){const{duration:e,loop:r,easing:s}=this.settings;e?(this.progress+=t/e,this.progress>1&&(this.progress=r?0:1,this.emit("finished",{})),Object.keys(this.props).forEach((t=>{const e=this.props[t],r=this.propStartValues[t],n=e;if(-1!==t.indexOf("color")){const e=s&&this.timingFunction(this.progress)||this.progress,i=o(r,n,e);this.node[t]=s?i:o(r,n,this.progress)}else this.node[t]=s?this.applyEasing(this.progress,r,n):r+(n-r)*this.progress}))):this.emit("finished",{})}}),t("b",class{manager;animation;stoppedPromise=null;stoppedResolve=null;constructor(t,e){this.manager=t,this.animation=e,this.state="stopped"}state;start(){return this.makeStoppedPromise(),this.animation.once("finished",this.finished.bind(this)),this.manager.activeAnimations.has(this.animation)||this.manager.registerAnimation(this.animation),this.state="running",this}stop(){return this.manager.unregisterAnimation(this.animation),null!==this.stoppedResolve&&(this.stoppedResolve(),this.stoppedResolve=null),this.animation.reset(),this.state="stopped",this}pause(){return this.manager.unregisterAnimation(this.animation),this.state="paused",this}restore(){return this.stoppedResolve=null,this.animation.restore(),this}waitUntilStopped(){this.makeStoppedPromise();const t=this.stoppedPromise;return n(t),t}makeStoppedPromise(){null===this.stoppedResolve&&(this.stoppedPromise=new Promise((t=>{this.stoppedResolve=t})))}finished(){n(this.stoppedResolve);const{loop:t,stopMethod:e}=this.animation.settings;if("reverse"===e)return this.animation.reverse(),void this.start();this.stoppedResolve(),this.stoppedResolve=null,t||this.manager.unregisterAnimation(this.animation)}});class S{data;constructor(t){t?(this.data=new Float32Array(9),this.data[0]=t[0],this.data[3]=t[3],this.data[6]=t[6],this.data[1]=t[1],this.data[4]=t[4],this.data[7]=t[7],this.data[2]=t[2],this.data[5]=t[5],this.data[8]=t[8]):this.data=new Float32Array(9)}static get temp(){return T}static multiply(t,e,r){const s=t.data[0]*e.data[0]+t.data[3]*e.data[1]+t.data[6]*e.data[2],o=t.data[0]*e.data[3]+t.data[3]*e.data[4]+t.data[6]*e.data[5],n=t.data[0]*e.data[6]+t.data[3]*e.data[7]+t.data[6]*e.data[8],i=t.data[1]*e.data[0]+t.data[4]*e.data[1]+t.data[7]*e.data[2],a=t.data[1]*e.data[3]+t.data[4]*e.data[4]+t.data[7]*e.data[5],l=t.data[1]*e.data[6]+t.data[4]*e.data[7]+t.data[7]*e.data[8],c=t.data[2]*e.data[0]+t.data[5]*e.data[1]+t.data[8]*e.data[2],h=t.data[2]*e.data[3]+t.data[5]*e.data[4]+t.data[8]*e.data[5],d=t.data[2]*e.data[6]+t.data[5]*e.data[7]+t.data[8]*e.data[8];return r||(r=new S),r.data[0]=s,r.data[3]=o,r.data[6]=n,r.data[1]=i,r.data[4]=a,r.data[7]=l,r.data[2]=c,r.data[5]=h,r.data[8]=d,r}static identity(t){return t||(t=new S),t.data[0]=1,t.data[3]=0,t.data[6]=0,t.data[1]=0,t.data[4]=1,t.data[7]=0,t.data[2]=0,t.data[5]=0,t.data[8]=1,t}static translate(t,e,r){return r||(r=new S),r.data[0]=1,r.data[3]=0,r.data[6]=t,r.data[1]=0,r.data[4]=1,r.data[7]=e,r.data[2]=0,r.data[5]=0,r.data[8]=1,r}static scale(t,e,r){return r||(r=new S),r.data[0]=t,r.data[3]=0,r.data[6]=0,r.data[1]=0,r.data[4]=e,r.data[7]=0,r.data[2]=0,r.data[5]=0,r.data[8]=1,r}static rotate(t,e){const r=Math.cos(t),s=Math.sin(t);return e||(e=new S),e.data[0]=r,e.data[3]=-s,e.data[6]=0,e.data[1]=s,e.data[4]=r,e.data[7]=0,e.data[2]=0,e.data[5]=0,e.data[8]=1,e}static copy(t,e,r){return e||(e=new S),e.data[0]=t.data[0],e.data[1]=t.data[1],e.data[2]=t.data[2],e.data[3]=t.data[3],e.data[4]=t.data[4],e.data[5]=t.data[5],e.data[6]=t.data[6],e.data[7]=t.data[7],e.data[8]=t.data[8],e}translate(t,e){return this.data[6]=this.data[0]*t+this.data[3]*e+this.data[6],this.data[7]=this.data[1]*t+this.data[4]*e+this.data[7],this}scale(t,e){return this.data[0]=this.data[0]*t,this.data[3]=this.data[3]*e,this.data[1]=this.data[1]*t,this.data[4]=this.data[4]*e,this}rotate(t){if(0===t||!(t%Math.PI*2))return this;const e=Math.cos(t),r=Math.sin(t),s=this.data[0]*e+this.data[3]*r,o=this.data[3]*e-this.data[0]*r,n=this.data[1]*e+this.data[4]*r,i=this.data[4]*e-this.data[1]*r;return this.data[0]=s,this.data[3]=o,this.data[1]=n,this.data[4]=i,this}multiply(t){return S.multiply(this,t,this)}get tx(){return this.data[6]}get ty(){return this.data[7]}get ta(){return this.data[0]}get tb(){return this.data[3]}get tc(){return this.data[1]}get td(){return this.data[4]}transformPoint(t,e){return[this.data[0]*t+this.data[3]*e+this.data[6],this.data[1]*t+this.data[4]*e+this.data[1]]}}const T=new S;class C extends r{stage;children=[];props;recalculationType=6;hasUpdates=!0;globalTransform;scaleRotateTransform;localTransform;isComplex=!1;constructor(t,e){super(),this.stage=t,this.props={...e,parent:null},this.parent=e.parent,this.updateScaleRotateTransform()}loadTexture(t,e,r=null){this.props.texture&&this.unloadTexture();const{txManager:s}=this.stage,o=s.loadTexture(t,e,r);this.props.texture=o,this.props.textureOptions=r,queueMicrotask((()=>{"loaded"===o.state?this.onTextureLoaded(o,o.dimensions):"failed"===o.state&&this.onTextureFailed(o,o.error),o.on("loaded",this.onTextureLoaded),o.on("failed",this.onTextureFailed)}))}unloadTexture(){this.props.texture&&(this.props.texture.off("loaded",this.onTextureLoaded),this.props.texture.off("failed",this.onTextureFailed)),this.props.texture=null,this.props.textureOptions=null}onTextureLoaded=(t,e)=>{this.emit("loaded",{type:"texture",dimensions:e})};onTextureFailed=(t,e)=>{this.emit("failed",{type:"texture",error:e})};loadShader(t,e){const r=this.stage.renderer.getShaderManager();n(r);const{shader:s,props:o}=r.loadShader(t,e);this.props.shader=s,this.props.shaderProps=o}setHasUpdates(){if(!this.props.alpha)return;this.hasUpdates=!0;let t=this?.props.parent;for(;t;)t.hasUpdates=!0,t=t?.props.parent}setRecalculationType(t){this.recalculationType|=t,this.setHasUpdates()}updateScaleRotateTransform(){this.setRecalculationType(4),this.scaleRotateTransform=S.rotate(this.props.rotation,this.scaleRotateTransform).scale(this.props.scaleX,this.props.scaleY),this.updateLocalTransform()}updateLocalTransform(){n(this.scaleRotateTransform),this.setRecalculationType(2);const t=this.props.pivotX*this.props.width,e=this.props.pivotY*this.props.height,r=this.props.mountX*this.props.width,s=this.props.mountY*this.props.height;this.localTransform=S.translate(t-r+this.props.x,e-s+this.props.y,this.localTransform).multiply(this.scaleRotateTransform).translate(-t,-e)}update(t){n(this.localTransform);const e=this.parent?.globalTransform;this.globalTransform=e?S.copy(e,this.globalTransform).multiply(this.localTransform):S.copy(this.localTransform,this.globalTransform),this.children.length&&this.children.forEach((e=>{e.update(t)})),this.hasUpdates=!1,this.recalculationType=0}renderQuads(t,e){const{width:r,height:s,colorTl:o,colorTr:i,colorBl:a,colorBr:l,texture:c,textureOptions:h,shader:d,shaderProps:u}=this.props,{zIndex:p,worldAlpha:f,globalTransform:m}=this;n(m),t.addRenderable({width:r,height:s,colorTl:o,colorTr:i,colorBl:a,colorBr:l,texture:c,textureOptions:h,zIndex:p,shader:d,shaderProps:u,alpha:f,clippingRect:e,tx:m.tx,ty:m.ty,ta:m.ta,tb:m.tb,tc:m.tc,td:m.td})}get id(){return this.props.id}get x(){return this.props.x}set x(t){this.props.x!==t&&(this.props.x=t,this.updateLocalTransform())}get absX(){return this.props.x+(this.props.parent?.absX||this.props.parent?.globalTransform?.tx||0)}get absY(){return this.props.y+(this.props.parent?.absY??0)}get y(){return this.props.y}set y(t){this.props.y!==t&&(this.props.y=t,this.updateLocalTransform())}get width(){return this.props.width}set width(t){this.props.width!==t&&(this.props.width=t,this.updateLocalTransform())}get height(){return this.props.height}set height(t){this.props.height!==t&&(this.props.height=t,this.updateLocalTransform())}get scale(){return this.scaleX}set scale(t){this.scaleX=t,this.scaleY=t}get scaleX(){return this.props.scaleX}set scaleX(t){this.props.scaleX!==t&&(this.props.scaleX=t,this.updateScaleRotateTransform())}get scaleY(){return this.props.scaleY}set scaleY(t){this.props.scaleY!==t&&(this.props.scaleY=t,this.updateScaleRotateTransform())}get worldScaleX(){return this.props.scaleX*(this.props.parent?.worldScaleX??1)||this.props.scaleX}get worldScaleY(){return this.props.scaleY*(this.props.parent?.worldScaleY??1)||this.props.scaleY}get mount(){return this.props.mount}set mount(t){this.props.mountX=t,this.props.mountY=t,this.props.mount=t,this.updateLocalTransform()}get mountX(){return this.props.mountX}set mountX(t){this.props.mountX=t,this.updateLocalTransform()}get mountY(){return this.props.mountY}set mountY(t){this.props.mountY=t,this.updateLocalTransform()}get pivot(){return this.props.pivot}set pivot(t){this.props.pivotX===t&&this.props.pivotY===t||(this.props.pivotX=t,this.props.pivotY=t,this.updateLocalTransform())}get pivotX(){return this.props.pivotX}set pivotX(t){this.props.pivotX=t,this.updateLocalTransform()}get pivotY(){return this.props.pivotY}set pivotY(t){this.props.pivotY=t,this.updateLocalTransform()}get rotation(){return this.props.rotation}set rotation(t){this.props.rotation!==t&&(this.props.rotation=t,this.updateScaleRotateTransform())}get alpha(){return this.props.alpha}set alpha(t){this.props.alpha=t}get worldAlpha(){const t=this.props,e=t.parent;return t.alpha*(e?.worldAlpha||1)}get clipping(){return this.props.clipping}set clipping(t){this.props.clipping=t}get color(){return this.props.color}set color(t){this.props.colorTl===t&&this.props.colorTr===t&&this.props.colorBl===t&&this.props.colorBr===t||(this.colorTl=t,this.colorTr=t,this.colorBl=t,this.colorBr=t),this.props.color=t}get colorTop(){return this.props.colorTop}set colorTop(t){this.props.colorTl===t&&this.props.colorTr===t||(this.colorTl=t,this.colorTr=t),this.props.colorTop=t}get colorBottom(){return this.props.colorBottom}set colorBottom(t){this.props.colorBl===t&&this.props.colorBr===t||(this.colorBl=t,this.colorBr=t),this.props.colorBottom=t}get colorLeft(){return this.props.colorLeft}set colorLeft(t){this.props.colorTl===t&&this.props.colorBl===t||(this.colorTl=t,this.colorBl=t),this.props.colorLeft=t}get colorRight(){return this.props.colorRight}set colorRight(t){this.props.colorTr===t&&this.props.colorBr===t||(this.colorTr=t,this.colorBr=t),this.props.colorRight=t}get colorTl(){return this.props.colorTl}set colorTl(t){this.props.colorTl=t}get colorTr(){return this.props.colorTr}set colorTr(t){this.props.colorTr=t}get colorBl(){return this.props.colorBl}set colorBl(t){this.props.colorBl=t}get colorBr(){return this.props.colorBr}set colorBr(t){this.props.colorBr=t}get zIndexLocked(){return this.props.zIndexLocked||0}set zIndexLocked(t){this.props.zIndexLocked=t}get zIndex(){const t=this.props,e=t.zIndex||0,r=t.parent?.zIndex||0;return t.parent?.zIndexLocked?e<r?e:r:e}set zIndex(t){this.props.zIndex=t}get parent(){return this.props.parent}set parent(t){const e=this.props.parent;if(e!==t){if(this.props.parent=t,e){const t=e.children.indexOf(this);n(-1!==t,"CoreNode.parent: Node not found in old parent's children!"),e.children.splice(t,1)}t&&t.children.push(this),this.updateScaleRotateTransform()}}}t("C",C);class R{root;constructor(t){this.root=t}getNodeByType(t){return[]}getNodeById(t){return null}update(t){this.root.update(t)}}class I extends i{constructor(t){super({renderer:t,attributes:["a_position","a_textureCoordinate","a_color"],uniforms:[{name:"u_resolution",uniform:"uniform2fv"},{name:"u_pixelRatio",uniform:"uniform1f"},{name:"u_texture",uniform:"uniform2fv"}]})}bindTextures(t){const{gl:e}=this;e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,t[0].ctxTexture)}static shaderSources={vertex:"\n      # ifdef GL_FRAGMENT_PRESICISON_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      attribute vec2 a_position;\n      attribute vec2 a_textureCoordinate;\n      attribute vec4 a_color;\n\n      uniform vec2 u_resolution;\n      uniform float u_pixelRatio;\n\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoordinate;\n\n      void main() {\n        vec2 normalized = a_position * u_pixelRatio / u_resolution;\n        vec2 zero_two = normalized * 2.0;\n        vec2 clip_space = zero_two - 1.0;\n\n        // pass to fragment\n        v_color = a_color;\n        v_textureCoordinate = a_textureCoordinate;\n\n        // flip y\n        gl_Position = vec4(clip_space * vec2(1.0, -1.0), 0, 1);\n      }\n    ",fragment:"\n      # ifdef GL_FRAGMENT_PRESICISON_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      uniform vec2 u_resolution;\n      uniform sampler2D u_texture;\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoordinate;\n\n      void main() {\n          vec4 color = texture2D(u_texture, v_textureCoordinate);\n          gl_FragColor = vec4(v_color) * texture2D(u_texture, v_textureCoordinate);\n      }\n    "}}class k extends i{supportsIndexedTextures=!0;constructor(t){super({renderer:t,attributes:["a_position","a_textureCoordinate","a_color","a_textureIndex"],uniforms:[{name:"u_resolution",uniform:"uniform2fv"},{name:"u_pixelRatio",uniform:"uniform1f"},{name:"u_textures[0]",uniform:"uniform1iv"}]})}bindTextures(t){const{renderer:e,gl:r}=this;if(t.length>e.system.parameters.MAX_VERTEX_TEXTURE_IMAGE_UNITS)throw new Error(`DefaultShaderBatched: Cannot bind more than ${e.system.parameters.MAX_VERTEX_TEXTURE_IMAGE_UNITS} textures`);t.forEach(((t,e)=>{r.activeTexture(r.TEXTURE0+e),r.bindTexture(r.TEXTURE_2D,t.ctxTexture)}));const s=Array.from(Array(t.length).keys());this.setUniform("u_textures[0]",s)}static shaderSources={vertex:"\n      # ifdef GL_FRAGMENT_PRESICISON_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      attribute vec2 a_textureCoordinate;\n      attribute vec2 a_position;\n      attribute vec4 a_color;\n      attribute float a_textureIndex;\n      attribute float a_depth;\n\n      uniform vec2 u_resolution;\n      uniform float u_pixelRatio;\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoordinate;\n      varying float v_textureIndex;\n\n      void main(){\n        vec2 normalized = a_position * u_pixelRatio / u_resolution;\n        vec2 zero_two = normalized * 2.0;\n        vec2 clip_space = zero_two - 1.0;\n\n        // pass to fragment\n        v_color = a_color;\n        v_textureCoordinate = a_textureCoordinate;\n        v_textureIndex = a_textureIndex;\n\n        // flip y\n        gl_Position = vec4(clip_space * vec2(1.0, -1.0), 0, 1);\n      }\n    ",fragment:t=>`\n      #define txUnits ${t}\n      # ifdef GL_FRAGMENT_PRESICISON_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      uniform vec2 u_resolution;\n      uniform sampler2D u_image;\n      uniform sampler2D u_textures[txUnits];\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoordinate;\n      varying float v_textureIndex;\n\n      vec4 sampleFromTexture(sampler2D textures[${t}], int idx, vec2 uv) {\n        ${Array.from(Array(t).keys()).map((t=>`\n          ${0!==t?"else ":""}if (idx == ${t}) {\n            return texture2D(textures[${t}], uv);\n          }\n        `)).join("")}\n        return texture2D(textures[0], uv);\n      }\n\n      void main(){\n        gl_FragColor = vec4(v_color) * sampleFromTexture(u_textures, int(v_textureIndex), v_textureCoordinate);\n      }\n    `}}class E{priority=1;name="";ref;target;passParameters="";declaredUniforms="";uniformInfo={};static uniforms={};static methods;static onShaderMask;static onColorize;static onEffectMask;static getEffectKey(t){return""}static getMethodParameters(t,e){const r=[];for(const s in t){const o=t[s];let n="";o.size&&(n=`[${o.size(e)}]`),r.push(`${o.type} ${s}${n}`)}return r.join(",")}constructor(t){const{ref:e,target:r,props:s={}}=t;this.ref=e,this.target=r;const o={},n=[];let i="";const a=this.constructor.uniforms||{};for(const l in a){const t=a[l],r=t.type,c=`${e}_${l}`;let h="";t.size&&(h=`[${t.size(s)}]`),n.push(c),i+=`uniform ${r} ${c}${h};`,o[l]={name:c,uniform:a[l].method}}this.passParameters=n.join(","),this.declaredUniforms=i,this.uniformInfo=o}static resolveDefaults(t){return{}}static makeEffectKey(t){return!1}}class M extends E{static z$__type__Props;name="radius";static getEffectKey(){return"radius"}static uniforms={radius:{value:0,method:"uniform4fv",type:"vec4",validator:t=>{let e=t;return Array.isArray(e)?2===e.length?e=[e[0],e[1],e[0],e[1]]:3===e.length?e=[e[0],e[1],e[2],e[0]]:4!==e.length&&(e=[e[0],e[0],e[0],e[0]]):"number"==typeof e&&(e=[e,e,e,e]),e}}};static methods={fillMask:"\n      float function(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n    ",boxDist:"\n      float function(vec2 p, vec2 size, float radius) {\n        size -= vec2(radius);\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n      }\n    "};static resolveDefaults(t){return{radius:t.radius??10}}static onShaderMask="\n  vec2 halfDimensions = u_dimensions * 0.5;\n  float r = radius[0] * step(v_textureCoordinate.x, 0.5) * step(v_textureCoordinate.y, 0.5);\n  r = r + radius[1] * step(0.5, v_textureCoordinate.x) * step(v_textureCoordinate.y, 0.5);\n  r = r + radius[2] * step(0.5, v_textureCoordinate.x) * step(0.5, v_textureCoordinate.y);\n  r = r + radius[3] * step(v_textureCoordinate.x, 0.5) * step(0.5, v_textureCoordinate.y);\n  return $boxDist(v_textureCoordinate.xy * u_dimensions - halfDimensions, halfDimensions, r);\n  ";static onEffectMask="\n  return mix(vec4(0.0), maskColor, $fillMask(shaderMask));\n  "}class F extends E{static z$__type__Props;name="border";static getEffectKey(){return"border"}static resolveDefaults(t){return{width:t.width??10,color:t.color??4294967295}}static uniforms={width:{value:0,method:"uniform1f",type:"float"},color:{value:4294967295,validator:t=>a(t),method:"uniform4fv",type:"vec4"}};static onEffectMask="\n  float mask = clamp(shaderMask + width, 0.0, 1.0) - clamp(shaderMask, 0.0, 1.0);\n  return mix(shaderColor, maskColor, mask);\n  ";static onColorize="\n    return color;\n  "}class O extends E{static z$__type__Props;name="linearGradient";static getEffectKey(t){return`linearGradient${t.colors.length}`}static resolveDefaults(t){const e=t.colors??[4278190080,4294967295];let r=t.stops;if(!r){r=[];const t=e.length-1;for(let s=0;s<e.length;s++)r.push(s*(1/t))}return{colors:e,stops:r,angle:t.angle??0}}static uniforms={angle:{value:0,method:"uniform1f",type:"float"},colors:{value:4294967295,validator:t=>t.map((t=>a(t))).reduce(((t,e)=>t.concat(e)),[]),size:t=>t.colors.length,method:"uniform4fv",type:"vec4"},stops:{value:[],validator:(t,e)=>{const r=e.colors??[];let s=t;const o=t;if(0===s.length||s&&s.length!==r.length){for(let t=0;t<r.length;t++)s[t]?(o[t]=s[t],void 0===s[t-1]&&void 0!==o[t-2]&&(o[t-1]=o[t-2]+(s[t]-o[t-2])/2)):o[t]=t*(1/(r.length-1));s=o}return o},size:t=>t.colors.length,method:"uniform1fv",type:"float"}};static methods={fromLinear:"\n      vec4 function(vec4 linearRGB) {\n        vec4 higher = vec4(1.055)*pow(linearRGB, vec4(1.0/2.4)) - vec4(0.055);\n        vec4 lower = linearRGB * vec4(12.92);\n        return mix(higher, lower, 1.0);\n      }\n    ",toLinear:"\n      vec4 function(vec4 sRGB) {\n        vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));\n        vec4 lower = sRGB/vec4(12.92);\n        return mix(higher, lower, 1.0);\n      }\n    ",calcPoint:"\n      vec2 function(float d, float angle) {\n        return d * vec2(cos(angle), sin(angle)) + (u_dimensions * 0.5);\n      }\n    "};static ColorLoop=t=>{let e="";for(let r=2;r<t;r++)e+=`colorOut = mix(colorOut, colors[${r}], clamp((dist - stops[${r-1}]) / (stops[${r}] - stops[${r-1}]), 0.0, 1.0));`;return e};static onColorize=t=>`\n      float a = angle - (PI / 180.0 * 90.0);\n      float lineDist = abs(u_dimensions.x * cos(a)) + abs(u_dimensions.y * sin(a));\n      vec2 f = $calcPoint(lineDist * 0.5, a);\n      vec2 t = $calcPoint(lineDist * 0.5, a + PI);\n      vec2 gradVec = t - f;\n      float dist = dot(v_textureCoordinate.xy * u_dimensions - f, gradVec) / dot(gradVec, gradVec);\n\n      float stopCalc = (dist - stops[0]) / (stops[1] - stops[0]);\n      vec4 colorOut = $fromLinear(mix($toLinear(colors[0]), $toLinear(colors[1]), stopCalc));\n      for(int i = 1; i < ${t.colors.length||1}-1; i++) {\n        stopCalc = (dist - stops[i]) / (stops[i + 1] - stops[i]);\n        colorOut = mix(colorOut, colors[i + 1], clamp(stopCalc, 0.0, 1.0));\n      }\n      return mix(maskColor, colorOut, clamp(colorOut.a, 0.0, 1.0));\n    `}class z extends E{name="grayscale";static getEffectKey(){return"grayscale"}static onColorize="\n    vec3 color = pow(maskColor.rgb, vec3(2.0));\n    float gray = dot(color, vec3(0.2126, 0.7152, 0.0722));\n    float gammaGray = sqrt(gray);\n    return vec4(gammaGray, gammaGray, gammaGray, 1.0);\n  "}class D extends E{static z$__type__Props;name="borderRight";static getEffectKey(){return"borderRight"}static resolveDefaults(t){return{width:t.width??10,color:t.color??4294967295}}static uniforms={width:{value:0,method:"uniform1f",type:"float"},color:{value:4294967295,validator:t=>a(t),method:"uniform4fv",type:"vec4"}};static methods={fillMask:"\n      float function(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n    ",rectDist:"\n      float function(vec2 p, vec2 size) {\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n      }\n    "};static onEffectMask="\n  vec2 pos = vec2(u_dimensions.x - width * 0.5, 0.0);\n  float mask = $rectDist(v_textureCoordinate.xy * u_dimensions - pos, vec2(width*0.5, u_dimensions.y));\n  return mix(shaderColor, maskColor, $fillMask(mask));\n  ";static onColorize="\n    return color;\n  "}class A extends E{static z$__type__Props;name="borderTop";static getEffectKey(){return"borderTop"}static resolveDefaults(t){return{width:t.width??10,color:t.color??4294967295}}static uniforms={width:{value:0,method:"uniform1f",type:"float"},color:{value:4294967295,validator:t=>a(t),method:"uniform4fv",type:"vec4"}};static methods={fillMask:"\n      float function(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n    ",rectDist:"\n      float function(vec2 p, vec2 size) {\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n      }\n    "};static onEffectMask="\n  vec2 pos = vec2(0.0, width * 0.5);\n  float mask = $rectDist(v_textureCoordinate.xy * u_dimensions - pos, vec2(u_dimensions.x, width*0.5));\n  return mix(shaderColor, maskColor, $fillMask(mask));\n  ";static onColorize="\n    return color;\n  "}class $ extends E{static z$__type__Props;name="borderBottom";static getEffectKey(){return"borderBottom"}static resolveDefaults(t){return{width:t.width??10,color:t.color??4294967295}}static uniforms={width:{value:0,method:"uniform1f",type:"float"},color:{value:4294967295,validator:t=>a(t),method:"uniform4fv",type:"vec4"}};static methods={fillMask:"\n      float function(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n    ",rectDist:"\n      float function(vec2 p, vec2 size) {\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n      }\n    "};static onEffectMask="\n  vec2 pos = vec2(0.0, u_dimensions.y - width * 0.5);\n  float mask = $rectDist(v_textureCoordinate.xy * u_dimensions - pos, vec2(u_dimensions.x, width*0.5));\n  return mix(shaderColor, maskColor, $fillMask(mask));\n  ";static onColorize="\n    return color;\n  "}class P extends E{static z$__type__Props;name="borderLeft";static getEffectKey(){return"borderLeft"}static resolveDefaults(t){return{width:t.width??10,color:t.color??4294967295}}static uniforms={width:{value:0,method:"uniform1f",type:"float"},color:{value:4294967295,validator:t=>a(t),method:"uniform4fv",type:"vec4"}};static methods={fillMask:"\n      float function(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n    ",rectDist:"\n      float function(vec2 p, vec2 size) {\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n      }\n    "};static onEffectMask="\n  vec2 pos = vec2(width * 0.5, 0.0);\n  float mask = $rectDist(v_textureCoordinate.xy * u_dimensions - pos, vec2(width*0.5, u_dimensions.y));\n  return mix(shaderColor, maskColor, $fillMask(mask));\n  ";static onColorize="\n    return color;\n  "}class j extends E{static z$__type__Props;name="glitch";static getEffectKey(t){return"glitch"}static resolveDefaults(t){return{amplitude:t.amplitude??.2,narrowness:t.narrowness??4,blockiness:t.blockiness??2,minimizer:t.minimizer??8,time:t.time??Date.now()}}static uniforms={amplitude:{value:0,method:"uniform1f",type:"float"},narrowness:{value:0,method:"uniform1f",type:"float"},blockiness:{value:0,method:"uniform1f",type:"float"},minimizer:{value:0,method:"uniform1f",type:"float"},time:{value:0,method:"uniform1f",validator:t=>(Date.now()-t)%1e3,type:"float"}};static methods={rand:"\n      float function(vec2 p, float time) {\n        float t = floor(time * 20.) / 10.;\n        return fract(sin(dot(p, vec2(t * 12.9898, t * 78.233))) * 43758.5453);\n      }\n    ",noise:"\n      float function(vec2 uv, float blockiness, float time) {\n        vec2 lv = fract(uv);\n        vec2 id = floor(uv);\n\n        float n1 = rand(id, time);\n        float n2 = rand(id+vec2(1,0), time);\n        float n3 = rand(id+vec2(0,1), time);\n        float n4 = rand(id+vec2(1,1), time);\n        vec2 u = smoothstep(0.0, 1.0 + blockiness, lv);\n        return mix(mix(n1, n2, u.x), mix(n3, n4, u.x), u.y);\n      }\n    ",fbm:"\n      float function(vec2 uv, int count, float blockiness, float complexity, float time) {\n        float val = 0.0;\n        float amp = 0.5;\n        const int MAX_ITERATIONS = 10;\n\n        for(int i = 0; i < MAX_ITERATIONS; i++) {\n          if(i >= count) {break;}\n          val += amp * noise(uv, blockiness, time);\n          amp *= 0.5;\n          uv *= complexity;\n        }\n        return val;\n      }\n    "};static onColorize="\n    vec2 uv = v_textureCoordinate.xy;\n    float aspect = u_dimensions.x / u_dimensions.y;\n    vec2 a = vec2(uv.x * aspect , uv.y);\n    vec2 uv2 = vec2(a.x / u_dimensions.x, exp(a.y));\n\n    float shift = amplitude * pow($fbm(uv2, 4, blockiness, narrowness, time), minimizer);\n    float colR = texture2D(u_texture, vec2(uv.x + shift, uv.y)).r * (1. - shift);\n    float colG = texture2D(u_texture, vec2(uv.x - shift, uv.y)).g * (1. - shift);\n    float colB = texture2D(u_texture, vec2(uv.x - shift, uv.y)).b * (1. - shift);\n\n    vec3 f = vec3(colR, colG, colB);\n    return vec4(f, texture2D(u_texture, vec2(uv.x - shift, uv.y)).a);\n  "}class B extends E{static z$__type__Props;name="fadeOut";static getEffectKey(){return"fadeOut"}static uniforms={fade:{value:0,method:"uniform4fv",type:"vec4",validator:t=>{let e=t;return Array.isArray(e)?2===e.length?e=[e[0],e[1],e[0],e[1]]:3===e.length?e=[e[0],e[1],e[2],e[0]]:4!==e.length&&(e=[e[0],e[0],e[0],e[0]]):"number"==typeof e&&(e=[e,e,e,e]),e}}};static resolveDefaults(t){return{fade:t.fade??10}}static onColorize="\n  vec2 point = v_textureCoordinate.xy * u_dimensions.xy;\n  vec2 pos1;\n  vec2 pos2;\n  vec2 d;\n  float c;\n  vec4 result = maskColor;\n\n\n  if(fade[0] > 0.0) {\n    pos1 = vec2(point.x, point.y);\n    pos2 = vec2(point.x, point.y + fade[0]);\n    d = pos2 - pos1;\n    c = dot(pos1, d) / dot(d, d);\n    result = mix(vec4(0.0), result, smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0)));\n  }\n\n  if(fade[1] > 0.0) {\n    pos1 = vec2(point.x - u_dimensions.x - fade[1], v_textureCoordinate.y);\n    pos2 = vec2(point.x - u_dimensions.x, v_textureCoordinate.y);\n    d = pos1 - pos2;\n    c = dot(pos2, d) / dot(d, d);\n    result = mix(vec4(0.0), result, smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0)));\n  }\n\n  if(fade[2] > 0.0) {\n    pos1 = vec2(v_textureCoordinate.x, point.y - u_dimensions.y - fade[2]);\n    pos2 = vec2(v_textureCoordinate.x, point.y - u_dimensions.y);\n    d = pos1 - pos2;\n    c = dot(pos2, d) / dot(d, d);\n    result = mix(vec4(0.0), result, smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0)));\n  }\n\n  if(fade[3] > 0.0) {\n    pos1 = vec2(point.x, point.y);\n    pos2 = vec2(point.x + fade[3], point.y);\n    d = pos2 - pos1;\n    c = dot(pos1, d) / dot(d, d);\n    result = mix(vec4(0.0), result, smoothstep(0.0, 1.0, clamp(c, 0.0, 1.0)));\n  }\n\n  return result;\n  "}class L extends E{static z$__type__Props;name="radialGradient";static getEffectKey(t){return`radialGradient${t.colors.length}`}static resolveDefaults(t){const e=t.colors??[4278190080,4294967295];let r=t.stops;if(!r){r=[];const t=e.length-1;for(let s=0;s<e.length;s++)r.push(s*(1/t))}return{colors:e,stops:r,width:t.width??0,height:t.height??t.width??0,pivot:t.pivot??[.5,.5]}}static uniforms={width:{value:0,method:"uniform1f",type:"float"},height:{value:0,method:"uniform1f",type:"float"},pivot:{value:[.5,.5],method:"uniform2fv",type:"vec2"},colors:{value:4294967295,validator:t=>t.map((t=>a(t))).reduce(((t,e)=>t.concat(e)),[]),size:t=>t.colors.length,method:"uniform4fv",type:"vec4"},stops:{value:[],validator:(t,e)=>{const r=e.colors??[];let s=t;const o=t;if(0===s.length||s&&s.length!==r.length){for(let t=0;t<r.length;t++)s[t]?(o[t]=s[t],void 0===s[t-1]&&void 0!==o[t-2]&&(o[t-1]=o[t-2]+(s[t]-o[t-2])/2)):o[t]=t*(1/(r.length-1));s=o}return o},size:t=>t.colors.length,method:"uniform1fv",type:"float"}};static onColorize=t=>`\n      vec2 point = v_textureCoordinate.xy * u_dimensions;\n      vec2 projection = vec2(pivot.x * u_dimensions.x, pivot.y * u_dimensions.y);\n\n      float dist = length((point - projection) / vec2(width, height));\n\n      float stopCalc = (dist - stops[0]) / (stops[1] - stops[0]);\n      vec4 colorOut = mix(colors[0], colors[1], stopCalc);\n      for(int i = 1; i < ${t.colors.length||1}-1; i++) {\n        stopCalc = (dist - stops[i]) / (stops[i + 1] - stops[i]);\n        colorOut = mix(colorOut, colors[i + 1], clamp(stopCalc, 0.0, 1.0));\n      }\n      return mix(maskColor, colorOut, clamp(colorOut.a, 0.0, 1.0));\n    `}const Y={radius:M,border:F,borderBottom:$,borderLeft:P,borderRight:D,borderTop:A,fadeOut:B,linearGradient:O,radialGradient:L,grayscale:z,glitch:j};class X extends i{effects=[];constructor(t,e,r){const s=X.createShader(e,r);super({renderer:t,attributes:["a_position","a_textureCoordinate","a_color"],uniforms:[{name:"u_resolution",uniform:"uniform2fv"},{name:"u_pixelRatio",uniform:"uniform1f"},{name:"u_texture",uniform:"uniform2fv"},{name:"u_dimensions",uniform:"uniform2fv"},{name:"u_alpha",uniform:"uniform1f"},...s.uniforms],shaderSources:{vertex:s.vertex,fragment:s.fragment}}),this.effects=s.effects}bindTextures(t){const{gl:e}=this;e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,t[0].ctxTexture)}bindProps(t){t.effects?.forEach(((t,e)=>{const r=this.effects[e],s=Y[r.name],o=t.props??{},n=r.uniformInfo;Object.keys(o).forEach((t=>{const e=s.uniforms[t],r=n[t];let i=e.validator?e.validator(o[t],o):o[t];Array.isArray(i)&&(i=new Float32Array(i)),this.setUniform(r.name,i)}))}))}static createShader(t,e){const r={},s={};let o="";const n=[],i=[],a=t.effects.map((t=>{const s=e[t.type],a=s.getEffectKey(t.props||{});r[a]=r[a]?++r[a]:1;const l=r[a];1===l&&i.push({key:a,type:t.type,props:t.props});const c=new s({ref:`${a}${1===l?"":l}`,target:a,props:t.props});return o+=c.declaredUniforms,n.push(...Object.values(c.uniformInfo)),c}));let l="";i?.forEach((t=>{const r=e[t.type],o=r.resolveDefaults(t.props??{}),n=[];for(const e in r.methods){let t=e;const o=r.methods[e];s[e]&&s[e]!==o&&(t=X.resolveMethodDuplicate(e,o,s)),s[t]=o.replace("function",t),n.push({m:e,cm:t})}let i=r.onShaderMask instanceof Function?r.onShaderMask(o):r.onShaderMask,a=r.onColorize instanceof Function?r.onColorize(o):r.onColorize,c=r.onEffectMask instanceof Function?r.onEffectMask(o):r.onEffectMask;n.forEach((t=>{const{m:e,cm:r}=t,s=new RegExp(`\\$${e}`,"g");i&&(i=i.replace(s,r)),a&&(a=a.replace(s,r)),c&&(c=c.replace(s,r))}));const h=r.getMethodParameters(r.uniforms,o),d=h.length>0?`, ${h}`:"";i&&(l+=`\n        float fx_${t.key}_onShaderMask(float shaderMask ${d}) {\n          ${i}\n        }\n        `),a&&(l+=`\n          vec4 fx_${t.key}_onColorize(float shaderMask, vec4 maskColor, vec4 shaderColor${d}) {\n            ${a}\n          }\n        `),c&&(l+=`\n          vec4 fx_${t.key}_onEffectMask(float shaderMask, vec4 maskColor, vec4 shaderColor${d}) {\n            ${c}\n          }\n        `)}));let c="";for(const u in s)c+=s[u];let h="mix(shaderColor, maskColor, clamp(-(lng_DefaultMask), 0.0, 1.0))",d="\n\n    ";for(let u=0;u<a.length;u++){const t=a[u],e=t.passParameters.length>0?`, ${t.passParameters}`:"",r=Y[t.name];r.onShaderMask&&(d+=`\n        shaderMask = fx_${t.target}_onShaderMask(shaderMask ${e});\n        `),r.onColorize&&(d+=`\n        maskColor = fx_${t.target}_onColorize(shaderMask, maskColor, shaderColor${e});\n        `),r.onEffectMask&&(h=`fx_${t.target}_onEffectMask(shaderMask, maskColor, shaderColor${e})`);const s=a[u+1];(void 0===s||Y[s.name].onEffectMask)&&(d+=`\n          shaderColor = ${h};\n        `)}return{effects:a,uniforms:n,fragment:X.fragment(o,c,l,d),vertex:X.vertex()}}static resolveMethodDuplicate(t,e,r,s=0){const o=t+(s>0?s:"");return r[o]&&r[o]!==e?this.resolveMethodDuplicate(t,e,r,++s):o}static resolveDefaults(t,e){return{effects:(t.effects??[]).map((t=>({type:t.type,props:e[t.type].resolveDefaults(t.props||{})}))),$dimensions:{width:0,height:0},$alpha:0}}static makeCacheKey(t,e){let r="";return t.effects?.forEach((t=>{const s=e[t.type].getEffectKey(t.props||{});r+=`,${s}`})),`DynamicShader${r}`}static z$__type__Props;static vertex=()=>"\n    # ifdef GL_FRAGMENT_PRESICISON_HIGH\n    precision highp float;\n    # else\n    precision mediump float;\n    # endif\n\n    attribute vec2 a_textureCoordinate;\n    attribute vec2 a_position;\n    attribute vec4 a_color;\n    attribute float a_textureIndex;\n\n    uniform vec2 u_resolution;\n    uniform float u_pixelRatio;\n\n    varying vec4 v_color;\n    varying vec2 v_textureCoordinate;\n    varying float v_textureIndex;\n\n    void main(){\n      vec2 normalized = a_position * u_pixelRatio / u_resolution;\n      vec2 zero_two = normalized * 2.0;\n      vec2 clip_space = zero_two - 1.0;\n\n      // pass to fragment\n      v_color = a_color;\n      v_textureCoordinate = a_textureCoordinate;\n      v_textureIndex = a_textureIndex;\n\n      // flip y\n      gl_Position = vec4(clip_space * vec2(1.0, -1.0), 0, 1);\n    }\n  ";static fragment=(t,e,r,s)=>`\n    # ifdef GL_FRAGMENT_PRESICISON_HIGH\n    precision highp float;\n    # else\n    precision mediump float;\n    # endif\n\n    #define PI 3.14159265359\n\n    uniform vec2 u_resolution;\n    uniform vec2 u_dimensions;\n    uniform float u_alpha;\n    uniform float u_radius;\n    uniform sampler2D u_texture;\n    uniform float u_pixelRatio;\n\n    ${t}\n\n    varying vec4 v_color;\n    varying vec2 v_textureCoordinate;\n\n    ${e}\n\n    ${r}\n\n    void main() {\n      vec2 p = v_textureCoordinate.xy * u_dimensions - u_dimensions * 0.5;\n      vec2 d = abs(p) - (u_dimensions) * 0.5;\n      float lng_DefaultMask = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n\n      vec4 shaderColor = vec4(0.0);\n      float shaderMask = lng_DefaultMask;\n\n      vec4 maskColor = texture2D(u_texture, v_textureCoordinate) * v_color;\n\n      shaderColor = mix(shaderColor, maskColor, clamp(-(lng_DefaultMask + 0.5), 0.0, 1.0));\n\n      ${s}\n\n      gl_FragColor = shaderColor * u_alpha;\n    }\n  `}class W extends i{constructor(t){super({renderer:t,attributes:["a_position","a_textureCoordinate","a_color"],uniforms:[{name:"u_resolution",uniform:"uniform2fv"},{name:"u_pixelRatio",uniform:"uniform1f"},{name:"u_texture",uniform:"uniform2f"},{name:"u_dimensions",uniform:"uniform2fv"},{name:"u_radius",uniform:"uniform1f"}]})}static z$__type__Props;static resolveDefaults(t){return{radius:t.radius||10,$dimensions:{width:0,height:0}}}bindTextures(t){const{gl:e}=this;e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,t[0].ctxTexture)}bindProps(t){this.setUniform("u_radius",t.radius)}canBatchShaderProps(t,e){return t.radius===e.radius&&t.$dimensions.width===e.$dimensions.width&&t.$dimensions.height===e.$dimensions.height}static shaderSources={vertex:"\n      # ifdef GL_FRAGMENT_PRESICISON_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      attribute vec2 a_position;\n      attribute vec2 a_textureCoordinate;\n      attribute vec4 a_color;\n      attribute float a_textureIndex;\n      attribute float a_depth;\n\n      uniform vec2 u_resolution;\n      uniform float u_pixelRatio;\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoordinate;\n\n      void main() {\n        vec2 normalized = a_position * u_pixelRatio / u_resolution;\n        vec2 zero_two = normalized * 2.0;\n        vec2 clip_space = zero_two - 1.0;\n\n        // pass to fragment\n        v_color = a_color;\n        v_textureCoordinate = a_textureCoordinate;\n\n        // flip y\n        gl_Position = vec4(clip_space * vec2(1.0, -1.0), 0, 1);\n      }\n    ",fragment:"\n      # ifdef GL_FRAGMENT_PRESICISON_HIGH\n      precision highp float;\n      # else\n      precision mediump float;\n      # endif\n\n      uniform vec2 u_resolution;\n      uniform vec2 u_dimensions;\n      uniform float u_radius;\n      uniform sampler2D u_texture;\n\n      varying vec4 v_color;\n      varying vec2 v_textureCoordinate;\n\n      float boxDist(vec2 p, vec2 size, float radius){\n        size -= vec2(radius);\n        vec2 d = abs(p) - size;\n        return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n      }\n\n      float fillMask(float dist) {\n        return clamp(-dist, 0.0, 1.0);\n      }\n\n      void main() {\n        vec4 color = texture2D(u_texture, v_textureCoordinate) * v_color;\n        vec2 halfDimensions = u_dimensions * 0.5;\n\n        float d = boxDist(v_textureCoordinate.xy * u_dimensions - halfDimensions, halfDimensions + 0.5, u_radius);\n        gl_FragColor = mix(vec4(0.0), color, fillMask(d));\n      }\n    "}}const N=new Float32Array([1,0,0,0,1,0,0,0,1]);class H extends i{constructor(t){super({renderer:t,attributes:["a_position","a_textureCoordinate"],uniforms:[{name:"u_resolution",uniform:"uniform2fv"},{name:"u_transform",uniform:"uniformMatrix3fv"},{name:"u_scrollY",uniform:"uniform1f"},{name:"u_pixelRatio",uniform:"uniform1f"},{name:"u_texture",uniform:"uniform2f"},{name:"u_color",uniform:"uniform4fv"},{name:"u_size",uniform:"uniform1f"},{name:"u_distanceRange",uniform:"uniform1f"},{name:"u_debug",uniform:"uniform1i"}]})}bindTextures(t){const{gl:e}=this;e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,t[0].ctxTexture)}bindProps(t){const e=H.resolveDefaults(t);for(const r in e)if("transform"===r)this.setUniform("u_transform",!1,e[r]);else if("scrollY"===r)this.setUniform("u_scrollY",e[r]);else if("color"===r){const t=a(e.color);this.setUniform("u_color",t)}else"size"===r?this.setUniform("u_size",e[r]):"distanceRange"===r?this.setUniform("u_distanceRange",e[r]):"debug"===r&&this.setUniform("u_debug",e[r]?1:0)}static resolveDefaults(t={}){return{transform:t.transform??N,scrollY:t.scrollY??0,color:t.color??4294967295,size:t.size??16,distanceRange:t.distanceRange??1,debug:t.debug??!1}}static shaderSources={vertex:"\n      // an attribute is an input (in) to a vertex shader.\n      // It will receive data from a buffer\n      attribute vec2 a_position;\n      attribute vec2 a_textureCoordinate;\n\n      uniform vec2 u_resolution;\n      uniform mat3 u_transform;\n      uniform float u_scrollY;\n      uniform float u_pixelRatio;\n      uniform float u_size;\n\n      varying vec2 v_texcoord;\n\n      void main() {\n        vec2 scrolledPosition = a_position * u_size - vec2(0, u_scrollY);\n        vec2 transformedPosition = (u_transform * vec3(scrolledPosition, 1)).xy;\n        gl_Position = vec4((transformedPosition * u_pixelRatio / u_resolution * 2.0 - 1.0) * vec2(1, -1), 0, 1);\n        v_texcoord = a_textureCoordinate;\n      }\n    ",fragment:"\n      precision highp float;\n\n      uniform vec4 u_color;\n      uniform sampler2D u_texture;\n      uniform float u_distanceRange;\n      uniform float u_pixelRatio;\n      uniform int u_debug;\n\n      varying vec2 v_texcoord;\n\n      float median(float r, float g, float b) {\n          return max(min(r, g), min(max(r, g), b));\n      }\n\n      void main() {\n          vec3 sample = texture2D(u_texture, v_texcoord).rgb;\n          if (u_debug == 1) {\n            gl_FragColor = vec4(sample.r, sample.g, sample.b, 1.0);\n            return;\n          }\n          float scaledDistRange = u_distanceRange * u_pixelRatio;\n          float sigDist = scaledDistRange * (median(sample.r, sample.g, sample.b) - 0.5);\n          float opacity = clamp(sigDist + 0.5, 0.0, 1.0) * u_color.a;\n\n          // Build the final color.\n          // IMPORTANT: We must premultiply the color by the alpha value before returning it.\n          gl_FragColor = vec4(u_color.r * opacity, u_color.g * opacity, u_color.b * opacity, opacity);\n      }\n    "}}class U{shCache=new Map;shConstructors={};attachedShader=null;effectConstructors={};renderer;constructor(){this.registerShaderType("DefaultShader",I),this.registerShaderType("DefaultShaderBatched",k),this.registerShaderType("RoundedRectangle",W),this.registerShaderType("DynamicShader",X),this.registerShaderType("SdfShader",H),this.registerEffectType("border",F),this.registerEffectType("borderBottom",$),this.registerEffectType("borderLeft",P),this.registerEffectType("borderRight",D),this.registerEffectType("borderTop",A),this.registerEffectType("fadeOut",B),this.registerEffectType("linearGradient",O),this.registerEffectType("radialGradient",L),this.registerEffectType("grayscale",z),this.registerEffectType("glitch",j),this.registerEffectType("radius",M)}registerShaderType(t,e){this.shConstructors[t]=e}registerEffectType(t,e){this.effectConstructors[t]=e}loadShader(t,e){if(!this.renderer)throw new Error("Renderer is not been defined");const r=this.shConstructors[t];if(!r)throw new Error(`Shader type "${t}" is not registered`);if("DynamicShader"===t)return this.loadDynamicShader(e);const s=r.resolveDefaults(e),o=r.makeCacheKey(s)||r.name;if(o&&this.shCache.has(o))return{shader:this.shCache.get(o),props:s};const n=new r(this.renderer,e);return o&&this.shCache.set(o,n),{shader:n,props:s}}loadDynamicShader(t){if(!this.renderer)throw new Error("Renderer is not been defined");const e=X.resolveDefaults(t,this.effectConstructors),r=X.makeCacheKey(e,this.effectConstructors);if(r&&this.shCache.has(r))return{shader:this.shCache.get(r),props:e};const s=new X(this.renderer,t,this.effectConstructors);return r&&this.shCache.set(r,s),{shader:s,props:e}}useShader(t){this.attachedShader!==t&&(this.attachedShader&&this.attachedShader.detach(),t.attach(),this.attachedShader=t)}}class G{activeAnimations=new Set;registerAnimation(t){this.activeAnimations.add(t)}unregisterAnimation(t){this.activeAnimations.delete(t)}update(t){this.activeAnimations.forEach((e=>{e.update(t)}))}}class K extends l{props;constructor(t,e){super(t),this.props=K.resolveDefaults(e)}async getTextureData(){const{src:t,premultiplyAlpha:e}=this.props;if(!t)return{data:null};if(t instanceof ImageData)return{data:t,premultiplyAlpha:e};const r=await fetch(t),s=await r.blob();return{data:await createImageBitmap(s,{premultiplyAlpha:e?"premultiply":"none",colorSpaceConversion:"none",imageOrientation:"none"})}}static makeCacheKey(t){const e=K.resolveDefaults(t);return!(e.src instanceof ImageData)&&`ImageTexture,${e.src},${e.premultiplyAlpha}`}static resolveDefaults(t){return{src:t.src??"",premultiplyAlpha:t.premultiplyAlpha??!0}}static z$__type__Props}class Q extends l{props;constructor(t,e){super(t),this.props=Q.resolveDefaults(e)}async getTextureData(){const{width:t,height:e}=this.props,r=t*e*4,s=new Uint8ClampedArray(r);for(let o=0;o<r;o+=4){const t=Math.floor(256*Math.random());s[o]=t,s[o+1]=t,s[o+2]=t,s[o+3]=255}return{data:new ImageData(s,t,e)}}static makeCacheKey(t){const e=Q.resolveDefaults(t);return`NoiseTexture,${e.width},${e.height},${e.cacheId}`}static resolveDefaults(t){return{width:t.width??128,height:t.height??128,cacheId:t.cacheId??0}}static z$__type__Props}class V{usedMemory=0;txConstructors={};textureKeyCache=new Map;textureIdCache=new Map;ctxTextureCache=new WeakMap;textureRefCountMap=new WeakMap;renderer;constructor(){this.registerTextureType("ImageTexture",K),this.registerTextureType("ColorTexture",c),this.registerTextureType("NoiseTexture",Q),this.registerTextureType("SubTexture",h)}registerTextureType(t,e){this.txConstructors[t]=e}loadTexture(t,e,r=null){const s=this.txConstructors[t];if(!s)throw new Error(`Texture type "${t}" is not registered`);let o;if(void 0!==r?.id&&this.textureIdCache.has(r.id)&&(o=this.textureIdCache.get(r.id)),!o){const t=r?.id,n=r?.cacheKey??s.makeCacheKey(e);o=n&&this.textureKeyCache.has(n)?this.textureKeyCache.get(n):new s(this,e),t&&this.addTextureIdToCache(t,n,o)}return r?.preload&&this.getCtxTexture(o).load(),o}addTextureIdToCache(t,e,r){const{textureIdCache:s,textureRefCountMap:o}=this;s.set(t,r),o.has(r)?o.get(r).count++:(o.set(r,{cacheKey:e,count:1}),e&&this.textureKeyCache.set(e,r))}removeTextureIdFromCache(t){const{textureIdCache:e,textureRefCountMap:r}=this,s=e.get(t);if(s&&(e.delete(t),r.has(s))){const t=r.get(s);n(t),t.count--,0===t.count&&(r.delete(s),t.cacheKey&&this.textureKeyCache.delete(t.cacheKey))}}getDebugInfo(){return{keyCacheSize:this.textureKeyCache.size,idCacheSize:this.textureIdCache.size}}getCtxTexture(t){if(this.ctxTextureCache.has(t))return this.ctxTextureCache.get(t);const e=this.renderer.createCtxTexture(t);return this.ctxTextureCache.set(t,e),e}}class q{textRenderers;constructor(t){this.textRenderers=t}addFontFace(t){for(const e in this.textRenderers){const r=this.textRenderers[e];r&&r.isFontFaceSupported(t)&&r.addFontFace(t)}}static resolveFontFace(t,e){return t.reduce(((t,r)=>{if(t)return t;const s=r[e.fontFamily];if(!s)return;const o=new Set(s);for(const n of o)n.descriptors.stretch===e.fontStretch&&n.descriptors.style===e.fontStyle&&n.descriptors.weight===e.fontWeight||o.delete(n);return o.values().next().value}),void 0)||[][0]}}const Z={x:(t,e)=>{t.props.x=e},y:(t,e)=>{t.props.y=e},width:(t,e)=>{t.props.width=e},height:(t,e)=>{t.props.height=e},color:(t,e)=>{t.props.color=e},zIndex:(t,e)=>{t.props.zIndex=e},fontFamily:(t,e)=>{t.props.fontFamily=e},fontWeight:(t,e)=>{t.props.fontWeight=e},fontStyle:(t,e)=>{t.props.fontStyle=e},fontStretch:(t,e)=>{t.props.fontStretch=e},fontSize:(t,e)=>{t.props.fontSize=e},scaleX:(t,e)=>{t.props.scaleX=e},scaleY:(t,e)=>{t.props.scaleY=e},text:(t,e)=>{t.props.text=e},textAlign:(t,e)=>{t.props.textAlign=e},contain:(t,e)=>{t.props.contain=e},offsetY:(t,e)=>{t.props.offsetY=e},scrollable:(t,e)=>{t.props.scrollable=e},scrollY:(t,e)=>{t.props.scrollY=e},letterSpacing:(t,e)=>{t.props.letterSpacing=e},debug:(t,e)=>{t.props.debug=e}};class J{stage;set;constructor(t){this.stage=t,this.set=Object.freeze({...Z,...this.getPropertySetters()})}setStatus(t,e,r){t.status!==e&&(t.status=e,t.emitter.emit(e,r))}}class tt{iterator;peekBuffer=[];_lastIndex;constructor(t,e=0){this.iterator=t,this.iterator=t,this._lastIndex=e-1,this.peekBuffer=[]}next(){const t=this.peekBuffer.length>0?this.peekBuffer.pop():this.iterator.next();return t.done?this._lastIndex=-1:this._lastIndex++,t}peek(){if(this.peekBuffer.length>0)return this.peekBuffer[0];const t=this.iterator.next();return this.peekBuffer.push(t),t}get lastIndex(){return this._lastIndex}}function*et(t,e=0){let r=e;for(;r<t.length;){const e=t.codePointAt(r);if(void 0===e)throw new Error("Invalid Unicode code point");yield e,r+=e<=65535?1:2}}function rt(t,e,r,s,o,i,a,l,c,h,d,u,p,f,m,g){n(f,"Font face must be loaded"),n(f.loaded,"Font face must be loaded"),n(f.data,"Font face must be loaded"),n(f.shaper,"Font face must be loaded");const x=f.data.info.size,y=l/x,v=i/y,_=c/y,b=u[t],w=b?.codepointIndex||0;let S=b?.maxX||0,T=b?.maxY||0,C=e,R=r,I=0;const k={codepointIndex:-1,bufferOffset:-1,xStart:-1},E=f.shaper,M={letterSpacing:_};let F,O=E.shapeText(M,new tt(et(s,w),w)),z=-1;const D=[],A=a/y,$=function(t,e,r){const s=r.shapeText(e,new tt(et(t,0),0));let o=0;for(const n of s)n.mapped&&(o+=n.xAdvance);return o}("...",M,E);let P=!0;for(;P;){const e="both"!==d||g||R+x+x<=A,r=e?v:v-$;let o=0;for(;(F=O.next())&&!F.done;){const n=F.value;if(t===u.length)u.push({codepointIndex:n.cluster,maxY:T,maxX:S});else if(t>u.length)throw new Error("Unexpected lineCache length");if(32===n.codepoint||10===n.codepoint?-1!==k.codepointIndex&&(k.codepointIndex=-1,o=C):-1===k.codepointIndex&&(k.codepointIndex=n.cluster,k.bufferOffset=I,k.xStart=o),n.mapped){const t=C+n.xOffset+n.width;if("none"!==d&&t>=r&&-1!==k.codepointIndex&&k.codepointIndex<n.cluster&&k.xStart>0){if(e){O=E.shapeText(M,new tt(et(s,k.codepointIndex),k.codepointIndex)),I=k.bufferOffset;break}O=E.shapeText(M,new tt(et("...",0),0)),C=k.xStart,I=k.bufferOffset}else{const t=C+n.xOffset,e=R+n.yOffset,r=!p||R+x>=p.y1/y,s=!p||R<=p.y2/y;if(r&&s){-1===z&&(z=I);const r=f.getAtlasEntry(n.glyphId),s=r.x/f.data.common.scaleW,o=r.y/f.data.common.scaleH,i=r.width/f.data.common.scaleW,a=r.height/f.data.common.scaleH;h[I++]=t,h[I++]=e,h[I++]=s,h[I++]=o,h[I++]=t+n.width,h[I++]=e,h[I++]=s+i,h[I++]=o,h[I++]=t,h[I++]=e+n.height,h[I++]=s,h[I++]=o+a,h[I++]=t+n.width,h[I++]=e+n.height,h[I++]=s+i,h[I++]=o+a}T=Math.max(T,e+n.height),C+=n.xAdvance,S=Math.max(S,C)}}else if(10===n.codepoint)break}-1!==z&&(D.push({bufferStart:z,bufferEnd:I}),z=-1),C=0,R+=x,t++,k.codepointIndex=-1,o=0,!m&&"both"===d&&p&&R>p.y2/y||F&&F.done?P=!1:"both"!==d||g||e||(P=!1)}if("center"===o){const t="none"===d?S:v;for(let e=0;e<D.length;e++){const r=D[e],s=(t-(h[r.bufferEnd-4]-h[r.bufferStart]))/2;for(let t=r.bufferStart;t<r.bufferEnd;t+=4)h[t]+=s}}else if("right"===o){const t="none"===d?S:v;for(let e=0;e<D.length;e++){const r=D[e],s=t-(r.bufferEnd===r.bufferStart?0:h[r.bufferEnd-4]-h[r.bufferStart]);for(let t=r.bufferStart;t<r.bufferEnd;t+=4)h[t]+=s}}return n(F),{bufferNumFloats:I,bufferNumQuads:I/16,layoutNumCharacters:F.done?s.length-w:F.value.cluster-w+1,fullyProcessed:!!F.done,maxX:S,maxY:T}}class st extends J{ssdfFontFamilies={};msdfFontFamilies={};sdfShader;constructor(t){super(t),this.sdfShader=this.stage.shManager.loadShader("SdfShader").shader}getPropertySetters(){return{fontFamily:(t,e)=>{t.props.fontFamily=e,t.trFontFace=void 0,this.invalidateCache(t)},fontWeight:(t,e)=>{t.props.fontWeight=e,t.trFontFace=void 0,this.invalidateCache(t)},fontStyle:(t,e)=>{t.props.fontStyle=e,t.trFontFace=void 0,this.invalidateCache(t)},fontStretch:(t,e)=>{t.props.fontStretch=e,t.trFontFace=void 0,this.invalidateCache(t)},fontSize:(t,e)=>{t.props.fontSize=e,this.invalidateCache(t)},text:(t,e)=>{t.props.text=e,this.invalidateCache(t)},textAlign:(t,e)=>{t.props.textAlign=e,this.invalidateCache(t)},color:(t,e)=>{t.props.color=e},x:(t,e)=>{t.props.x=e},y:(t,e)=>{t.props.y=e},contain:(t,e)=>{t.props.contain=e,this.invalidateCache(t)},width:(t,e)=>{t.props.width=e,this.invalidateCache(t)},height:(t,e)=>{t.props.height=e,this.invalidateCache(t)},offsetY:(t,e)=>{t.props.offsetY=e,this.invalidateCache(t)},scrollable:(t,e)=>{t.props.scrollable=e,this.invalidateCache(t)},scrollY:(t,e)=>{t.props.scrollY=e},letterSpacing:(t,e)=>{t.props.letterSpacing=e,this.invalidateCache(t)},debug:(t,e)=>{t.props.debug=e}}}canRenderFont(t){const{fontFamily:e}=t;return e in this.ssdfFontFamilies||e in this.msdfFontFamilies||"$$SDF_FAILURE_TEST$$"===e}isFontFaceSupported(t){return t instanceof u}addFontFace(t){n(t instanceof u);const e=t.fontFamily,r="ssdf"===t.type?this.ssdfFontFamilies:"msdf"===t.type?this.msdfFontFamilies:void 0;if(!r)return void console.warn(`Invalid font face type: ${t.type}`);let s=r[e];s||(s=new Set,r[e]=s),s.add(t)}createState(t){return{props:t,status:"initialState",emitter:new r,lineCache:[],forceFullLayoutCalc:!1,renderWindow:void 0,bufferNumFloats:0,bufferNumQuads:0,vertexBuffer:void 0,webGlBuffers:null,bufferUploaded:!1,textH:void 0,textW:void 0,distanceRange:0,trFontFace:void 0,debugData:{updateCount:0,layoutCount:0,lastLayoutNumCharacters:0,layoutSum:0,drawSum:0,drawCount:0,bufferSize:0}}}updateState(t){performance.now();let{trFontFace:e}=t;const{textH:r,lineCache:s,debugData:o,forceFullLayoutCalc:i}=t;if(o.updateCount++,"initialState"===t.status&&this.setStatus(t,"loading"),!e&&(e=this.resolveFontFace(t.props),t.trFontFace=e,!e)){const e=`SdfTextRenderer: Could not resolve font face for family: '${t.props.fontFamily}'`;return console.error(e),void this.setStatus(t,"failed",new Error(e))}if(!e.loaded)return void e.on("loaded",(function r(){t.emitter.emit("fontLoaded",{}),e?.off("fontLoaded",r)}));n(e.data,"Font face data should be loaded");const{text:a,fontSize:l,x:c,y:h,contain:u,width:f,height:m,scrollable:g}=t.props,x="both"===u&&g?t.props.scrollY:0;let{renderWindow:y}=t;const v=e.data.info.size,_=l/v;t.distanceRange=_*e.data.distanceField.distanceRange;const b=24*a.length;let w=t.vertexBuffer;(!w||w.length<b)&&(w=new Float32Array(2*b));const S={x1:0,y1:0,x2:this.stage.options.appWidth,y2:this.stage.options.appHeight},T=p(S,{x1:c,y1:h,x2:"none"!==u?c+f:1/0,y2:"both"===u?h+m:1/0});if(!i&&y){if(c+y.x1<=T.x1&&c+y.x2>=T.x2&&h-x+y.y1<=T.y1&&h-x+y.y2>=T.y2)return;t.renderWindow=y=void 0}const{offsetY:C,textAlign:R}=t.props;if(!y){const t=T.y2-T.y1;y=function(t,e,r,s,o,n){const i=s*o,a=n.x1-t,l=n.y1-e;return d(n)?{x1:a,y1:l+r-i,x2:a+(n.x2-n.x1),y2:l+r+(n.y2-n.y1)+i}:{x1:0,y1:0,x2:0,y2:0}}(c,h,x,v,Math.ceil(t/v),T)}const I=function(t,e,r,s,o,n,i){let a=0;o&&(a=Math.min(Math.max(Math.floor(o.y1/t),0),n.length));const l=e/r+a*s;if(!(i&&l>=i/r))return{x:0,y:l,lineIndex:a}}(l,C,_,v,y,s,r);if(!I)return void this.setStatus(t,"loaded");const{letterSpacing:k}=t.props,E=rt(I.lineIndex,I.x,I.y,a,R,f,m,l,k,w,u,s,y,e,i,g);t.bufferUploaded=!1,t.bufferNumFloats=E.bufferNumFloats,t.bufferNumQuads=E.bufferNumQuads,t.vertexBuffer=w,t.renderWindow=y,o.lastLayoutNumCharacters=E.layoutNumCharacters,o.bufferSize=w.byteLength,E.fullyProcessed&&(t.textW=E.maxX*_,t.textH=E.maxY*_),this.setStatus(t,"loaded")}renderQuads(t,e,r,s){if(!t.vertexBuffer)return;performance.now();const{renderer:o}=this.stage;this.stage.options;const{fontSize:i,color:a,contain:l,scrollable:c,zIndex:h,debug:d}=t.props,u="both"===l&&c?t.props.scrollY:0,{textW:p=0,textH:x=0,distanceRange:y,vertexBuffer:v,bufferNumFloats:_,bufferUploaded:b,renderWindow:w,debugData:S,trFontFace:T}=t;let{webGlBuffers:C}=t;if(!C){const e=o.gl,r=4*Float32Array.BYTES_PER_ELEMENT,s=e.createBuffer();n(s),t.webGlBuffers=new f([{buffer:s,attributes:{a_position:{name:"a_position",size:2,type:e.FLOAT,normalized:!1,stride:r,offset:0},a_textureCoordinate:{name:"a_textureCoordinate",size:2,type:e.FLOAT,normalized:!1,stride:r,offset:2*Float32Array.BYTES_PER_ELEMENT}}}]),t.bufferUploaded=!1,n(t.webGlBuffers),C=t.webGlBuffers}if(!b){const e=o.gl,r=C?.getBuffer("a_textureCoordinate")??null;e.bindBuffer(e.ARRAY_BUFFER,r),e.bufferData(e.ARRAY_BUFFER,v,e.STATIC_DRAW),t.bufferUploaded=!0}n(T);const R=new m(o.gl,o.options,C,this.sdfShader,{transform:e.data,color:g(a,s),size:i/(T.data?.info.size||0),scrollY:u,distanceRange:y,debug:d.sdfShaderDebug},s,r,{height:x,width:p},0,h),I=t.trFontFace?.texture;n(I);const k=this.stage.txManager.getCtxTexture(I);R.addTexture(k),R.length=t.bufferNumFloats,R.numQuads=t.bufferNumQuads,o.addRenderable(R)}resolveFontFace(t){return q.resolveFontFace([this.msdfFontFamilies,this.ssdfFontFamilies],t)}invalidateCache(t){t.renderWindow=void 0,t.textH=void 0,t.textW=void 0,t.lineCache=[],this.setStatus(t,"loading")}}class ot{_canvas;_context;_settings;renderInfo;constructor(t,e){this._canvas=t,this._context=e,this._settings=this.mergeDefaults({})}set settings(t){this._settings=this.mergeDefaults(t)}get settings(){return this._settings}getPrecision(){return this._settings.precision}setFontProperties(){this._context.font=this._getFontSetting(),this._context.textBaseline=this._settings.textBaseline}_getFontSetting(){const t=[this._settings.fontFace],e=[];for(let r=0,s=t.length;r<s;r++)"serif"===t[r]||"sans-serif"===t[r]?e.push(t[r]):e.push(`"${t[r]}"`);return`${this._settings.fontStyle} ${this._settings.fontSize*this.getPrecision()}px ${e.join(",")}`}_load(){if(document.fonts){const e=this._getFontSetting();try{if(!document.fonts.check(e,this._settings.text))return document.fonts.load(e,this._settings.text).catch((t=>{console.warn("[Lightning] Font load error",t,e)})).then((()=>{document.fonts.check(e,this._settings.text)||console.warn("[Lightning] Font not found",e)}))}catch(t){console.warn("[Lightning] Can't check font loading for "+e)}}}calculateRenderInfo(){const t={},e=this.getPrecision(),r=this._settings.paddingLeft*e,s=this._settings.paddingRight*e,o=this._settings.fontSize*e;let n=null===this._settings.offsetY?null:this._settings.offsetY*e,i=(this._settings.lineHeight||o)*e;const a=this._settings.w*e,l=this._settings.h*e;let c=this._settings.wordWrapWidth*e;const h=this._settings.cutSx*e,d=this._settings.cutEx*e,u=this._settings.cutSy*e,p=this._settings.cutEy*e,f=(this._settings.letterSpacing||0)*e,m=this._settings.textIndent*e;this.setFontProperties();let g,x=a||2048/this.getPrecision(),y=x-r;if(y<10&&(x+=10-y,y=10),c||(c=y),this._settings.textOverflow&&!this._settings.wordWrap){let t;switch(this._settings.textOverflow){case"clip":t="";break;case"ellipsis":t=this._settings.maxLinesSuffix;break;default:t=this._settings.textOverflow}this._settings.text=this.wrapWord(this._settings.text,c-m,t)}if(this._settings.wordWrap)g=this.wrapText(this._settings.text,c,f,m);else{g={l:this._settings.text.split(/(?:\r\n|\r|\n)/),n:[]};const t=g.l.length;for(let e=0;e<t-1;e++)g.n.push(e)}let v=g.l;if(this._settings.maxLines&&v.length>this._settings.maxLines){const e=v.slice(0,this._settings.maxLines);let r,s=null;if(this._settings.maxLinesSuffix){const t=this._settings.maxLinesSuffix?this.measureText(this._settings.maxLinesSuffix):0,r=this.wrapText(e[e.length-1],c-t,f,m);e[e.length-1]=`${r.l[0]}${this._settings.maxLinesSuffix}`,s=[r.l.length>1?r.l[1]:""]}else s=[""];const o=v.length;let n=0;const i=g.n.length;for(r=this._settings.maxLines;r<o;r++)s[n]+=`${s[n]?" ":""}${v[r]}`,r+1<i&&g.n[r+1]&&n++;t.remainingText=s.join("\n"),t.moreTextLines=!0,v=e}else t.moreTextLines=!1,t.remainingText="";let _=0;const b=[];for(let S=0;S<v.length;S++){const t=this.measureText(v[S],f)+(0===S?m:0);b.push(t),_=Math.max(_,t)}let w;if(t.lineWidths=b,a||(x=_+r+s,y=_),i=i||o,l)w=l;else{const t="bottom"!=this._settings.textBaseline?.5*o:0;w=i*(v.length-1)+t+Math.max(i,o)+(n||0)}return null===n&&(n=o),t.w=x,t.h=w,t.lines=v,t.precision=e,x||(x=1),w||(w=1),(h||d)&&(x=Math.min(x,d-h)),(u||p)&&(w=Math.min(w,p-u)),t.width=x,t.innerWidth=y,t.height=w,t.fontSize=o,t.cutSx=h,t.cutSy=u,t.cutEx=d,t.cutEy=p,t.lineHeight=i,t.lineWidths=b,t.offsetY=n,t.paddingLeft=r,t.paddingRight=s,t.letterSpacing=f,t.textIndent=m,t}draw(t,e){const r=this.getPrecision(),s=e?.lines||t.lines,o=e?.lineWidths||t.lineWidths,n=e?e.lines.length*t.lineHeight:t.height;let i,a;this._canvas.width=Math.min(Math.ceil(t.width+this._settings.textRenderIssueMargin),2048),this._canvas.height=Math.min(Math.ceil(n),2048),this.setFontProperties(),t.fontSize>=128&&(this._context.globalAlpha=.01,this._context.fillRect(0,0,.01,.01),this._context.globalAlpha=1),(t.cutSx||t.cutSy)&&this._context.translate(-t.cutSx,-t.cutSy);const l=[];for(let h=0,d=s.length;h<d;h++)i=0===h?t.textIndent:0,a=h*t.lineHeight+t.offsetY,"middle"==this._settings.verticalAlign?a+=(t.lineHeight-t.fontSize)/2:"bottom"==this._settings.verticalAlign&&(a+=t.lineHeight-t.fontSize),"right"===this._settings.textAlign?i+=t.innerWidth-o[h]:"center"===this._settings.textAlign&&(i+=(t.innerWidth-o[h])/2),i+=t.paddingLeft,l.push({text:s[h],x:i,y:a,w:o[h]});if(this._settings.highlight){const e=this._settings.highlightColor,s=this._settings.highlightHeight*r||1.5*t.fontSize,o=this._settings.highlightOffset*r,n=null!==this._settings.highlightPaddingLeft?this._settings.highlightPaddingLeft*r:t.paddingLeft,i=null!==this._settings.highlightPaddingRight?this._settings.highlightPaddingRight*r:t.paddingRight;this._context.fillStyle=x(e);for(let r=0;r<l.length;r++){const e=l[r];this._context.fillRect(e.x-n,e.y-t.offsetY+o,e.w+i+n,s)}}let c=null;this._settings.shadow&&(c=[this._context.shadowColor,this._context.shadowOffsetX,this._context.shadowOffsetY,this._context.shadowBlur],this._context.shadowColor=x(this._settings.shadowColor),this._context.shadowOffsetX=this._settings.shadowOffsetX*r,this._context.shadowOffsetY=this._settings.shadowOffsetY*r,this._context.shadowBlur=this._settings.shadowBlur*r),this._context.fillStyle=x(this._settings.textColor);for(let h=0,d=l.length;h<d;h++){const e=l[h];if(0===t.letterSpacing)this._context.fillText(e.text,e.x,e.y);else{const r=e.text.split("");let s=e.x;for(let o=0,n=r.length;o<n;o++)this._context.fillText(r[o],s,e.y),s+=this.measureText(r[o],t.letterSpacing)}}c&&(this._context.shadowColor=c[0],this._context.shadowOffsetX=c[1],this._context.shadowOffsetY=c[2],this._context.shadowBlur=c[3]),(t.cutSx||t.cutSy)&&this._context.translate(t.cutSx,t.cutSy),this.renderInfo=t}wrapWord(t,e,r){const s=this._context.measureText(r).width,o=t.length,n=this._context.measureText(t).width;if(n<=e)return t;let i=Math.floor(e*o/n),a=this._context.measureText(t.substring(0,i)).width+s;if(a>e)for(;i>0&&(a=this._context.measureText(t.substring(0,i)).width+s,a>e);)i-=1;else for(;i<o;){if(a=this._context.measureText(t.substring(0,i)).width+s,!(a<e)){i-=1;break}i+=1}return t.substring(0,i)+(e>=s?r:"")}wrapText(t,e,r,s=0){const o=t.split(/\r?\n/g);let n=[];const i=[];for(let a=0;a<o.length;a++){const t=[];let l="",c=e-s;const h=o[a].split(" ");for(let o=0;o<h.length;o++){const n=this.measureText(h[o],r),i=n+this.measureText(" ",r);0===o||i>c?(o>0&&(t.push(l),l=""),l+=h[o],c=e-n-(0===o?s:0)):(c-=i,l+=` ${h[o]}`)}t.push(l),l="",n=n.concat(t),a<o.length-1&&i.push(n.length)}return{l:n,n:i}}measureText(t,e=0){return e?t.split("").reduce(((t,r)=>t+this._context.measureText(r).width+e),0):this._context.measureText(t).width}mergeDefaults(t){return{text:"",w:0,h:0,fontStyle:"normal",fontSize:40,fontFace:null,wordWrap:!0,wordWrapWidth:0,wordBreak:!1,textOverflow:"",lineHeight:null,textBaseline:"alphabetic",textAlign:"left",verticalAlign:"top",offsetY:null,maxLines:0,maxLinesSuffix:"..",textColor:[1,1,1,1],paddingLeft:0,paddingRight:0,shadow:!1,shadowColor:[0,0,0,1],shadowOffsetX:0,shadowOffsetY:0,shadowBlur:5,highlight:!1,highlightHeight:0,highlightColor:[0,0,0,1],highlightOffset:0,highlightPaddingLeft:0,highlightPaddingRight:0,letterSpacing:0,textIndent:0,cutSx:0,cutEx:0,cutSy:0,cutEy:0,advancedRenderer:!1,fontBaselineRatio:0,precision:1,textRenderIssueMargin:0,...t}}}const nt="undefined"==typeof self?globalThis:self,it=nt.document?.fonts||nt.fonts;class at extends J{canvas;context;constructor(t){super(t),"undefined"!=typeof OffscreenCanvas?this.canvas=new OffscreenCanvas(0,0):this.canvas=document.createElement("canvas");let e=this.canvas.getContext("2d");e||(this.canvas=document.createElement("canvas"),e=this.canvas.getContext("2d")),n(e),this.context=e}getPropertySetters(){return{fontFamily:(t,e)=>{t.props.fontFamily=e,t.fontInfo=void 0,this.markForReload(t)},fontWeight:(t,e)=>{t.props.fontWeight=e,t.fontInfo=void 0,this.markForReload(t)},fontStyle:(t,e)=>{t.props.fontStyle=e,t.fontInfo=void 0,this.markForReload(t)},fontStretch:(t,e)=>{t.props.fontStretch=e,t.fontInfo=void 0,this.markForReload(t)},fontSize:(t,e)=>{t.props.fontSize=e,t.fontInfo=void 0,this.markForReload(t)},text:(t,e)=>{t.props.text=e,this.markForReload(t)},textAlign:(t,e)=>{t.props.textAlign=e,this.markForReload(t)},color:(t,e)=>{t.props.color=e,this.markForReload(t)},x:(t,e)=>{t.props.x=e},y:(t,e)=>{t.props.y=e},contain:(t,e)=>{t.props.contain=e,this.markForReload(t)},width:(t,e)=>{t.props.width=e,this.markForReload(t)},height:(t,e)=>{t.props.height=e,this.markForReload(t)},offsetY:(t,e)=>{t.props.offsetY=e,this.markForReload(t)},scrollY:(t,e)=>{t.props.scrollY=e},letterSpacing:(t,e)=>{t.props.letterSpacing=e,this.markForReload(t)}}}canRenderFont(t){return!0}isFontFaceSupported(t){return t instanceof y}addFontFace(t){n(t instanceof y),it.add(t.fontFace)}createState(t){return{props:t,status:"initialState",emitter:new r,canvasPages:void 0,lightning2TextRenderer:new ot(this.canvas,this.context),renderWindow:void 0,renderInfo:void 0,forceFullLayoutCalc:!1,textW:0,textH:0,fontInfo:void 0,fontFaceLoadedHandler:void 0,debugData:{updateCount:0,layoutCount:0,drawCount:0,lastLayoutNumCharacters:0,layoutSum:0,drawSum:0,bufferSize:0}}}updateState(t){if("initialState"===t.status&&this.setStatus(t,"loading"),!t.fontInfo){const e=function(t){const{fontFamily:e,fontStyle:r,fontWeight:s,fontStretch:o,fontSize:n}=t;return[r,s,o,`${n}px`,e].join(" ")}(t.props);if(t.fontInfo={cssString:e,loaded:!1},!t.fontInfo.loaded)return void it.load(e).then(this.onFontLoaded.bind(this,t,e)).catch(this.onFontLoadError.bind(this,t,e))}if(!t.fontInfo.loaded)return;if(!t.renderInfo){t.lightning2TextRenderer.settings={text:t.props.text,textAlign:t.props.textAlign,fontFace:t.props.fontFamily,fontSize:t.props.fontSize,fontStyle:[t.props.fontStretch,t.props.fontStyle,t.props.fontWeight].join(" "),textColor:a(t.props.color),offsetY:t.props.fontSize+t.props.offsetY,wordWrap:"none"!==t.props.contain,wordWrapWidth:"none"===t.props.contain?void 0:t.props.width,letterSpacing:t.props.letterSpacing};const e=performance.now();t.renderInfo=t.lightning2TextRenderer.calculateRenderInfo(),console.log("Render info calculated in",performance.now()-e,"ms"),t.textH=t.renderInfo.lineHeight*t.renderInfo.lines.length,t.textW=t.renderInfo.width,t.renderWindow=void 0}const{x:e,y:r,width:s,height:o,scrollY:n,contain:i}=t.props;let{renderWindow:l,canvasPages:c}=t;const h={x1:0,y1:0,x2:this.stage.options.appWidth,y2:this.stage.options.appHeight},d=p(h,{x1:e,y1:r,x2:"none"!==i?e+s:1/0,y2:"both"===i?r+o:1/0}),u=d.y2-d.y1,f=Math.ceil(u/t.renderInfo.lineHeight);if(l&&c){const s=e+l.x1,o=r-n+l.y1,i=e+l.x2,a=r-n+l.y2;if(s<=d.x1&&i>=d.x2&&o<=d.y1&&a>=d.y2)return;a<d.y2?(l.y1+=f*t.renderInfo.lineHeight,l.y2+=f*t.renderInfo.lineHeight,c.push(c.shift()),c[2].lineNumStart=c[1].lineNumStart+f,c[2].lineNumEnd=c[2].lineNumStart+f,c[2].valid=!1):o>d.y1&&(l.y1-=f*t.renderInfo.lineHeight,l.y2-=f*t.renderInfo.lineHeight,c.unshift(c.pop()),c[0].lineNumStart=c[1].lineNumStart-f,c[0].lineNumEnd=c[0].lineNumStart+f,c[0].valid=!1)}else{const e=t.renderInfo.lineHeight*f,r=Math.ceil(n/e)*f,o=r-f,i=r+f;c=[{texture:c?.[0].texture,lineNumStart:o,lineNumEnd:o+f,valid:!1},{texture:c?.[1].texture,lineNumStart:r,lineNumEnd:r+f,valid:!1},{texture:c?.[2].texture,lineNumStart:i,lineNumEnd:i+f,valid:!1}],t.canvasPages=c;const a=Math.ceil(n/e)*e;l={x1:0,y1:a-e,x2:s,y2:a+2*e}}t.renderWindow=l;const m=performance.now();for(const a of c)a.valid||(a.lineNumStart<0?(a.texture=this.stage.txManager.loadTexture("ImageTexture",{src:""}),a.valid=!0):(t.lightning2TextRenderer.draw(t.renderInfo,{lines:t.renderInfo.lines.slice(a.lineNumStart,a.lineNumEnd),lineWidths:t.renderInfo.lineWidths.slice(a.lineNumStart,a.lineNumEnd)}),0!==this.canvas.width&&0!==this.canvas.height&&(a.texture=this.stage.txManager.loadTexture("ImageTexture",{src:this.context.getImageData(0,0,this.canvas.width,this.canvas.height)},{preload:!0})),a.valid=!0));console.log("pageDrawTime",performance.now()-m,"ms"),this.setStatus(t,"loaded")}renderQuads(t,e,r,s){const{stage:o}=this,{canvasPages:i,textW:a=0,textH:l=0,renderWindow:c}=t;if(!i||!c)return;const{x:h,y:d,scrollY:u,contain:p,width:f,height:m}=t.props,g={x:h,y:d,width:"none"!==p?f:a,height:"both"===p?m:l};v({x:0,y:0,width:o.options.appWidth,height:o.options.appHeight},g),n(i,"canvasPages is not defined"),n(c,"renderWindow is not defined");const x=(c.y2-c.y1)/3,{zIndex:y,color:b}=t.props,w=s*_(b);i[0].valid&&this.stage.renderer.addRenderable({alpha:w,clippingRect:r,colorBl:4294967295,colorBr:4294967295,colorTl:4294967295,colorTr:4294967295,width:i[0].texture?.dimensions?.width||0,height:i[0].texture?.dimensions?.height||0,texture:i[0].texture,textureOptions:{},shader:null,shaderProps:null,zIndex:y,tx:e.tx,ty:e.ty-u+c.y1,ta:e.ta,tb:e.tb,tc:e.tc,td:e.td}),i[1].valid&&this.stage.renderer.addRenderable({alpha:w,clippingRect:r,colorBl:4294967295,colorBr:4294967295,colorTl:4294967295,colorTr:4294967295,width:i[1].texture?.dimensions?.width||0,height:i[1].texture?.dimensions?.height||0,texture:i[1].texture,textureOptions:{},shader:null,shaderProps:null,zIndex:y,tx:e.tx,ty:e.ty-u+c.y1+x,ta:e.ta,tb:e.tb,tc:e.tc,td:e.td}),i[2].valid&&this.stage.renderer.addRenderable({alpha:w,clippingRect:r,colorBl:4294967295,colorBr:4294967295,colorTl:4294967295,colorTr:4294967295,width:i[2].texture?.dimensions?.width||0,height:i[2].texture?.dimensions?.height||0,texture:i[2].texture,textureOptions:{},shader:null,shaderProps:null,zIndex:y,tx:e.tx,ty:e.ty-u+c.y1+x+x,ta:e.ta,tb:e.tb,tc:e.tc,td:e.td})}markForReload(t){t.renderInfo=void 0,this.setStatus(t,"loading")}onFontLoaded(t,e){e===t.fontInfo?.cssString&&t.fontInfo&&(t.fontInfo.loaded=!0,this.updateState(t))}onFontLoadError(t,e,r){e===t.fontInfo?.cssString&&t.fontInfo&&(t.fontInfo.loaded=!0,console.error(`CanvasTextRenderer: Error loading font '${t.fontInfo.cssString}'`,r),this.updateState(t))}}t("S",class{options;animationManager;txManager;fontManager;textRenderers;shManager;renderer;scene;deltaTime=0;lastFrameTime=0;currentFrameTime=0;constructor(t){this.options=t;const{canvas:e,clearColor:r,rootId:s,debug:o,appWidth:i,appHeight:a}=t;this.txManager=new V,this.shManager=new U,this.animationManager=new G,o?.monitorTextureCache&&setInterval((()=>{n(this.txManager);const t=this.txManager.getDebugInfo();console.log("Texture ID Cache Size: ",t.idCacheSize),console.log("Texture Key Cache Size: ",t.keyCacheSize)}),1e3),this.renderer=new b({stage:this,canvas:e,pixelRatio:t.devicePhysicalPixelRatio*t.deviceLogicalPixelRatio,clearColor:r??4278190080,bufferMemory:2e6,txManager:this.txManager,shManager:this.shManager}),this.txManager.renderer=this.renderer,this.textRenderers={canvas:new at(this),sdf:new st(this)},this.fontManager=new q(this.textRenderers);const l=new C(this,{id:s,x:0,y:0,width:i,height:a,alpha:1,clipping:!1,color:0,colorTop:0,colorBottom:0,colorLeft:0,colorRight:0,colorTl:0,colorTr:0,colorBl:0,colorBr:0,zIndex:0,zIndexLocked:0,scaleX:1,scaleY:1,mountX:0,mountY:0,mount:0,pivot:.5,pivotX:.5,pivotY:.5,rotation:0,parent:null,texture:null,textureOptions:null,shader:null,shaderProps:null});this.scene=new R(l),(t=>{const e=()=>{t.drawFrame(),requestAnimationFrame(e)};requestAnimationFrame(e)})(this)}drawFrame(){const{renderer:t,scene:e,animationManager:r}=this;e?.root&&(this.lastFrameTime=this.currentFrameTime,this.currentFrameTime=performance?performance.now():Date.now(),this.deltaTime=this.lastFrameTime?this.currentFrameTime-this.lastFrameTime:100/6,r.update(this.deltaTime),t?.reset(),e?.root?.hasUpdates&&e?.root?.update(this.deltaTime),this.addQuads(e.root),t?.sortRenderables(),t?.render())}addQuads(t,e=null){n(this.renderer&&t.globalTransform);const r=t.globalTransform,s=0!==r.tb||0!==r.tc;let o=t.clipping&&!s?{x:r.tx,y:r.ty,width:t.width*r.ta,height:t.height*r.td}:null;e&&o?o=v(e,o):e&&(o=e),t.renderQuads(this.renderer,o),t.children.forEach((t=>{0!==t.worldAlpha&&this.addQuads(t,o)}))}resolveTextRenderer(t,e=null){let r=e,s=!1;if(r){const e=this.textRenderers[r];e?e.canRenderFont(t)||(console.warn(`Cannot use override text renderer '${r}' for font`,t),r=null,s=!0):(console.warn(`Text renderer override '${r}' not found.`),r=null,s=!0)}if(!r){for(const[e,s]of Object.entries(this.textRenderers))if("canvas"!==e&&s.canRenderFont(t)){r=e;break}r||(r="canvas")}s&&console.warn(`Falling back to text renderer ${String(r)}`);const o=this.textRenderers[r];return n(o,"resolvedTextRenderer undefined"),o}get root(){return this.scene?.root||null}}),t("c",class extends C{textRenderer;trState;updateScheduled;_textRendererOverride=null;constructor(t,e){super(t,e),this.updateScheduled=!1,this._textRendererOverride=e.textRendererOverride;const{resolvedTextRenderer:r,textRendererState:s}=this.resolveTextRendererAndState({x:this.absX,y:this.absY,width:e.width,height:e.height,textAlign:e.textAlign,color:e.color,zIndex:e.zIndex,contain:e.contain,scaleX:e.scaleX,scaleY:e.scaleY,scrollable:e.scrollable,scrollY:e.scrollY,offsetY:e.offsetY,letterSpacing:e.letterSpacing,debug:e.debug,fontFamily:e.fontFamily,fontSize:e.fontSize,fontStretch:e.fontStretch,fontStyle:e.fontStyle,fontWeight:e.fontWeight,text:e.text},void 0);this.textRenderer=r,this.trState=s}onTextLoaded=()=>{const{contain:t}=this,e=this.trState.props.width,r=this.trState.props.height,s=this.trState.textW||0,o=this.trState.textH||0;"both"===t?(this.props.width=e,this.props.height=r):"width"===t?(this.props.width=e,this.props.height=o):"none"===t&&(this.props.width=s,this.props.height=o),this.updateLocalTransform(),this.emit("loaded",{type:"text",dimensions:{width:this.trState.textW||0,height:this.trState.textH||0}})};onTextFailed=(t,e)=>{this.emit("failed",{type:"text",error:e})};get width(){return this.trState.props.width}set width(t){this.textRenderer.set.width(this.trState,t),this.updateText()}get height(){return this.trState.props.height}set height(t){this.textRenderer.set.height(this.trState,t),this.updateText()}get color(){return this.trState.props.color}set color(t){this.textRenderer.set.color(this.trState,t),this.updateText()}get text(){return this.trState.props.text}set text(t){this.textRenderer.set.text(this.trState,t),this.updateText()}get textRendererOverride(){return this._textRendererOverride}set textRendererOverride(t){this._textRendererOverride=t;const{resolvedTextRenderer:e,textRendererState:r}=this.resolveTextRendererAndState(this.trState.props,this.trState);this.textRenderer=e,this.trState=r}get fontSize(){return this.trState.props.fontSize}set fontSize(t){this.textRenderer.set.fontSize(this.trState,t),this.updateText()}get fontFamily(){return this.trState.props.fontFamily}set fontFamily(t){this.textRenderer.set.fontFamily(this.trState,t),this.updateText()}get fontStretch(){return this.trState.props.fontStretch}set fontStretch(t){this.textRenderer.set.fontStretch(this.trState,t),this.updateText()}get fontStyle(){return this.trState.props.fontStyle}set fontStyle(t){this.textRenderer.set.fontStyle(this.trState,t),this.updateText()}get fontWeight(){return this.trState.props.fontWeight}set fontWeight(t){this.textRenderer.set.fontWeight(this.trState,t),this.updateText()}get textAlign(){return this.trState.props.textAlign}set textAlign(t){this.textRenderer.set.textAlign(this.trState,t),this.updateText()}get contain(){return this.trState.props.contain}set contain(t){this.textRenderer.set.contain(this.trState,t),this.updateText()}get scrollable(){return this.trState.props.scrollable}set scrollable(t){this.textRenderer.set.scrollable(this.trState,t),this.updateText()}get scrollY(){return this.trState.props.scrollY}set scrollY(t){this.textRenderer.set.scrollY(this.trState,t),this.updateText()}get offsetY(){return this.trState.props.offsetY}set offsetY(t){this.textRenderer.set.offsetY(this.trState,t),this.updateText()}get letterSpacing(){return this.trState.props.letterSpacing}set letterSpacing(t){this.textRenderer.set.letterSpacing(this.trState,t),this.updateText()}get debug(){return this.trState.props.debug}set debug(t){this.textRenderer.set.debug(this.trState,t),this.updateText()}update(t){super.update(t),n(this.globalTransform),this.textRenderer.set.x(this.trState,this.globalTransform.tx),this.textRenderer.set.y(this.trState,this.globalTransform.ty),"loading"===this.trState.status&&this.textRenderer.updateState(this.trState)}updateText(){this.updateScheduled||(this.updateScheduled=!0,queueMicrotask((()=>{this.updateScheduled=!1,this.textRenderer.updateState(this.trState)})))}renderQuads(t,e){n(this.globalTransform),this.textRenderer.renderQuads(this.trState,this.globalTransform,e,this.worldAlpha)}resolveTextRendererAndState(t,e){const r=this.stage.resolveTextRenderer(t,this._textRendererOverride),s=r.createState(t);return e&&["loading","loaded","failed"].forEach((t=>{e.emitter.off(t)})),s.emitter.on("loading",(()=>{s.emitter.once("fontLoaded",(()=>{this.updateText()})),s.emitter.once("loaded",(()=>{s.emitter.off("fontLoaded")}))})),s.emitter.on("loaded",this.onTextLoaded),s.emitter.on("failed",this.onTextFailed),this.updateText(),{resolvedTextRenderer:r,textRendererState:s}}});const lt=function(t,e,r){return t()},ct="undefined"==typeof self?globalThis:self;function ht(t,e){if(!t)throw new Error(e||"Assertion failed")}class dt{threadx;sharedObjectStruct;mutations;waitPromise=null;mutationsQueued=!1;static staticInitialized=!1;_id;_typeId;initialized=!1;destroying=!1;curProps;static extractBuffer(t){if(t.destroying||!t.sharedObjectStruct)throw new Error("SharedObject.extractBuffer(): SharedObject is or was being destroyed.");return t.sharedObjectStruct.buffer}constructor(t,e){this.curProps=e,this.threadx=gt.instance,this.sharedObjectStruct=t,this._id=t.id,this._typeId=t.typeId;const r=this.constructor;if(!Object.prototype.hasOwnProperty.call(r,"staticInitialized")||!r.staticInitialized){r.staticInitialized=!0;const t=Object.getPrototypeOf(this);Object.keys(e).forEach((e=>{Object.defineProperty(t,e,{get:function(){return this.curProps[e]},set:function(t){this.curProps[e]=t,this.mutations[e]=!0,this.queueMutations()}})}))}this.mutations={},this._executeMutations(),this.initialized=!0}get typeId(){return this._typeId}get id(){return this._id}processDirtyProperties(){if(!this.sharedObjectStruct)throw new Error("SharedObject was destroyed");const{sharedObjectStruct:t,mutations:e,curProps:r}=this;t.constructor.propDefs.forEach(((s,o)=>{if(t.isDirty(o)){const o=s.name;delete e[o];const n=r[o];r[o]=t[o],this.initialized&&this.onPropertyChange(o,t[o],n)}})),t.resetDirty()}onPropertyChange(t,e,r){}queueMutations(){this.mutationsQueued||(this.mutationsQueued=!0,queueMicrotask((()=>{this.mutationsQueued=!1,this.sharedObjectStruct&&this.mutationMicrotask().catch(console.error)})))}async mutationMicrotask(){if(!this.sharedObjectStruct)throw new Error("SharedObject was destroyed");await this.sharedObjectStruct.lockAsync((async()=>{this._executeMutations()})),this.destroying&&this.finishDestroy()}flush(){if(this.destroying||!this.sharedObjectStruct)throw new Error("SharedObject was destroyed");this.sharedObjectStruct.lock((()=>{this._executeMutations()}))}onDestroy(){}destroy(){const t=this.sharedObjectStruct;!this.destroying&&t&&(this.emit("beforeDestroy",{},{localOnly:!0}),this.destroying=!0,this.onDestroy(),this.queueMutations())}finishDestroy(){const t=this.sharedObjectStruct;this.destroying&&t&&(this.threadx.forgetObjects([this],{silent:!0}).catch(console.error),this.sharedObjectStruct=null,t.notify(),this.emit("afterDestroy",{},{localOnly:!0}),this.eventListeners={})}get isDestroyed(){return null===this.sharedObjectStruct}_executeMutations(){if(!this.sharedObjectStruct)return;this.sharedObjectStruct.notifyValue!==this.threadx.workerId&&this.sharedObjectStruct.isDirty()&&this.processDirtyProperties();const{mutations:t}=this;this.mutations={};for(const s in t)if(Object.prototype.hasOwnProperty.call(t,s)){const t=this.curProps[s];this.sharedObjectStruct[s],this.sharedObjectStruct[s]=t}this.waitPromise&&(this.waitPromise=null);let e=this.sharedObjectStruct.notifyValue;this.sharedObjectStruct.isDirty()&&(this.sharedObjectStruct.notify(this.threadx.workerId),e=this.threadx.workerId);const r=this.sharedObjectStruct.waitAsync(e).then((async t=>{this.waitPromise===r&&this.sharedObjectStruct&&(ht("ok"===t),this.waitPromise=null,await this.mutationMicrotask())}));this.waitPromise=r}eventListeners={};on(t,e){let r=this.eventListeners[t];r||(r=[]),r.push(e),this.eventListeners[t]=r}off(t,e){const r=this.eventListeners[t];if(!r)return;const s=r.indexOf(e);s>=0&&r.splice(s,1)}once(t,e){const r=(s,o)=>{this.off(t,r),e(s,o)};this.on(t,r)}emit(t,e,r={}){const s=this.eventListeners[t];r.localOnly||gt.instance.__sharedObjectEmit(this,t,e),s&&[...s].forEach((t=>{t(this,e)}))}}function ut(t){return t>=65&&t<=90||t>=48&&t<=57}function pt(t){let e=0;if(0===t.length)throw new Error("genTypeId: Type ID string must be at least 1 character");if(t.length>4)throw new Error("genTypeId: Type ID string must be 4 characters or less");for(let r=0;r<t.length;r++){let s=t.charCodeAt(r);if(s!=s)s=0;else if(!ut(s))throw new Error(`genTypeId: Invalid character '${t[r]}' (char code: ${s}) in type ID string. A-Z and 0-9 only.`);e|=s<<8*r}return e}function ft(t){const e=[];for(let r=0;r<4;r++){const s=255&t;if(ut(s))e.push(String.fromCharCode(s));else if(0!==s||0===r)return"????";t>>>=8}return e.join("")}function mt(t,e){return"object"==typeof e&&null!==e&&"threadXMessageType"in e&&e.threadXMessageType===t}class gt{static init(t){if(ct.THREADX)throw new Error("ThreadX.init(): ThreadX already initialized.");const e=new gt(t);return ct.THREADX=e,e}static destroy(){ct.THREADX?delete ct.THREADX:console.warn("ThreadX.destroy(): ThreadX is not initialized.")}static get workerId(){if(!ct.THREADX)throw new Error("ThreadX not initialized");return ct.THREADX.workerId}static get workerName(){if(!ct.THREADX)throw new Error("ThreadX not initialized");return ct.THREADX.workerName}static get instance(){if(!ct.THREADX)throw new Error("ThreadX not initialized");return ct.THREADX}workerId;workerName;sharedObjectFactory;onSharedObjectCreated;onBeforeObjectForgotten;onUserMessage;sharedObjects=new Map;sharedObjectData=new WeakMap;workers=new Map;workerReadyPromises=new Map;pendingAsyncMsgs=new Map;nextAsyncMsgId=0;nextUniqueId=0;suppressSharedObjectEmit=!1;constructor(t){this.workerId=t.workerId,this.workerName=t.workerName,this.nextUniqueId=1e13*t.workerId+1,this.sharedObjectFactory=t.sharedObjectFactory,this.onSharedObjectCreated=t.onObjectShared,this.onBeforeObjectForgotten=t.onBeforeObjectForgotten,this.onUserMessage=t.onMessage;const e=ct;"function"==typeof e.DedicatedWorkerGlobalScope&&(this.registerWorker("parent",e),this.sendMessage("parent",{threadXMessageType:"ready"}))}registerWorker(t,e){let r,s;this.workers.set(t,e),"parent"===t?(s=Promise.resolve(),r=()=>{}):s=new Promise((t=>{r=t})),this.workerReadyPromises.set(t,{promise:s,resolve:r}),this.listenForWorkerMessages(t,e)}closeWorker(t){if(!this.workers.has(t))throw new Error(`Worker ${t} not registered.`);this.closeWorkerAsync(t).catch(console.error)}async closeWorkerAsync(t,e=5e3){const r=this.workers.get(t);if(!r)throw new Error(`Worker ${t} not registered.`);const s=await Promise.race([new Promise((t=>{setTimeout((()=>{t(!1)}),e)})),this.sendMessageAsync(t,{threadXMessageType:"close"})]);return this.workers.delete(t),this.workerReadyPromises.delete(t),s?"graceful":(console.warn(`threadX.closeWorkerAsync(): Worker "${t}" did not respond to "close" message within ${e}ms. Forcing termination.`),r.terminate?.(),"forced")}listenForWorkerMessages(t,e){e.addEventListener("message",(r=>{const{data:s}=r,o=s.__asyncMsgId;this.onMessage(t,s).then((t=>{void 0!==o&&e.postMessage({threadXMessageType:"response",asyncMsgId:o,data:t})})).catch((t=>{void 0!==o&&e.postMessage({threadXMessageType:"response",asyncMsgId:o,error:!0,data:t})}))}))}async shareObjects(t,e){for(const r of e)this.sharedObjects.get(r.id)?console.warn(`ThreadX.shareObject(): SharedObject ${r.id} (TypeID: ${ft(r.typeId)}) is already shared.`):(this.sharedObjects.set(r.id,r),this.sharedObjectData.set(r,{workerName:t,shareConfirmed:!1,emitQueue:null}));await this.sendMessageAsync(t,{threadXMessageType:"shareObjects",buffers:e.map((t=>dt.extractBuffer(t)))});for(const r of e){const t=this.sharedObjectData.get(r);if(t){t.shareConfirmed=!0;const{emitQueue:e}=t;if(e){for(const t of e)this.__sharedObjectEmit(r,t[0],t[1]);t.emitQueue=null}}}}async forgetObjects(t,e={}){const r=new Map;for(const o of t)if(this.sharedObjects.has(o.id)){const t=this.sharedObjectData.get(o);ht(t);let e=r.get(t.workerName);e||(e=[],r.set(t.workerName,e)),e.push(o),this.sharedObjects.delete(o.id),this.sharedObjectData.delete(o)}else e.silent||console.warn(`ThreadX.forgetObject(): SharedObject ${o.id} (TypeID: ${ft(o.typeId)}) is not shared.`);const s=[];for(const[o,n]of r)s.push(this.sendMessageAsync(o,{threadXMessageType:"forgetObjects",objectIds:n.map((t=>t.id))}));await Promise.all(s)}sendMessage(t,e,r){if(!this.workers.get(t))throw new Error(`ThreadX.sendMessage(): Worker '${t}' not registered.`);this.sendMessageAsync(t,e,r,{skipResponseWait:!0}).catch(console.error)}async sendMessageAsync(t,e,r,s={}){const o=this.workers.get(t);if(!o)throw new Error(`ThreadX.execMessage(): Worker '${t}' not registered.`);if(await this.workerReadyPromises.get(t).promise,s.skipResponseWait)return void o.postMessage(e,r);const n=this.nextAsyncMsgId++,i=new Promise(((t,e)=>{this.pendingAsyncMsgs.set(n,{resolve:t,reject:e})}));return e.__asyncMsgId=n,o.postMessage(e,r),i}async onMessage(t,e){if(mt("shareObjects",e))e.buffers.forEach((e=>{const r=this.sharedObjectFactory?.(e);if(!r)throw new Error("ThreadX.onMesasge(): Failed to create shared object.");this.sharedObjects.set(r.id,r),this.sharedObjectData.set(r,{workerName:t,shareConfirmed:!0,emitQueue:null}),this.onSharedObjectCreated?.(r)}));else if(mt("forgetObjects",e))e.objectIds.forEach((t=>{const e=this.sharedObjects.get(t);e&&(this.onBeforeObjectForgotten?.(e),this.sharedObjects.delete(t),e.destroy())}));else if(mt("sharedObjectEmit",e)){const t=this.sharedObjects.get(e.sharedObjectId);if(!t)return;this.suppressSharedObjectEmit=!0,t.emit(e.eventName,e.data),this.suppressSharedObjectEmit=!1}else if(mt("response",e)){const t=this.pendingAsyncMsgs.get(e.asyncMsgId);if(!t)throw new Error(`ThreadX.onMessage(): Received response for unknown request (ID: ${e.asyncMsgId})`);this.pendingAsyncMsgs.delete(e.asyncMsgId),e.error?t.reject(e.data):t.resolve(e.data)}else{if(mt("close",e))return ct.close(),!0;if(mt("ready",e))return this.workerReadyPromises.get(t)?.resolve(),!0;if(this.onUserMessage)return await this.onUserMessage(e)}}getSharedObjectById(t){return this.sharedObjects.get(t)||null}generateUniqueId(){return this.nextUniqueId++}__sharedObjectEmit(t,e,r){if(this.suppressSharedObjectEmit)return;const s=this.sharedObjectData.get(t);if(!s)return;if(!s.shareConfirmed)return s.emitQueue||(s.emitQueue=[]),void s.emitQueue.push([e,r]);const o=this.workers.get(s.workerName);ht(o,"Worker not found"),o.postMessage({threadXMessageType:"sharedObjectEmit",sharedObjectId:t.id,eventName:e,data:r})}}t("T",gt);const xt=255;function yt(t,e,r){return t===e}function vt(t,e){return t===e}function _t(t,e){return function(r,s,o){const n=r.constructor;Object.prototype.hasOwnProperty.call(n,"staticInitialized")&&n.staticInitialized||n.initStatic();let i=n.size,a=0,l=0;"string"===t?(i+=i%2,a=i/2,l=512):"int32"===t||"boolean"===t?(i+=i%4,a=i/4,l=4):"number"===t&&(i+=i%8,a=i/8,l=8);const c=n.propDefs,h=c.length,d={propNum:h,name:s,type:t,byteOffset:i,offset:a,byteSize:l};c.push(d),n.size=i+l,o.get=function(){let r;if("string"===t){const t=this.uint16array[a];if(!t)return"";if(t>xt)throw new Error(`get SharedObject.${s}: Text length is too long. Length: ${t}`);r=String.fromCharCode(...this.uint16array.slice(a+1,a+1+t))}else"int32"===t?r=this.int32array[a]:"boolean"===t?r=!!this.int32array[a]:"number"===t&&(r=this.float64array[a]);return e?.bufferToProp&&(r=e.bufferToProp(r)),r},o.set=function(r){if(e?.propToBuffer&&(r=e.propToBuffer(r)),yt("string",t)){if(!vt(r,this[s])){this.setDirty(h);let t=r.length;t>xt&&(console.error(`set SharedObject.${s}: Text length is too long. Truncating...`,t),t=xt),this.uint16array[a]=t;const e=a+1,o=e+t;let n=0;for(let s=e;s<o;s++)this.uint16array[s]=r.charCodeAt(n++)}}else yt("int32",t)?vt(r,this[s])||(this.setDirty(h),this.int32array[a]=r):yt("boolean",t)?vt(r,this[s])||(this.setDirty(h),this.int32array[a]=r?1:0):yt("number",t)&&(vt(r,this[s])||(this.setDirty(h),this.float64array[a]=r))}}}class bt{buffer;lockId=Math.floor(4294967295*Math.random());uint16array;int32array;float64array;static staticInitialized=!1;static typeId=0;static typeIdStr="";static size=32;static propDefs=[];constructor(t){const e=this.constructor;Object.prototype.hasOwnProperty.call(e,"staticInitialized")&&e.staticInitialized||e.initStatic();const r=!t;t||(t=new SharedArrayBuffer(8*Math.ceil(e.size/8))),this.buffer=t,this.uint16array=new Uint16Array(t),this.int32array=new Int32Array(t),this.float64array=new Float64Array(t);const s=e.typeId;if(r)this.int32array[0]=s,this.float64array[2]=gt.instance.generateUniqueId();else if(this.int32array[0]!==s)throw new Error(`BufferStruct: TypeId mismatch. Expected '${e.typeIdStr}', got '${ft(this.int32array[0])}'`)}static extractTypeId(t){return t.byteLength<bt.size||t.byteLength%8!=0?0:new Int32Array(t)[0]||0}static initStatic(){const t=ft(this.typeId);if("????"===t)throw new Error("BufferStruct.typeId must be set to a valid 32-bit integer");this.typeIdStr=t,this.propDefs=[...this.propDefs],this.staticInitialized=!0}setDirty(t){const e=Math.floor(t/32),r=t-32*e;this.int32array[6+e]=this.int32array[6+e]|1<<r}resetDirty(){this.int32array[1]=0,this.int32array[6]=0,this.int32array[7]=0}isDirty(t){if(void 0!==t){const e=Math.floor(t/32),r=t-32*e;return!!(this.int32array[6+e]&1<<r)}return!(!this.int32array[6]&&!this.int32array[7])}get typeId(){return this.int32array[0]}get id(){return this.float64array[2]}get notifyValue(){return Atomics.load(this.int32array,1)}get isLocked(){return 0!==Atomics.load(this.int32array,2)}lock(t){let e,r=Atomics.compareExchange(this.int32array,2,0,this.lockId);for(;0!==r;){try{Atomics.wait(this.int32array,2,r)}catch(s){if(!(s instanceof TypeError&&"Atomics.wait cannot be called in this context"===s.message))throw s}r=Atomics.compareExchange(this.int32array,2,0,this.lockId)}try{e=t()}finally{Atomics.store(this.int32array,2,0),Atomics.notify(this.int32array,2)}return e}async lockAsync(t){let e,r=Atomics.compareExchange(this.int32array,2,0,this.lockId);for(;0!==r;){const t=Atomics.waitAsync(this.int32array,2,r);await t.value,r=Atomics.compareExchange(this.int32array,2,0,this.lockId)}try{e=await t()}finally{Atomics.store(this.int32array,2,0),Atomics.notify(this.int32array,2)}return e}notify(t){return void 0!==t&&Atomics.store(this.int32array,1,t),Atomics.notify(this.int32array,1)}wait(t,e=1/0){return Atomics.wait(this.int32array,1,t,e)}async waitAsync(t,e=1/0){return Atomics.waitAsync(this.int32array,1,t,e).value}}t("B",bt);var wt=globalThis&&globalThis.__decorate||function(t,e,r,s){var o,n=arguments.length,i=n<3?e:null===s?s=Object.getOwnPropertyDescriptor(e,r):s;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,r,s);else for(var a=t.length-1;a>=0;a--)(o=t[a])&&(i=(n<3?o(i):n>3?o(e,r,i):o(e,r))||i);return n>3&&i&&Object.defineProperty(e,r,i),i};class St extends bt{static typeId=pt("NODE");get x(){return 0}set x(t){}get y(){return 0}set y(t){}get width(){return 0}set width(t){}get height(){return 0}set height(t){}get alpha(){return 1}set alpha(t){}get clipping(){return!1}set clipping(t){}get color(){return 0}set color(t){}get colorTop(){return 0}set colorTop(t){}get colorBottom(){return 0}set colorBottom(t){}get colorLeft(){return 0}set colorLeft(t){}get colorRight(){return 0}set colorRight(t){}get colorTl(){return 0}set colorTl(t){}get colorTr(){return 0}set colorTr(t){}get colorBl(){return 0}set colorBl(t){}get colorBr(){return 0}set colorBr(t){}get scaleX(){return 1}set scaleX(t){}get scaleY(){return 1}set scaleY(t){}get mount(){return 0}set mount(t){}get mountX(){return 0}set mountX(t){}get mountY(){return 0}set mountY(t){}get pivot(){return.5}set pivot(t){}get pivotX(){return.5}set pivotX(t){}get pivotY(){return.5}set pivotY(t){}get rotation(){return 0}set rotation(t){}get parentId(){return 0}set parentId(t){}get zIndex(){return 0}set zIndex(t){}get zIndexLocked(){return 0}set zIndexLocked(t){}}t("N",St),wt([_t("number")],St.prototype,"x",null),wt([_t("number")],St.prototype,"y",null),wt([_t("number")],St.prototype,"width",null),wt([_t("number")],St.prototype,"height",null),wt([_t("number")],St.prototype,"alpha",null),wt([_t("boolean")],St.prototype,"clipping",null),wt([_t("number")],St.prototype,"color",null),wt([_t("number")],St.prototype,"colorTop",null),wt([_t("number")],St.prototype,"colorBottom",null),wt([_t("number")],St.prototype,"colorLeft",null),wt([_t("number")],St.prototype,"colorRight",null),wt([_t("number")],St.prototype,"colorTl",null),wt([_t("number")],St.prototype,"colorTr",null),wt([_t("number")],St.prototype,"colorBl",null),wt([_t("number")],St.prototype,"colorBr",null),wt([_t("number")],St.prototype,"scaleX",null),wt([_t("number")],St.prototype,"scaleY",null),wt([_t("number")],St.prototype,"mount",null),wt([_t("number")],St.prototype,"mountX",null),wt([_t("number")],St.prototype,"mountY",null),wt([_t("number")],St.prototype,"pivot",null),wt([_t("number")],St.prototype,"pivotX",null),wt([_t("number")],St.prototype,"pivotY",null),wt([_t("number")],St.prototype,"rotation",null),wt([_t("number")],St.prototype,"parentId",null),wt([_t("number")],St.prototype,"zIndex",null),wt([_t("number")],St.prototype,"zIndexLocked",null),t("d",class extends dt{constructor(t,e){super(t,{...e,x:t.x,y:t.y,width:t.width,height:t.height,alpha:t.alpha,clipping:t.clipping,color:t.color,colorTop:t.colorTop,colorBottom:t.colorBottom,colorLeft:t.colorLeft,colorRight:t.colorRight,colorTl:t.colorTl,colorTr:t.colorTr,colorBl:t.colorBl,colorBr:t.colorBr,parentId:t.parentId,zIndex:t.zIndex,zIndexLocked:t.zIndexLocked,scaleX:t.scaleX,scaleY:t.scaleY,mount:t.mount,mountX:t.mountX,mountY:t.mountY,pivot:t.pivot,pivotX:t.pivotX,pivotY:t.pivotY,rotation:t.rotation})}});var Tt=globalThis&&globalThis.__decorate||function(t,e,r,s){var o,n=arguments.length,i=n<3?e:null===s?s=Object.getOwnPropertyDescriptor(e,r):s;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(t,e,r,s);else for(var a=t.length-1;a>=0;a--)(o=t[a])&&(i=(n<3?o(i):n>3?o(e,r,i):o(e,r))||i);return n>3&&i&&Object.defineProperty(e,r,i),i};class Ct extends St{static typeId=pt("TEXT");get text(){return""}set text(t){}get textRendererOverride(){return null}set textRendererOverride(t){}get fontSize(){return 0}set fontSize(t){}get fontFamily(){return""}set fontFamily(t){}get fontStretch(){return"normal"}set fontStretch(t){}get fontStyle(){return"normal"}set fontStyle(t){}get fontWeight(){return"normal"}set fontWeight(t){}get textAlign(){return"left"}set textAlign(t){}get contain(){return"none"}set contain(t){}get scrollable(){return!1}set scrollable(t){}get scrollY(){return 0}set scrollY(t){}get offsetY(){return 0}set offsetY(t){}get letterSpacing(){return 0}set letterSpacing(t){}}t("e",Ct),Tt([_t("string")],Ct.prototype,"text",null),Tt([_t("string",{propToBuffer:t=>t??"$$null",bufferToProp:t=>"$$null"===t?null:t})],Ct.prototype,"textRendererOverride",null),Tt([_t("number")],Ct.prototype,"fontSize",null),Tt([_t("string")],Ct.prototype,"fontFamily",null),Tt([_t("string")],Ct.prototype,"fontStretch",null),Tt([_t("string")],Ct.prototype,"fontStyle",null),Tt([_t("string")],Ct.prototype,"fontWeight",null),Tt([_t("string")],Ct.prototype,"textAlign",null),Tt([_t("string")],Ct.prototype,"contain",null),Tt([_t("boolean")],Ct.prototype,"scrollable",null),Tt([_t("number")],Ct.prototype,"scrollY",null),Tt([_t("number")],Ct.prototype,"offsetY",null),Tt([_t("number")],Ct.prototype,"letterSpacing",null)}}}));
//# sourceMappingURL=TextNodeStruct-legacy-3eebf1ba.js.map
